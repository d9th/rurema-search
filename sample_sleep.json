{
  "versions": [
    {
      "name": "all",
      "selected": false
    },
    {
      "name": "2.1.0",
      "selected": false
    },
    {
      "name": "2.2.0",
      "selected": false
    },
    {
      "name": "2.3.0",
      "selected": false
    },
    {
      "name": "2.4.0",
      "selected": false
    },
    {
      "name": "2.5.0",
      "selected": false
    },
    {
      "name": "2.6.0",
      "selected": false
    },
    {
      "name": "2.7.0",
      "selected": false
    },
    {
      "name": "3.0",
      "selected": false
    },
    {
      "name": "3.1",
      "selected": false
    },
    {
      "name": "3.2",
      "selected": false
    },
    {
      "name": "3.3",
      "selected": true
    }
  ],
  "statistics": {
    "total": 68,
    "start_offset": 1,
    "end_offset": 68,
    "elapsed_time": 0.018841981887817383
  },
  "conditions": [
    {
      "name": "version",
      "value": "3.3",
      "icon_url": "https://rurema.clear-code.com/images/version-icon.png"
    },
    {
      "name": "query",
      "value": "sleep",
      "icon_url": "https://rurema.clear-code.com/images/query-icon.png"
    }
  ],
  "corrections": [
    {
      "value": "_builtin sleep",
      "score": 10966
    },
    {
      "value": "kernel sleep",
      "score": 7310
    },
    {
      "value": "mutex sleep",
      "score": 3079
    },
    {
      "value": "sleep _builtin",
      "score": 1064
    }
  ],
  "suggestions": [],
  "entries": [
    {
      "signature": "Kernel.#sleep -> Integer",
      "score": 54379.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "sec 秒だけプログラムの実行を停止します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Kernel/m/sleep.html",
          "description": "sec 秒だけプログラムの実行を停止します。\n\nsec が省略された場合、他スレッドからの Thread#run\nなどで明示的に起こさない限り永久にスリープします。Thread#runを呼ぶとその時点で\nsleepの実行が中断されます。\n\n@param sec 停止する秒数を非負の数値で指定します。浮動小数点数も指定できます。\n           省略された場合、永久にスリープします。\n\n@return 実際に停止していた秒数 (整数に丸められた値) です。\n\n//emlist[例][ruby]{\nit = Thread.new do\n  sleep\n  puts 'it_end'\nend\n\nre = sleep 2.11\nputs re\nit.run\nre2 = sleep 0.76\nputs re2\n#=> 2\n#   it_end\n#   1\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Kernel/"
        }
      ]
    },
    {
      "signature": "Kernel.#sleep(sec) -> Integer",
      "score": 54379.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "sec 秒だけプログラムの実行を停止します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Kernel/m/sleep.html",
          "description": "sec 秒だけプログラムの実行を停止します。\n\nsec が省略された場合、他スレッドからの Thread#run\nなどで明示的に起こさない限り永久にスリープします。Thread#runを呼ぶとその時点で\nsleepの実行が中断されます。\n\n@param sec 停止する秒数を非負の数値で指定します。浮動小数点数も指定できます。\n           省略された場合、永久にスリープします。\n\n@return 実際に停止していた秒数 (整数に丸められた値) です。\n\n//emlist[例][ruby]{\nit = Thread.new do\n  sleep\n  puts 'it_end'\nend\n\nre = sleep 2.11\nputs re\nit.run\nre2 = sleep 0.76\nputs re2\n#=> 2\n#   it_end\n#   1\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Kernel/"
        }
      ]
    },
    {
      "signature": "Thread::Mutex#sleep(timeout = nil) -> Integer",
      "score": 54376.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "与えられた秒数の間ロックを解除してスリープして、実行後にまたロックします。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread=3a=3aMutex/i/sleep.html",
          "description": "与えられた秒数の間ロックを解除してスリープして、実行後にまたロックします。\n\n@param timeout スリープする秒数を指定します。省略するとスリープし続けます。\n\n@return タイムアウトした時は nil を、それ以外はスリープしていた秒数を返します。\n\n@raise ThreadError 自身がカレントスレッドによってロックされていない場合に発生します。\n\n[注意] 2.0 以降ではスリープ中でも、シグナルを受信した場合などに実行が再\n開(spurious wakeup)される場合がある点に注意してください。\n\n//emlist[例][ruby]{\nm = Mutex.new\nth = Thread.new do\n  m.lock\n  m.sleep(2)\nend\nth.status # => \"run\"\nsleep 1\nth.status # => \"sleep\"\nsleep 1\nth.status # => false\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread::Mutex",
          "label": "Thread::Mutex",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread%3A%3AMutex/"
        }
      ]
    },
    {
      "signature": "void rb_thread_sleep(int sec)",
      "score": 18301.0,
      "metadata": {
        "type": "function",
        "versions": [
          "3.3"
        ]
      },
      "summary": null,
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/function/rb_thread_sleep.html",
          "description": null,
          "snippets": []
        }
      ],
      "related_entries": []
    },
    {
      "signature": "void rb_thread_sleep_forever(void)",
      "score": 18301.0,
      "metadata": {
        "type": "function",
        "versions": [
          "3.3"
        ]
      },
      "summary": null,
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/function/rb_thread_sleep_forever.html",
          "description": null,
          "snippets": []
        }
      ],
      "related_entries": []
    },
    {
      "signature": "Process::Status",
      "score": 181.0,
      "metadata": {
        "type": "class",
        "versions": [
          "3.3"
        ]
      },
      "summary": "プロセスの終了ステータスを表すクラスです。\nメソッド Process.#wait2 などの返り値として使われます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/class/Process=3a=3aStatus.html",
          "description": "プロセスの終了ステータスを表すクラスです。\nメソッド Process.#wait2 などの返り値として使われます。\n\n=== 使用例\n\nwait を使用した例\n\n  fork { exit }\n  Process.wait\n  case\n  when $?.signaled?\n    p \"child #{$?.pid} was killed by signal #{$?.termsig}\"\n    if $?.coredump?   # システムがこのステータスをサポートしてなければ常にfalse\n      p \"child #{$?.pid} dumped core.\"\n    end\n  when $?.stopped?\n    # 実際には Process.wait を使用しているので、ここに来ることはない\n    p \"child #{$?.pid} was stopped by signal #{$?.stopsig}\"\n  when $?.exited?\n    p \"child #{$?.pid} exited normally. status=#{$?.exitstatus}\"\n  else\n    p \"unknown status %#x\" % $?.to_i\n  end\n\nSIGCHLD を trap する例\n\n  trap(:SIGCHLD) {|sig|\n\n    puts \"interrupted by signal #{sig} at #{caller[1]}\"\n    # 複数の子プロセスの終了に対して1つの SIGCHLD しか届かない\n    # 場合があるのでループさせる必要があります\n\n    while Process.waitpid(-1, Process::WNOHANG|Process::WUNTRACED)\n      case\n      when $?.signaled?\n        puts \"   child #{$?.pid} was killed by signal #{$?.termsig}\"\n        if $?.coredump?\n          puts \"   child #{$?.pid} dumped core.\"\n        end\n      when $?.stopped?\n        puts \"   child #{$?.pid} was stopped by signal #{$?.stopsig}\"\n      when $?.exited?\n        puts \"   child #{$?.pid} exited normally. status=#{$?.exitstatus}\"\n      else\n        p \"unknown status %#x\" % $?.to_i\n      end\n    end\n  }\n\n  p pid1 = fork { sleep 1; exit }\n  p pid2 = fork { loop { sleep } } # signal を待つための sleep\n  begin\n     Process.kill :STOP, pid2\n     sleep                      # SIGCHLD を待つための sleep\n     Process.kill :CONT, pid2\n     Process.kill :TERM, pid2\n     loop { sleep }             # SIGCHLD を待つための sleep\n  rescue Errno::ECHILD\n    puts \"done\"\n  end\n\n  => 12964\n     12965\n     interrupted by signal 17 at -:27:in `sleep'\n        child 12965 was stopped by signal 19\n     interrupted by signal 17 at -:30:in `sleep'\n        child 12965 was killed by signal 15\n     interrupted by signal 17 at -:30:in `sleep'\n        child 12964 exited normally. status=0\n     done",
          "snippets": []
        }
      ],
      "related_entries": []
    },
    {
      "signature": "ThreadGroup.new -> ThreadGroup",
      "score": 145.0,
      "metadata": {
        "type": "singleton-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "新たな ThreadGroup を生成して返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/ThreadGroup/s/new.html",
          "description": "新たな ThreadGroup を生成して返します。\n\n//emlist[例][ruby]{\nthread_group = ThreadGroup.new\nthread_group.add Thread.new { sleep 0.1; Thread.new { sleep 1 }; sleep 1 }\nthread_group.add Thread.new { sleep 2 }\nsleep 0.5\nthread_group.list # => [#<Thread:0x007fc6f1842d70 sleep>, #<Thread:0x007fc6f1842c80 sleep>, #<Thread:0x007fc6f080dba8 sleep>]\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "ThreadGroup",
          "label": "ThreadGroup",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:ThreadGroup/"
        }
      ]
    },
    {
      "signature": "ruby 1.6 feature",
      "score": 109.0,
      "metadata": {
        "type": "document",
        "versions": [
          "3.3"
        ]
      },
      "summary": "ruby 1.6 feature \nruby version 1.6 は安定版です。この版での変更はバグ修正がメイン\nになります。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/doc/news=2f1=2e6=2e0.html",
          "description": "ruby 1.6 feature \nruby version 1.6 は安定版です。この版での変更はバグ修正がメイン\nになります。\n\n((<stable-snapshot|URL:ftp://ftp.netlab.co.jp/pub/lang/ruby/stable-snapshot.tar.gz>)) は、日々更新される安定版の最新ソースです。\n\n== 1.6.8 (2002-12-24) -> stable-snapshot\n\n: 2003-01-22: errno\n\n    EAGAIN と EWOULDBLOCK が同じ値のシステムで、EWOULDBLOCK がなくなっ\n    ていました。現在は、このようなシステムでは、EWOULDBLOCK は、EAGAIN \n    として定義されています。(これは 1.6.7 とは異なる挙動です)\n\n        p Errno::EAGAIN\n        p Errno::EWOULDBLOCK\n\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           Errno::EAGAIN\n           Errno::EWOULDBLOCK\n\n        => ruby 1.6.8 (2002-12-24) [i586-linux]\n           Errno::EAGAIN\n           -:2: uninitialized constant EWOULDBLOCK at Errno (NameError)\n\n        => ruby 1.6.8 (2003-02-13) [i586-linux]\n           Errno::EAGAIN\n           Errno::EAGAIN\n\n== 1.6.7 (2002-03-01) -> 1.6.8 (2002-12-24)\n\n: 2002-10-02: Thread (cygwin)\n\n  Cygwin で、Thread の切替えが行われないことがありました。\n  ((<ruby-list:36058>)), ((<ruby-list:24637>))\n\n: 2002-10-01: Socket (win)\n\n  Windows でのソケットの問題が1つ解決されたようです。(どのような問題かは\n  大本のメールがわかりませんでしたが、selectで読み込み可能になったのに\n  空配列が返されるという問題なのだそうです) ((<ruby-talk:40015>)),\n  ((<ruby-win32:366>))\n\n: 2002-09-12: Thread.status (?)\n\n  シグナルを trap でトラップしたときにスレッドの状態を保持していなかっ\n  たためシグナルに割り込まれたスレッドの状態がおかしくなることがありま\n  した((<ruby-talk:40337>)), ((<ruby-core:00019>))\n\n: 2002-09-11: Queue#((<Queue/pop>))\n\n  Queue#pop に競合状態の問題がありました ((<ruby-dev:17223>))\n\n: 2002-09-11: SizedQueue.new\n\n  引数に 0 以下を受けつけるバグが修正されました。\n\n: 2002-09-05: ((<リテラル/式展開>))\n\n  stable snapshot で、一時期、式展開中のクォートは、バックスラッシュエ\n  スケープが必要になっていましたが、この変更は元に戻りました。\n\n        p \"#{ \"\" }\"\n\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           \"\"\n\n        => -:1: warning: bad substitution in string\n           ruby 1.6.7 (2002-09-12) [i586-linux]\n           \"#{  }\"\n\n        => ruby 1.6.7 (2002-09-25) [i586-linux]\n           \"\"\n\n  これは1.7からのバックポートではありません。コメントの扱いなどは、1.7 \n  とは異なります。(((<ruby 1.7 feature>)) の 2002-06-24 も参照)\n\n        p \"#{ \"\" # comment }\"\n        => ruby 1.6.8 (2002-10-04) [i586-linux]\n           \"\"\n        => -:1: parse error\n           ruby 1.7.3 (2002-10-04) [i586-linux]\n\n: SizedQueue#deq, #shift\n: SizedQueue#enq\n\n  追加(push, pop の別名)。これらが定義されていなかったため、enq などを\n  呼び出したときスーパークラス Queue の enq が実行されていました。\n\n: 2002-09-11: ((<tempfile/Tempfile#size>))\n\n  追加 ((<ruby-dev:17221>))\n\n: 2002-09-09\n\n  mswin32 版と mingw32 版の ruby で、1.6.6の頃から ruby の子プロセスに環境変数が渡らない\n  バグがありました。((<ruby-dev:18236>))\n\n: 2002-09-03\n\n  Bison を使用してコンパイルした Ruby で、複数回のライブラリロードを行\n  うときの速度が向上しました。(Bison を使用しない場合、ロードの都度明\n  示的に GC が実行されるためライブラリロードの実行速度が低下するのだそ\n  うです) ((<ruby-dev:18145>))\n\n: 2002-08-20 File.expand_path\n\n  Cygwin 1.3.x ((<ruby-bugs-ja:PR#299>))\n\n        p File.expand_path('file', 'c:/')\n\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           /tmp/c:/file\n        => ruby 1.6.7 (2002-08-21) [i586-linux]\n           c:/file\n\n: 2002-08-19 Thread (win)\n\n  Ruby のスレッドと Win32 の構造化例外（Win32 API からのコールバッ\n  クを含む）を同時に使うと落ちてしまう不具合が修正されたのだそうです。\n  ((<ruby-win32:273>))\n\n: 2002-08-12 Hash#==\n\n  Hash オブジェクトはデフォルト値 (((<Hash/default>))) も == で等しい\n  ときに等しいとみなされるようになりました。\n\n        p Hash.new(\"foo\") == Hash.new(\"bar\")\n\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           true\n        => ruby 1.6.7 (2002-08-21) [i586-linux]\n           false\n\n# : 2002-08-01 IO#read, gets ..., etc.\n# \n#    File::NONBLOCK を指定した IO の読み込みで EWOULDBLOCK が発生すると、\n#    途中まで読んだデータが失われることがありました。\n#    ((<ruby-dev:17855>))\n#    ((-これはまだマージされてません。1.6に入るかも不明です。-))\n\n: 2002-07-11 String#slice!\n\n  範囲外の文字列を指定したときに例外を返す場合がありましたが、常に nil \n  を返すようになりました。(String#[]やString#slice と同じ結果を返すと\n  いうことです)\n\n        p \"foo\".slice!(\"bar\")   # <- 以前からこちらは nil を返していた\n        p \"foo\".slice!(5,10)\n\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           nil\n           -:2:in `slice!': index 5 out of string (IndexError)\n                from -:2\n        => ruby 1.6.7 (2002-08-01) [i586-linux]\n           nil\n           nil\n\n: 2002-07-05 String#split\n\n  最初の引数に nil を指定できるようになりました。((<ruby-talk:43513>)) \n  この場合、$; を分割文字列として使用します。以前までは $; が有効にな\n  るのは引数省略時だけでした。\n\n    $; = \":\"\n    p \"a:b:c\".split(nil)\n    => -:2:in `split': bad separator (ArgumentError)\n            from -:2\n       ruby 1.6.7 (2002-03-01) [i586-linux]\n\n    => ruby 1.6.7 (2002-07-30) [i586-linux]\n       [\"a\", \"b\", \"c\"]\n\n: 2002-06-15 Dir.glob\n\n  リンクの切れたシンボリックリンクに対して、Dir.glob がマッチしません\n  でした。\n\n        File.symlink(\"foo\", \"bar\")\n        p Dir.glob(\"bar\")\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           []\n        => ruby 1.6.7 (2002-08-01) [i586-linux]\n           [\"bar\"]\n\n: 2002-06-13 Hash[]\n\n  Hash[] で、キーとなる文字列を dup & freeze していませんでした。\n\n        a = \"key\"\n        h = Hash[a,\"val\"]\n        h.keys[0].upcase!\n        p a\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           \"KEY\"\n        => -:3:in `upcase!': can't modify frozen string (TypeError)\n                from -:3\n           ruby 1.6.7 (2002-08-01) [i586-linux]\n\n: 2002-06-10 Fixnum#>>, <<\n\n  負の数に対して右シフトすると 0 になることがありました。\n  ((<ruby-bugs-ja:PR#247>))\n\n  負の数を引数にした左シフト(つまり右シフト)も同様におかしな挙動をして\n  いました。((<ruby-bugs-ja:PR#248>))\n\n        p(-1 >> 31)\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           0\n        => ruby 1.6.7 (2002-08-01) [i586-linux]\n           -1\n\n        p(-1 << -1)\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           -2147483649\n        => ruby 1.6.7 (2002-08-01) [i586-linux]\n           -1\n\n: 2002-06-05\n: ((<Math/Math.acosh>))\n: ((<Math/Math.asinh>))\n: ((<Math/Math.atanh>))\n\n  追加。\n\n: 2002-06-03\n: String#[]=\n\n  インデックスとして指定した文字列がレシーバに含まれない場合に、何もせ\n  ず右辺を返していました。\n\n    foo = \"foo\"\n    p foo[\"bar\"] = \"baz\"\n    p foo\n\n    => ruby 1.6.7 (2002-03-01) [i586-linux]\n       \"baz\"\n       \"foo\"\n    => -:2:in `[]=': string not matched (IndexError)\n            from -:2\n       ruby 1.6.7 (2002-07-30) [i586-linux]\n\n: 2002-06-03 sprintf()\n\n  \"%d\" で引数を整数にするときに、((<組み込み関数/Integer>)) と同じ規則を\n  使用するようになりました。\n\n        p sprintf(\"%d\", nil)\n\n        => -:1:in `sprintf': no implicit conversion from nil (TypeError)\n                from -:1\n           ruby 1.6.7 (2002-03-01) [i586-linux]\n\n        => ruby 1.6.7 (2002-07-30) [i586-linux]\n           \"0\"\n\n: 2002-05-23 -* オプション(?)\n\n  以前まで、\n\n    #! ruby -*- mode: ruby -*-\n\n  のような Emacs の '-*-' 指定を使用したスクリプトのために -* 以降を無\n  視する(何もしないオプションとして認識)するようになっていましたが、こ\n  の特別扱いはなくなりました。Emacs の '-*-' 指定は、2行目に書くように\n  するべきです。((<ruby-dev:17193>))\n\n        ruby '-*' -v\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n\n        => ruby: invalid option -*  (-h will show valid options)\n\n: 2002-05-22 parsedate\n\n  バージョンアップ((<ruby-dev:17171>))\n\n: 2002-05-22 -T オプション\n\n  ruby のコマンドラインオプション -T の後に空白を置かずに他のオプショ\n  ンを続けると、-T以降のオプションが無効になっていました。-T の後は数\n  字以外が続いた場合、オプションとみなすようになりました(-0 オプション\n  と同じ) ((<ruby-dev:17179>))\n\n        ruby -Tv  # -v が無効 (ruby 1.6.7 (2002-03-01) [i586-linux])\n\n        => ruby: No program input from stdin allowed in tainted mode (SecurityError)\n\n        => ruby 1.6.7 (2002-07-30) [i586-linux]\n\n: 2002-05-20 IO#close\n\n  双方向のパイプの dup を close_write するとエラーになっていました。\n  ((<ruby-dev:17155>))\n\n    open(\"|-\",\"r+\") {|f|\n      if f\n        f.dup.close_write\n      else\n         sleep 1\n      end\n    }\n\n    => ruby 1.6.7 (2002-03-01) [i586-linux]\n       -:3:in `close_write': closing non-duplex IO for writing (IOError)\n            from -:3\n            from -:1:in `open'\n            from -:1\n\n\n    => ruby 1.6.7 (2002-07-30) [i586-linux]\n\n: 2002-05-02 Regexp.quote\n\n  # はバックスラッシュクォートするようになりました。これは、quote した\n  正規表現を //x に正しく埋め込めるようにするためです。\n  ((<ruby-bugs-ja:PR#231>))\n\n        p Regexp.quote(\"#\")\n\n        p /a#{Regexp.quote(\"#\")}b/x =~ \"ab\"\n\n        => -:3: warning: ambiguous first argument; make sure\n           ruby 1.6.7 (2002-03-01) [i586-linux]\n           \"#\"\n           0\n\n        => -:3: warning: ambiguous first argument; make sure\n           ruby 1.6.7 (2002-07-30) [i586-linux]\n           \"\\\\#\"\n           nil\n\n: 2002-04-29: rb_find_file()\n\n  $SAFE >= 4 で、絶対パス指定でない場合、SecurityError 例外が発生する\n  ようになりました。\n\n: 2002-04-26: Regexp.quote\n\n  ((<ruby-bugs-ja:PR#231>))\n\n        p Regexp.quote(\"\\t\")\n\n        p /a#{Regexp.quote(\"\\t\")}b/x =~ \"ab\"\n\n        => -:3: warning: ambiguous first argument; make sure\n           ruby 1.6.7 (2002-03-01) [i586-linux]\n           \"\\t\"\n           0\n\n        => -:3: warning: ambiguous first argument; make sure\n           ruby 1.6.7 (2002-05-04) [i586-linux]\n           \"\\\\t\"\n           nil\n\n: 2002-04-20: Regexp#inspect\n\n  /x フラグ付きの正規表現オブジェクトの inspect が改行を \\n に変換して\n  いました。((<ruby-bugs-ja:PR#225>))\n\n        p /a\n                b/x\n\n        => -:1: warning: ambiguous first argument; make sure\n           ruby 1.6.7 (2002-03-01) [i586-linux]\n           /a\\n                b/x\n\n        => -:1: warning: ambiguous first argument; make sure\n           ruby 1.7.2 (2002-04-24) [i586-linux]\n           /a\n                           b/x\n: 2002-04-19: 終了処理\n\n  以下のスクリプトで 2 回シグナルを送らないと終了しない不具合が修正さ\n  れました。((<ruby-bugs-ja:PR#223>))\n\n    trap(:TERM, \"EXIT\")\n\n    END{\n      puts \"exit\"\n    }\n\n    Thread.start { Thread.stop }\n    sleep\n\n: 2002-04-17: Regexp#inspect\n\n  ((<ruby-bugs-ja:PR#222>))\n\n    p %r{\\/}\n\n    => ruby 1.6.7 (2002-03-01) [i586-linux]\n       /\\\\//\n\n    => ruby 1.6.7 (2002-05-04) [i586-linux]\n       /\\//\n\n: 2002-04-15: pack('U')\n\n  pack('U') を unpack('U') すると元に戻らないバグが修正されました。\n  (unpack は、バイト単位でなく文字単位の処理になりました)\n  ((<ruby-bugs-ja:PR#220>))\n\n    p [128].pack(\"U\")\n    p [128].pack(\"U\").unpack(\"U\")\n\n    => ruby 1.6.7 (2002-03-01) [i586-linux]\n       \"\\302\\200\"\n       [0]\n\n    => ruby 1.6.7 (2002-05-04) [i586-linux]\n       \"\\302\\200\"\n       [128]\n\n: 2002-04-11: IO#write\n\n  ソケットやパイプに対する EPIPE の検出に失敗することがありました。\n  ((<ruby-dev:16849>))\n\n: 2002-04-11: ((<\"cgi/session\">))    (*ドキュメント未反映*)\n\n  support for multipart form.\n\n: 2002-04-10: Object#((<Object/remove_instance_variable>))\n\n  指定したインスタンス変数が定義されていない場合例外 NameError を起こ\n  すようになりました。((<ruby-bugs-ja:PR#216>))\n\n        Object.new.instance_eval {\n          p remove_instance_variable :@foo\n        }\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           nil\n\n        => -:2:in `remove_instance_variable': instance variable @foo not defined (NameError)\n           ruby 1.6.7 (2002-04-10) [i586-linux]\n\n: 2002-04-04: Integer#((<Integer/step>))\n\n  第二引数が 1 よりも小さい場合に 0 を指定したと見なされエラーになって\n  いました。\n\n    1.step(2, 0.1) {|f| p f }\n\n    => -:1:in `step': step cannot be 0 (ArgumentError)\n            from -:1\n       ruby 1.6.7 (2002-03-01) [i586-linux]\n\n    => ruby 1.6.7 (2002-04-10) [i586-linux]\n       1\n       1.1\n        :\n       1.9\n\n: 2002-04-01: ((<組み込み変数/$~>))\n\n  $~ に nil を代入できないバグが修正されました。((<ruby-dev:16697>))\n\n    /foo/ =~ \"foo\"\n    p $~\n    $~ = nil\n    p $~\n    => ruby 1.6.7 (2002-03-01) [i586-linux]\n       #<MatchData:0x401b1be4>\n       -:3: wrong argument type nil (expected Match) (TypeError)\n                                              ^^^^^ MatchData の間違い\n    => ruby 1.6.7 (2002-04-04) [i586-linux]\n       #<MatchData:0x401b1c98>\n       nil\n\n: 2002-03-25 ((<BasicSocket/BasicSocket.do_not_reverse_lookup>))\n\n  $SAFE > 3 で値を設定できなくなりました。\n  ((<ruby-dev:16554>))\n\n: 2002-03-23 IO#((<IO/read>))\n\n  サイズが 0 で中身のあるファイル(Linux の /proc ファイルシステムでこ\n  のような場合があります)が File#read などで読めないバグが修正されまし\n  た。\n\n        p File.open(\"/proc/#$$/cmdline\").read\n\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           \"\"\n\n        => ruby 1.6.7 (2002-03-29) [i586-linux]\n           \"ruby-1.6\\000-v\\000-\"\n\n: 2002-03-22 ((<Module/module_eval>))\n\n  ((<Module/module_eval>)) のブロック内で定数やクラス変数のスコープが\n  変わることはなくなりました。((<ruby-dev:17876>))\n\n        class Foo\n          FOO = 1\n          @@foo = 1\n        end\n\n        FOO = 2\n        @@foo = 2\n\n        Foo.module_eval { p FOO, @@foo }\n\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           1\n           1\n\n        => ruby 1.6.7 (2002-03-29) [i586-linux]\n           2\n           2\n\n: 2002-03-22 ((<\"net/http\">))\n\n  Net::HTTP.new がブロックなしのときに nil を返していました。\n  ((<ruby-bugs-ja:PR#214>))\n\n  net/protocol は削除される方向にあるようで、その準備時に\n  エンバグしたそうです。\n\n: 2002-03-20 ((<File/File.expand_path>))\n\n  メモリの解放洩れがありました。((<ruby-bugs:PR#276>))\n\n: 2002-03-18 文字列リテラル\n\n  漢字コードの扱いが #{..} の中などで不完全な部分がありました。\n  ((<ruby-list:34478>))\n\n        #! ruby -Ks\n        p a = \"#{\"表\"}\"\n        => -:1: compile error in string expansion (SyntaxError)\n           -:1: unterminated string meets end of file\n           ruby 1.6.7 (2002-03-15) [i586-linux]\n        => ruby 1.6.7 (2002-03-19) [i586-linux]\n           \"表\"\n\n        #! ruby -Ks\n        p %[評価]\n        => -:2: parse error\n                   p %[評価]\n                           ^\n           ruby 1.6.7 (2002-03-15) [i586-linux]\n\n        => ruby 1.6.7 (2002-03-19) [i586-linux]\n           \"評価\"\n\n: 2002-03-16 $~\n\n  正規表現マッチのメソッドが実際には内部でマッチを実行しない場合に \n  $~ の状態をクリアしていませんでした。\n  ((<ruby-bugs-ja:PR#208>))\n\n        /foo/ =~ \"foo\"\n        /foo/ =~ nil\n        p $~\n\n        /foo/ =~ \"foo\"\n        $_ = nil; ~\"foo\"\n        p $~\n\n        /foo/ =~ \"foo\"\n        \"foo\".index(/bar/, 4)\n        p $~\n\n        /foo/ =~ \"foo\"\n        \"foo\".rindex(/bar/, -4)\n        p $~\n\n        => ruby 1.6.7 (2002-03-06) [i586-linux]\n           #<MatchData:0x401b1be4>\n           #<MatchData:0x401b198c>\n           #<MatchData:0x401b1644>\n           #<MatchData:0x401b1414>\n        => ruby 1.6.7 (2002-03-19) [i586-linux]\n           nil\n           nil\n           nil\n           nil\n\n: 2002-03-14 拡張ライブラリの autoload\n\n  拡張ライブラリに対して autoload が効いていませんでした。((<ruby-dev:16379>))\n\n    autoload :Fcntl, \"fcntl\"\n    require \"fcntl\"\n\n    => -:2:in `require': uninitialized constant Fcntl (NameError)\n            from -:2\n       ruby 1.6.7 (2002-03-01) [i586-linux]\n\n    => ruby 1.6.7 (2002-03-15) [i586-linux]\n\n: 2002-03-13 ((<getopts>))\n\n  refine. ((<ruby-dev:16193>)), ((<ruby-dev:16213>))\n\n: 2002-03-11 正規表現中の 8 進コード\n\n  正規表現中の \\nnn による 8 進記法で先頭が 0 の場合だけ、4桁を許して\n  いました。((<ruby-bugs-ja:PR#207>))\n\n    p /\\0001/ =~ \"\\0001\"   # equivalent to \"\\0\" + \"1\"\n    => -:1: warning: ambiguous first argument; make sure\n       ruby 1.6.7 (2002-03-01) [i586-linux]\n       nil\n    => -:1: warning: ambiguous first argument; make sure\n       ruby 1.6.7 (2002-03-15) [i586-linux]\n       0\n\n: 2002-03-11 trap\n\n  ((<ruby-bugs-ja:PR#206>))\n\n    trap('EXIT','Foo')\n    => -:1: [BUG] Segmentation fault\n       ruby 1.6.7 (2002-03-01) [i586-linux]\n    => ruby 1.6.7 (2002-03-15) [i586-linux]\n\n: 2002-03-10 メソッドの戻り値\n\n  以下のメソッドの戻り値が正しくなりました。((<ruby-bugs-ja:PR#205>))\n\n  * ((<Enumerable/each_with_index>)) が self を返すようになった(以前は nil)\n  * ((<Process/Process.setpgrp>)) が返す値が不定だった。\n  * ((<String/ljust>)), ((<String/rjust>)), ((<String/center>)) の結果に\n    変化がなくても常に dup した文字列を返すようになった\n\n: 2002-03-08 class variable\n\n  ((<ruby-talk:35122>))\n\n    class C\n      class << self\n        def test\n          @@cv = 5\n          p @@cv\n        end\n      end\n\n      test\n    end\n    => -:5:in `test': uninitialized class variable @@cv in C (NameError)\n            from -:9\n       ruby 1.6.7 (2002-03-01) [i586-linux]\n\n    => ruby 1.6.6 (2001-12-26) [i586-linux]\n       5\n\n: 2002-03-03 ((<Marshal/Marshal.load>))\n\n  Marshal.load が 1.7 のメソッド Proc#yield を呼んでいました。\n  ((<ruby-dev:16178>))\n\n    Marshal.load(Marshal.dump('foo'), proc {|o| p o})\n    => -:1:in `load': undefined method `yield' for #<Proc:0x401b1b30> (NameError)\n            from -:1\n       ruby 1.6.7 (2002-03-01) [i586-linux]\n\n    => ruby 1.6.6 (2001-12-26) [i586-linux]\n       \"foo\"\n\n== 1.6.6 (2001-12-26) -> 1.6.7 (2002-03-01)\n\n: 2002-02-20 true/false/nil の特異メソッド定義\n\n  これら擬似変数に特異クラス定義形式で特異メソッドを定義できるようにな\n  りました。\n\n        class <<true\n          def foo\n           \"foo\"\n          end\n        end\n        p true.foo\n        => -:1: no virtual class for true (TypeError)\n           ruby 1.6.6 (2001-12-26) [i586-linux]\n\n        => ruby 1.6.7 (2002-03-01) [i586-linux]\n           \"foo\"\n\n: ((<time>)), URI\n\n  追加されました。\n\n: Ruby/Tk\n\n  バグ修正、機能追加 ((<ruby-dev:16139>)),((<ruby-dev:16153>))。\n\n: 数値リテラルの `_'\n\n  `_' を置ける場所の規則が見直され、String#hex などの数値変換メソッド\n  の挙動と共に規則が統一されました。((<rubyist:1018>)), ((<ruby-dev:15684>)),\n  ((<ruby-dev:15757>))\n\n: ((<Module/include>))\n\n  モジュールが再帰的に include されないようになりました。\n\n    module Foo; end\n    module Bar; include Foo; end\n    module Foo; include Bar; end\n\n    p Foo.ancestors\n\n    => ruby 1.6.6 (2001-12-26) [i586-linux]\n       [Foo, Bar, Foo]\n\n    => -:3:in `append_features': cyclic include detected (ArgumentError)\n            from -:3:in `include'\n            from -:3\n       ruby 1.6.6 (2002-01-28) [i586-linux]\n\n: メソッドの戻り値\n\n  以下のメソッドの戻り値が正しくなりました。\n  ((<ruby-bugs-ja:PR#182>)), ((<rubyist:1016>))\n\n  * Hash#default= が右辺を返すようになった(以前は self を返していた)。\n\n  * Dir#pos= が右辺を返すようになった(以前は self を返していた)。\n    (Dir#seek は、変わらず self を返します)\n\n  * Dir.glob がブロックを伴うとき nil を返すようになった(以前は false)\n\n  * IO#close がクローズ済みな IO に対して IOError を起こすようになった。\n\n  * IO#each_byte が self を返すようになった(以前は nil)\n\n: rb_define_module_under()\n\n  C 関数 rb_define_module_under() でモジュールを定義するときに同名の定\n  数が既に定義されていると失敗していました。((<ruby-talk:30203>))\n\n        Constants = 1\n        require 'syslog'\n        p Syslog::Constants\n\n        => -:2:in `require': Syslog::Fixnum is not a module (TypeError)\n                from -:2\n           ruby 1.6.6 (2001-12-26) [i586-linux]\n\n        => ruby 1.6.6 (2002-01-07) [i586-linux]\n           Syslog::Constants\n\n  このバグにより 1.6.7 が近いうちにリリースされるかもしれません\n  ((<ruby-talk:30387>))(やっぱそんなことはなかったようです。\n  これを見て、1.6.6 の stable-snapshot を使用している方は、2002/1/30 \n  の以下の変更(ChangeLog)\n\n        * re.c (rb_reg_search): should set regs.allocated.\n\n  で、メモリリークが起こるようになってることに注意してください。\n  2002/2/13 以降の修正版で直ってます。っと一度ハマッたので書いておきま\n  す)。\n\n== 1.6.5 (2001-09-19) -> 1.6.6 (2001-09-19)\n\n: ((<Syslog>))\n\n  追加されました。\n\n: CGI\n\n  Netscape(バージョンは？) のバグに対処しました\n  ((<ruby-list:32089>))\n\n: Time#localtime\n: Time#gmtime\n\n  フリーズした Time オブジェクトに対して一度だけ呼び出しを許しました。\n\n        t = Time.new.freeze\n        p t.gmtime\n        p t.localtime\n\n        => -:2:in `gmtime': can't modify frozen Time (TypeError)\n                from -:2\n           ruby 1.6.5 (2001-09-19) [i586-linux]\n\n        => ruby 1.6.5 (2001-11-01) [i586-linux]\n           Mon Nov 05 18:08:34 UTC 2001\n           -:3:in `localtime': can't modify frozen Time (TypeError)\n                from -:3\n\n: File::SEPARATOR\n: File::ALT_SEPARATOR\n: File::PATH_SEPARATOR\n: RUBY_PLATFORM\n: RUBY_RELEASE_DATE\n: RUBY_VERSION\n\n  これらは、freeze された文字列になりました。\n\n        p File::SEPARATOR.frozen?\n        p File::ALT_SEPARATOR.frozen?\n        p File::PATH_SEPARATOR.frozen?\n\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           false\n           false\n           false\n\n        => ruby 1.6.5 (2001-11-01) [i586-linux]\n           true\n           false  # ここでは実行環境がLinuxなので ALT_SEPARATOR は nil\n           true\n\n: Integer[nth]\n\n  大きな値のインデックスに対して例外が発生していました。\n  ((<ruby-bugs-ja:PR#114>))\n\n        p(-1[10000000000])\n\n        => -:1:in `[]': bignum too big to convert into `int' (RangeError)\n                from -:1\n           ruby 1.6.5 (2001-09-19) [i586-linux]\n\n        => ruby 1.6.5 (2001-11-01) [i586-linux]\n           1\n\n  整数の負のインデックスに対して 0 を返すようにな・・・ってません。あれ？\n  ((<ruby-bugs-ja:PR#122>))\n\n        p(-1[-1])\n\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           1\n        => ruby 1.6.5 (2001-11-01) [i586-linux]\n           1\n\n: Numeric#remainder\n\n  ((<ruby-bugs-ja:PR#110>))\n\n        p( 3.remainder(-3))\n        p(-3.remainder(3))\n\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           3\n           -3\n        => ruby 1.6.5 (2001-11-01) [i586-linux]\n           0\n           0\n\n: END { ... }\n\n  END ブロックの中の END ブロックが実行されていませんでした。\n  ((<ruby-bugs-ja:PR#107>))\n\n        END {\n          p 1\n          END { p 2 }\n        }\n\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           1\n\n        => ruby 1.6.5 (2001-11-01) [i586-linux]\n           1\n           2\n\n: String#succ\n\n((<ruby-talk:22557>))\n\n        p \"***\".succ\n        p \"*\".succ\n        p sprintf(\"%c\", 255).succ\n        p sprintf(\"*%c\", 255).succ\n        p sprintf(\"**%c\", 255).succ\n\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           \"**+\"\n           \"\\001+\"\n           \"\\001\\000\"\n           \"\\001+\\000\"\n           \"*+\\000\"\n\n        => ruby 1.6.5 (2001-11-01) [i586-linux]\n           \"**+\"\n           \"+\"\n           \"\\001\\000\"\n           \"+\\000\"\n           \"*+\\000\"\n\n: method_missing\n\n  以下が Segmentation Fault していました。((<ruby-dev:14942>))\n\n        Module.constants.each {|c|\n          c = eval c\n          if c.instance_of?(Class)\n            p c\n            c.instance_methods.each {|m|\n              c.module_eval \"undef #{m};\"\n            }\n            c.module_eval {undef initialize}\n          end\n        }\n\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           NotImplementedError\n           MatchData\n           Exception\n           Numeric\n           MatchData\n           Segmentation fault\n\n        => ruby 1.6.5 (2001-10-15) [i586-linux]\n           MatchData\n           NotImplementedError\n           FloatDomainError\n           LoadError\n           Float\n           Binding\n           SignalException\n           Module\n           -:6:in `method_missing': stack level too deep (SystemStackError)\n\n: %q(...)\n\n  % 記法によるリテラル表記でその区切り文字として英数字を指定\n  できなくなりました。\n\n     p %q1..1\n\n    => ruby 1.6.5 (2001-10-10) [i586-linux]\n       \"..\"\n    => -:1: unknown type of %string\n            p %q1..1\n                 ^\n       ruby 1.6.5 (2001-10-15) [i586-linux]\n\n: String#=~\n\n  String#=~ の呼出で両辺ともリテラルであったときに速度重視のためにメソッ\n  ドコールを行わなくなりました。(実際は、前からこのようにしようとして\n  いたがバグによりメソッドが呼び出されていた(しかもString#=~ でなく \n  Regexp#=~))\n\n    class String\n      def =~(arg)\n        [\"String#=~\", self, arg]\n      end\n    end\n\n    class Regexp\n      def =~(arg)\n        [\"Regexp#=~\", self, arg]\n      end\n    end\n\n    p \"foo\" =~ /foo/\n    p \"foo\" =~ Regexp.new(\"foo\")\n\n    => -:2: warning: discarding old =~\n       -:8: warning: discarding old =~\n       ruby 1.6.5 (2001-09-19) [i586-linux]\n       [\"Regexp#=~\", /foo/, \"foo\"]\n       [\"String#=~\", \"foo\", /foo/]\n\n    => -:2: warning: discarding old =~\n       -:8: warning: discarding old =~\n       ruby 1.6.5 (2001-10-10) [i586-linux]\n       0\n       [\"String#=~\", \"foo\", /foo/]\n\n  (((*組み込みのメソッドはこのような最適化が行われることがあるのでメソッ\n  ドの再定義の効果が及ばないことがある点に注意*))というか、メソッドが\n  再定義されたかどうかで、最適化の on/off をしてほしいなあ)\n\n: class 定義\n\n  既にクラスが定義されていて、そのクラスと異なるスーパークラスを明示的\n  に指定して再定義したとき、指定したスーパークラスが反映されていません\n  でした。((<ruby-bugs-ja:PR#87>))\n\n    class A\n      p self.id\n    end\n    class A < String\n      p self.id\n      p self.superclass\n    end\n\n    => ruby 1.6.5 (2001-09-19) [i586-linux]\n       537760880\n       -:4: warning: already initialized constant A\n       537757180\n       Object\n    => ruby 1.6.5 (2001-10-10) [i586-linux]\n       537760960\n       -:4: warning: already initialized constant A\n       537757200\n       String\n\n: %w(...)\n\n  配列リテラル %w(...) が構文解析器により文字列リテラルとして判断されて\n  いたため、以下のようなコードで異常な状態になっていました。\n  ((<ruby-bugs-ja:PR#91>))\n\n    %w!a! \"b\" \n    => -:1: tried to allocate too big memory (NoMemoryError)\n       ruby 1.6.5 (2001-09-19) [i586-linux]\n\n    => -:1: parse error\n           %w!a! \"b\" \n                    ^\n       ruby 1.6.5 (2001-10-10) [i586-linux]\n\n: Thread\n\n  Thread#status が aborting 状態に対して \"run\" を返していたバグが修正\n  されました。また、Thread#priority = val が val でなく self を返して\n  いました。((<rubyist:0820>)), ((<ruby-dev:14903>))\n\n: ((<Marshal>))\n\n  無名のクラス／モジュールは dump できないようになりました。\n\n    p Marshal.dump(Class.new)\n\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       \"\\004\\005c\\031#<Class 0lx401a6b44>\"\n\n    => -:1:in `dump': can't dump anonymous class #<Class 0lx401ab980> (ArgumentError)\n            from -:1\n       ruby 1.6.5 (2001-10-05) [i586-linux]\n\n: UNIXSocket#addr\n\n  UNIXSocket#addr がゴミを返していました(BSD の場合？)。\n  ((<ruby-bugs-ja:PR#85>))\n\n        # server\n        require 'socket'\n        File.unlink(\"/tmp/sss\")\n        sock = UNIXServer.new(\"/tmp/sss\").accept\n\n        # client\n        require 'socket'\n        sock = UNIXSocket.new(\"/tmp/sss\").addr\n\n        => [\"AF_UNIX\", \"\\031((\\306\\031(\\010\"]\n\n        => [\"AF_UNIX\", \"\"]\n\n: ???\n        ((<ruby-talk:21722>))\n\n        class Ptr\n                def initialize(obj) @obj = obj end\n                def []=() @obj = obj end\n                def []() @obj end\n        end\n        module Kernel\n                def _ptr() Ptr.new(self) end\n        end\n\n        def foo(int)\n                int[] += 1\n        end\n        x = 1._ptr\n        foo(x)\n        puts x[]\n\n        => -:11: [BUG] Segmentation fault\n           ruby 1.6.5 (2001-09-19) [i586-linux]\n\n        => -:11:in `[]=': wrong # of arguments(1 for 0) (ArgumentError)\n                   from -:11:in `foo'\n                   from -:14\n           ruby 1.6.5 (2001-10-05) [i586-linux]\n\n: Subclass of String and Array\n\n  String, Array のサブクラスで特定のメソッドを呼ぶと、String, Array\n  になっていました。\n\n        class Foo < String\n        end\n        p Foo.new(\"\").class\n        p Foo.new(\"foo\")[0,0].class              # String ???\n        p Foo.new(\"foo\")[1,1].class\n        p Foo.new(\"foo\").succ.class\n        p Foo.new(\"foo\").reverse.class\n        p((Foo.new(\"foo\") * 5).class)\n        p Foo.new(\"foo\").gsub(/foo/, \"bar\").class\n        p Foo.new(\"foo\").sub(/foo/, \"bar\").class\n        p Foo.new(\"foo\").ljust(10).class\n        p Foo.new(\"foo\").rjust(10).class\n        p Foo.new(\"foo\").center(10).class\n\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           Foo\n           String\n           String\n           String\n           String\n           String\n           String\n           Foo\n           String\n           String\n           String\n\n        => ruby 1.6.5 (2001-10-05) [i586-linux]\n           Foo\n           String\n           Foo\n           Foo\n           Foo\n           Foo\n           Foo\n           Foo\n           Foo\n           Foo\n           Foo\n\n        class Bar < Array\n        end\n        bar = Bar.new\n        p bar.class\n        p bar.push(1,2,3)\n        p bar.class\n        p bar[0,0].class            # => Array ???\n        p bar[0,1].class\n        p ((bar * 5).class)\n\n        => -:9: warning: p (...) interpreted as method call\n           ruby 1.6.5 (2001-09-19) [i586-linux]\n           Bar\n           [1, 2, 3]\n           Bar\n           Array\n           Array\n           Array\n        => -:9: warning: p (...) interpreted as method call\n           ruby 1.6.5 (2001-10-05) [i586-linux]\n           Bar\n           [1, 2, 3]\n           Bar\n           Array\n           Bar\n           Bar\n\n== 1.6.4 (2001-06-04) -> 1.6.5 (2001-09-19)\n\n: $_, $~, if a..b\n\n  関数の中からThread#runを使うと、そのスレッドとスコープを共有する親スレッ\n  ドの$_, $~が、子スレッドのもので上書きされてしまっていました。\n  ((<ruby-dev:14743>))\n\n        def foo(t)\n          t.run\n        end\n\n        t = Thread.start do\n          t = $_= \"sub\"\n          loop{Thread.stop;puts \"sub:#$_\"}\n        end\n\n        $_ = \"main\"\n        t.run                   # => sub:sub\n        puts \"main:#$_\"         # => main:main\n        foo(t)                  # => sub:sub\n        puts \"main:#$_\"         # => main:sub\n        => ruby 1.6.4 (2001-06-04) [i586-linux]\n           sub:sub\n           main:main\n           sub:sub\n           main:sub\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           sub:sub\n           main:main\n           sub:sub\n           main:main\n\n: net/telnet\n\n  Net::Telnet が特定のホストへ接続後、動かない事がありました。\n  ((<ruby-list:31303>))\n\n: CGI#header\n\n  以下のようなスクリプトでTEXT_PLAINが\"text/plain; charset=iso-8859-1\"\n  のように書き換えられていました。\n  ((<ruby-dev:14716>))\n\n        require 'cgi'\n\n        TEXT_PLAIN = \"text/plain\"\n\n        cgi = CGI.new\n        print cgi.header(\"type\" => TEXT_PLAIN,\n                         \"charset\" => \"iso-8859-1\")\n        printf(\"TEXT_PLAIN: %s\\n\", TEXT_PLAIN)\n\n        => ruby 1.6.4 (2001-06-04) [i586-linux]\n           Content-Type: text/plain; charset=iso-8859-1\n           ^M\n           TEXT_PLAIN: text/plain; charset=iso-8859-1\n           TEXT_PLAIN: text/plain\n\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           Content-Type: text/plain; charset=iso-8859-1\n           ^M\n           TEXT_PLAIN: text/plain\n\n: Dir.chdir\n\n        環境変数 HOME, LOGDIR のいずれも定義されていないとき引数なしの \n        Dir.chdir で ArgumentError 例外を起こすようになりました\n\n        ENV['HOME'] = nil\n        ENV['LOGDIR'] = nil\n        Dir.chdir\n        => -:3:in `chdir': Bad address (Errno::EFAULT)\n                from -:3\n           ruby 1.6.4 (2001-08-26) [i586-linux]\n        => -:3:in `chdir': HOME/LOGDIR not set (ArgumentError)\n                from -:3\n           ruby 1.6.5 (2001-09-19) [i586-linux]\n\n: Dir.glob\n\n  以下のコードが無限ループになっていました。\n\n        Dir.mkdir(\"test?\") rescue nil\n        p Dir.glob(\"test?/*\")\n        => ruby 1.6.5 (2001-09-19) [i586-linux]\n           []\n\n: jcode\n  バグがいくつか修正されました。((<ruby-list:31238>))\n\n\n〜この間、空白期間〜\n\n: ((<Dir>)).glob\n\n  Dir.glob(\"*/**/*\")がサブディレクトリのファイルを二度返していました。\n  ((<ruby-dev:14576>))\n\n    Dir.mkdir('foo') rescue nil\n    Dir.mkdir('foo/bar') rescue nil\n    p Dir.glob('*/**/*')\n\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       [\"foo/bar\", \"foo/bar\"]\n\n    => ruby 1.6.4 (2001-08-26) [i586-linux]\n       [\"foo/bar\"]\n\n: ((<UnboundMethod>))#bind\n\n  モジュールの UnboundMethod オブジェクトを bind することができませんでした。\n  ((<rubyist:0728>))\n\n    module Foo\n      def foo\n        :foo\n      end\n    end\n\n    class Bar\n      include Foo\n    end\n\n    m = Foo.instance_method :foo\n    p m.bind(Bar.new).call\n\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       -:12:in `bind': first argument must be an instance of Foo (TypeError)\n            from -:12\n\n    => ruby 1.6.4 (2001-08-23) [i586-linux]\n       :foo\n\n: 組み込みクラスの置き換え\n\n  組み込みクラス／モジュール(を代入した定数)への代入を行ったときに警告を\n  出すようになりました。\n\n    Array = nil\n    p Array\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       nil\n\n    => -:1: warning: already initialized constant Array\n       ruby 1.6.4 (2001-08-23) [i586-linux]\n       nil\n\n: ((<Regexp>))\n\n  括弧の数より大きな数のバックリファレンスが何にでもマッチしていました。\n  ((<ruby-list:30975>))\n\n    p /(foo)\\2/ =~ \"foobar\"\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       0\n    => ruby 1.6.4 (2001-08-23) [i586-linux]\n       nil\n\n: ((<TCPSocket>)).open\n\n  ((<Cygwin>)) で ((<TCPSocket>)).open がタイミングによってエラー(Errno::EINVAL,\n  EALREADY)になることがある問題に対処しました。(1.6.4 20010712以降)\n  ((<ruby-talk:9939>)), ((<ruby-talk:16632>)),\n  ((<ruby-list:24702>)), ((<ruby-list:27805>)), ((<ruby-list:30512>)) 等など\n\n: resolv, resolv-replace\n\n  追加。rubyで実装したリゾルバ(DNSの名前解決) とSocket関連のクラスでこ\n  のライブラリを使用するためのライブラリです。\n\n  rubyで実装したリゾルバは、timeout の制御が効きます(つまり、名前解\n  決中にThreadが切替え可能ということです)\n\n    require 'resolv'\n    p Resolv.new.getaddress(\"www.ruby-lang.org\").to_s\n\n    => /usr/local/lib/ruby/1.6/resolv.rb:160: warning: timeout (...) interpreted as method call\n       /usr/local/lib/ruby/1.6/resolv.rb:55: warning: instance variable @initialized not initialized\n       /usr/local/lib/ruby/1.6/resolv.rb:113: warning: instance variable @initialized not initialized\n       /usr/local/lib/ruby/1.6/resolv.rb:392: warning: instance variable @initialized not initialized\n       ruby 1.6.4 (2001-08-23) [i586-linux]\n       \"210.251.121.214\"\n\n: ((<Digest|digest>)) モジュール\n\n  SHA1, MD5 は Digest::SHA1, Digest::MD5 に置き換えられました。\n  Digest::SHA256, Digest::SHA384,  Digest::SHA512, Digest::RMD160\n  も新たに追加されました。\n\n    require 'digest/md5'\n    include Digest\n\n    md = MD5.new\n    md << \"abc\"\n    puts md\n\n    puts MD5.hexdigest(\"123\")\n\n: ((<Struct>))\n\n  フリーズされた構造体オブジェクトが変更できていました。また、$SAFE =\n  4 のときの変更を禁止するようにしました。((<ruby-talk:19167>))\n\n    cat = Struct.new(\"Cat\", :name, :age, :life)\n    a = cat.new(\"cat\", 12, 7).freeze\n    a.name = \"dog\"\n    p a\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       #<Struct::Cat name=\"dog\", age=12, life=7>\n    => ruby 1.6.4 (2001-08-06) [i586-linux]\n       -:4:in `name=': can't modify frozen Struct (TypeError)\n            from -:4\n\n    cat = Struct.new(\"Cat\", :name, :age, :life)\n    a = cat.new(\"cat\", 12, 7)\n    Thread.new do\n       abort_on_exception = true\n       $SAFE = 4\n       a.life -= 1\n    end.join\n    p a.life\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       6\n    => ruby 1.6.4 (2001-08-06) [i586-linux]\n       -:6:in `life=': Insecure: can't modify Struct (SecurityError)\n            from -:3:in `join'\n            from -:3\n\n: ((<String>))#rindex\n\n  rindex に正規表現を渡したときの動作にバグがありました。((<ruby-dev:13843>))\n  (1.6.4 リリース後のバグです)\n\n    p \"foobar\".rindex(/b/)\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       3\n\n    => ruby 1.6.4 (2001-06-19) [i386-freebsd5.0]\n       nil\n\n    => ruby 1.6.4 (2001-08-06) [i586-linux]\n       3\n\n: ((<require|組み込み関数>))\n\n  requireに ~ で始まるファイル名を指定したとき、拡張子がついてな\n  いとロードできなくなっていました。((<ruby-dev:13756>))\n\n    $ echo p __FILE__ > ~/a.rb\n    $ ruby17 -v -r~/a -e0\n    ruby 1.7.1 (2001-07-03) [i686-linux]\n    0: No such file to load -- ~/a (LoadError)\n    $ ruby16 -v -r~/a -e0\n    ruby 1.6.4 (2001-07-02) [i686-linux]\n    0: No such file to load -- ~/a (LoadError)\n    $ ruby14 -v -r~/a -e0\n    ruby 1.4.6 (2000-08-16) [i686-linux]\n    \"/home/nobu/a.rb\"\n\n: ((<String>))#each_line\n\n  正しく汚染が伝搬していませんでした。((<ruby-dev:13755>))\n\n    \"foo\\nbar\\n\".taint.each_line {|v| p v.tainted?}\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       false\n       true\n    => ruby 1.6.4 (2001-08-06) [i586-linux]\n       true\n       true\n\n: ((<NKF|nkf>)).nkf\n\n  正しく汚染が伝搬していませんでした。((<ruby-dev:13754>))\n\n    require 'nkf'\n    p NKF.nkf(\"-j\", \"a\".taint).tainted?\n\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       false\n    => ruby 1.6.4 (2001-08-06) [i586-linux]\n       true\n\n: ruby -x\n\n  オプション ((<Rubyの起動/-x[directory]>)) を指定したときにスクリ\n  プトを実行せずに終了することがありました。((<ruby-dev:13752>))\n\n: attr_*\n\n  アクセサに余計な引数を渡してもエラーになりませんでした。\n  ((<ruby-dev:13748>))\n\n    class C\n      def initialize\n        @message = 'ok'\n      end\n      attr_reader :message\n    end\n    puts C.new.message(1,2,3)\n\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       ok\n    => ruby 1.6.4 (2001-08-06) [i586-linux]\n       -:7:in `message': wrong # of arguments(3 for 0) (ArgumentError)\n            from -:7\n\n: ((<Readline|readline>)).completion_append_character\n: ((<Readline|readline>)).completion_append_character=\n\n  追加。GNU Readline ライブラリの変数 (({rl_completion_append_character}))\n  のアクセサ。(この変数は GNU readline 2.1 以降で使えます)\n  ((<ruby-ext:01760>))\n\n: ((<Socket::Constants>))\n\n  ソケット関連の定数のうち以下が新規に追加されました(システムに定義さ\n  れている場合に限る)。\n\n    SO_PASSCRED\n    SO_PEERCRED\n    SO_RCVLOWAT\n    SO_SNDLOWAT\n    SO_RCVTIMEO\n    SO_SNDTIMEO\n    SO_SECURITY_AUTHENTICATION\n    SO_SECURITY_ENCRYPTION_TRANSPORT\n    SO_SECURITY_ENCRYPTION_NETWORK\n    SO_BINDTODEVICE\n    SO_ATTACH_FILTER\n    SO_DETACH_FILTER\n    SO_PEERNAME\n    SO_TIMESTAMP\n\n: ((<require|組み込み関数>)) / $LOAD_PATH\n\n  Changed to use a new algorithm to locate a library.\n\n  Now when requiring \"foo\", the following directories are searched for\n  the library in the order listed.\n\n    $prefix/lib/ruby/site_ruby/$ver/foo.rb\n    $prefix/lib/ruby/site_ruby/$ver/foo.so\n    $prefix/lib/ruby/site_ruby/$ver/$arch/foo.rb\n    $prefix/lib/ruby/site_ruby/$ver/$arch/foo.so\n    $prefix/lib/ruby/site_ruby/foo.rb\n    $prefix/lib/ruby/site_ruby/foo.so\n    $prefix/lib/ruby/$ver/foo.rb\n    $prefix/lib/ruby/$ver/foo.so\n    $prefix/lib/ruby/$ver/$arch/foo.rb\n    $prefix/lib/ruby/$ver/$arch/foo.so\n    ./foo.rb\n    ./foo.so\n\n  The previous behavior had a potential security risk because a\n  foo.rb (if exists) in the current directory is located prior to a\n  foo.so in $prefix/lib/ruby/site_ruby/$ver/$arch.\n\n  ((<ruby-bugs:PR#140>)), ((<ruby-ext:01778>)), ((<ruby-dev:13659>))\n\n: sync\n: mutex_m\n\n  Fixed for obj.extend(Sync_m) and obj.extend(Mutex_m).((<ruby-dev:13463>))\n\n    $ ruby -v -rsocket -rmutex_m -e 's=TCPSocket.new(\"localhost\",25); s.extend(Mutex_m)'\n    ruby 1.6.4 (2001-06-04) [i386-linux]\n    /usr/lib/ruby/1.6/mutex_m.rb:104:in `initialize': wrong # of arguments (0 for 1) (ArgumentError)\n            from /usr/lib/ruby/1.6/mutex_m.rb:104:in `initialize'\n            from /usr/lib/ruby/1.6/mutex_m.rb:50:in `mu_extended'\n            from /usr/lib/ruby/1.6/mutex_m.rb:34:in `extend_object'\n            from -e:1:in `extend'\n            from -e:1\n\n: $SAFE / ((<load|組み込み関数>))\n\n  1 <= $SAFE <= 3 で、第二引数が true のとき汚染されたファイル名を\n  指定しても load() できてしまうバグが修正されました。((<ruby-dev:13481>))\n\n    $SAFE = 1\n    filename = \"foo\"\n    filename.taint\n    p load(filename, true)\n\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       true\n\n    => ruby 1.6.4 (2001-08-06) [i586-linux]\n       -:4:in `load': Insecure operation - load (SecurityError)\n            from -:4\n\n: ((<Regexp>))\n\n  以下で、前者がマッチしませんでした。((<ruby-talk:16233>))\n\n    puts \"OK 1\" if /(.|a)bd/ =~ \"cxbd\"\n    puts \"OK 2\" if /(a|.)bd/ =~ \"cxbd\"\n\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       OK 2\n    => ruby 1.6.4 (2001-08-06) [i586-linux]\n       OK 1\n       OK 2\n\n: ((<Marshal>))\n\n  モジュールのロードの型チェックに誤りがありました。この変更によりdump\n  フォーマットのマイナーバージョンが1あがりました\n\n    p Marshal.dump(Object.new).unpack(\"CC\").join(\".\")\n        => ruby 1.6.4 (2001-06-04) [i586-linux]\n           \"4.5\"\n    p Marshal.dump(Object.new).unpack(\"CC\").join(\".\")\n        => ruby 1.6.4 (2001-06-11) [i586-linux]\n           \"4.6\"\n\n: $SAFE / ((<クラス／メソッドの定義/def>))\n\n  doc/NEWS には\n\n    Fixed so defining a new method is allowed under $SAFE == 4, which\n    previously wasn't.\n\n  とあるけど実際にはできません。\n\n    $SAFE = 4; def a; end\n\n    => -:1: Insecure operation `(null)' at level 4 (SecurityError)\n       ruby 1.6.4 (2001-06-04) [i586-linux]\n\n    => -:1: Insecure: can't define method (SecurityError)\n       ruby 1.6.4 (2001-08-06) [i586-linux]\n\n  対応するChangeLogは以下のようです。\n\n    Tue Jun  5 15:16:06 2001  Yukihiro Matsumoto  <matz@ruby-lang.org>\n\n            * eval.c (rb_add_method): should not call rb_secure(), for\n              last_func may not be set.\n\n  差分は以下のようです。\n\n    @@ -227,10 +227,7 @@ rb_add_method(klass, mid, node, noex)\n         NODE *body;\n\n         if (NIL_P(klass)) klass = rb_cObject;\n    -    if (klass == rb_cObject) {\n    -       rb_secure(4);\n    -    }\n    -    if (rb_safe_level() >= 4 && !OBJ_TAINTED(klass)) {\n    +    if (rb_safe_level() >= 4 && (klass == rb_cObject || !OBJ_TAINTED(klass))) {\n            rb_raise(rb_eSecurityError, \"Insecure: can't define method\");\n         }\n         if (OBJ_FROZEN(klass)) rb_error_frozen(\"class/module\");\n\n  また今度調べ直します。\n\n: ((<IO>))#ioctl\n\n  第二引数に Bignum も受け付けるようになりました(long int の範囲をカバー\n  するため)\n\n== 1.6.3 (2001-03-19) -> 1.6.4 (2001-06-04)\n\n: ((<Hash>))#replace\n\n  ハッシュのイテレート中に、そのハッシュのある要素を削除して、\n  他のハッシュへreplaceするとAbortしていました。((<ruby-dev:13432>))\n\n    h  = { 10 => 100, 20 => 200 }\n    h2 = { }\n\n    h.each { |k, v|\n      if (k == 10)\n        h.delete(10)\n        h2.replace(h)  # => Abort core dumped\n      end\n    }\n\n: $SAFE / ((<File>)).unlink\n\n  File.unlink は引数が汚染されてなくても $SAFE >= 2 の環境下では\n  禁止するようになりました。((<ruby-dev:13426>))\n\n    touch foo\n    ruby -v -e '$SAFE=2;File.unlink(\"foo\")'\n\n    => ruby 1.6.3 (2001-03-19) [i586-linux]\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       -e:1:in `unlink': Insecure operation `unlink' at level 2 (SecurityError)\n               from -e:1\n\n: ((<Object>))#untaint\n\n  凍結したオブジェクトに対してuntaintできないようにしました。((<ruby-dev:13409>))\n\n    a = Object.new\n    a.taint\n    a.freeze\n    a.untaint\n\n    => ruby 1.6.3 (2001-03-19) [i586-linux]\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       -:4:in `untaint': can't modify frozen object (TypeError)\n               from -:4\n\n: ruby -T4\n\n  オプション ((<-T4|Rubyの起動/-T[level]>)) を指定したとき、ARGV を\n  変更できないためプログラムの実行ができませんでした。\n  ((<ruby-dev:13401>))\n\n    touch foo\n    ruby-1.6.3 -v -T4 foo\n    => ruby 1.6.3 (2001-03-19) [i586-linux]\n       foo: Insecure: can't modify array (SecurityError)\n\n: ((<Regexp>))\n\n  正規表現中の \\1 .. \\9 は常にバックリファレンスとして解釈されるように\n  なりました(以前は対応する括弧があればバックリファレンス、なければ8進\n  の文字コードとして解釈されていました)。\n\n  正規表現で8進文字コードを指定するには \\001 のように3桁で指定します。\n\n  また、対応する括弧のないバックリファレンスや対応する括弧が自身を含む\n  バックリファレンスは常にマッチに失敗するようになりました。\n\n    p /(foo)\\2/ =~ \"foo\\002\"\n    => ruby 1.6.3 (2001-03-19) [i586-linux]\n       0\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       0\n    => ruby 1.6.4 (2001-08-23) [i586-linux]\n       nil\n\n  (上記の通り 1.6.4 にはまだバグがありました 2001-08-23 あたりで修正さ\n  れています ((<ruby-list:30975>)))\n\n    p /(foo\\1)/ =~ \"foo\"\n    => ruby 1.6.3 (2001-03-19) [i586-linux]\n       0\n    => ruby 1.6.4 (2001-06-04) [i586-linux]\n       nil\n\n: 汚染文字列の伝搬\n\n  以下は、すべて true を返すようになりました。((<ruby-dev:13340>))\n\n    # []=\n    s1 = \"abc\"\n    s2 = \"cde\".taint\n    s1[0]= s2\n    p s1.tainted?             # => false\n\n    # crypt\n    s = \"abc\".taint\n    p s.crypt(\"cd\").tainted?  # => false\n\n    # ljust\n    s = \"abc\".taint\n    p s.ljust(10).tainted?    # => false\n\n    # rjust\n    s = \"abc\".taint\n    p s.rjust(10).tainted?    # => false\n\n    # center\n    s = \"abc\".taint\n    p s.center(10).tainted?   # => false\n\n: rb_yield_0()\n\n  C API から yield されたとき 1 つの引数が 1 要素の配列として渡されていました。\n  ((<ruby-dev:13299>))\n\n    class X\n      include Enumerable\n\n      def each(&block)\n        block.call(1,2)\n        block.call(2,3)\n        block.call(3,4)\n      end\n    end\n\n    x = X.new\n    p x.to_a #=> [[1], [2], [3]]\n\n    # => ruby 1.6.3 (2001-03-19) [i586-linux]\n         [[1], [2], [3]]\n\n    # => ruby 1.6.4 (2001-06-04) [i586-linux]\n         [1, 2, 3]\n\n: $SAFE / alias\n\n  $SAFE = 4 のときグローバル変数のエイリアスを許さないようにしました。\n  ((<ruby-dev:13287>))\n\n: ((<open3/Open3.popen3>))\n\n  終了したプロセスが at_exit を呼ばないようにしました。\n  (exit を exit! に修正) ((<ruby-dev:13170>))\n\n: ((<SizedQueue>))#pop\n\n  以下のコードでデッドロックが起こらないようにしました。((<ruby-dev:13169>))\n\n    ruby -r thread -e 'q = SizedQueue.new(1); q.push(1);'\\\n                   -e 'Thread.new{sleep 1; q.pop}; q.push(1);'\n\n: ((<SizedQueue>))#max=\n\n  maxが現在値より大きい時にその差の分だけ待ちスレッドを起こす処理\n  の判定に誤りがありました。((<ruby-dev:13170>))\n\n: ((<Queue>))\n: ((<SizedQueue>))\n\n  ((<Thread>))#run を呼ぶ直前にスレッドが死んでいた場合に ((<ThreadError>))\n  が発生する問題に対処しました。((<ruby-dev:13194>))\n\n: Ctrl-C (Interrupt)が効かなくなる\n\n  ((<ruby-dev:13195>))\n\n    th1 = Thread.start {\n      begin\n        Thread.stop\n      ensure\n        Thread.pass\n        Thread.stop\n      end\n    }\n    sleep 1\n\n  (確認できる限りでは ruby-1.7.0 (2001-05-17) 以降で治ってますが、\n  1.6 には取り込まれていません)\n\n: ((<Array>))#&\n: ((<Array>))#|\n: ((<Array>))#uniq\n\n  結果の配列の要素が freeze され変更不可になっていました。((<ruby-list:29665>))\n\n    (%w(foo bar) & %w(foo baz))[0].upcase!\n    => -:1:in `upcase!': can't modify frozen string (TypeError)\n\n    %w(foo bar bar baz).uniq[0].upcase!\n    => -:1:in `upcase!': can't modify frozen string (TypeError)\n\n: ((<shell>))\n\n    shell 0.6 が標準ライブラリとして新規に追加されました。\n    (ドキュメントが doc ディレクトリにあります)\n\n: ((<forwardable>))\n\n    forwardable 1.1 が標準ライブラリとして新規に追加されました。\n    (ドキュメントが doc ディレクトリにあります)\n\n: ((<irb>)) & irb-tools\n\n    irb と irb-tools がそれぞれ 0.7.4 と 0.7.1 にバージョンアップしました。\n\n: 夏時間\n\n  夏時間の考慮に不備がありました(？) ((<ruby-bugs-ja:PR#46>))\n\n    env TZ=America/Managua ruby -e 'p Time.local(1998,12,1,0,59,59)'\n    => Mon Nov 30 01:59:59 EST 1998\n    env TZ=America/Managua ruby -e 'p Time.local(1998,12,1,0,59,59).tv_sec'   \n    => 912409199\n\n: SIGINFO\n\n  4.4BSD のシグナル SIGINFO に対応しました。((<ruby-bugs-ja:PR#45>))\n\n: ((<Thread>)).stop で SEGV\n\n  ((<Thread>)).stop で SEGV することがありました。((<ruby-dev:13189>))\n\n: rescue 修飾\n\n  以下が 1.6.3 で parse error になっていたバグが修正されました。\n  ((<ruby-dev:13073>)), ((<ruby-dev:13292>))\n\n    raise \"\" rescue []\n    raise \"\" rescue (p \"foo\"; true)\n    raise \"\" rescue -1\n    raise \"\" rescue (-1)\n\n: ((<Thread>))\n\n  以下は dead lock にならなくなりました。\n\n    Thread.start { Thread.stop }\n    sleep\n\n    => deadlock 0x40199b58: 2:0  - -:1\n       deadlock 0x401a2528: 2:4 (main) - -:2\n       -:2:in `sleep': Thread: deadlock (fatal)\n               from -:2\n       ruby 1.6.3 (2001-03-19) [i586-linux]\n\n: ((<Module>))#const_defined?\n: ((<Module>))#const_get\n: ((<Module>))#const_set\n\n  これらのメソッドが定数以外にアクセス可能になっていたバグが修正されました\n  ((<ruby-dev:13019>))\n\n: ((<Marshal>)).dump\n\n  ((<Float>)) を dump するときの精度が \"%.12g\" から \"%.16g\" になりました。\n  ((<ruby-list:29349>))\n\n: ((<Fixnum>))#[]\n\n  sizeof(long) > sizeof(int) なシステムでのバグが修正されたようです。\n\n: 正規表現\n\n  まれなバグが2件修正されました ((<ruby-talk:13658>)), ((<ruby-talk:13744>))\n\n: retry\n\n  以下が 1.6.3 で正常に機能しませんでした((<ruby-talk:13957>))\n\n        def WHILE(cond)\n          return if not cond\n          yield\n          retry\n        end\n\n        i=0\n        WHILE(i<3) {\n          print i\n          i+=1\n        }\n\n        ruby 1.6.2 (2000-12-25) [i586-linux]\n        => 012\n\n        ruby 1.6.3 (2001-03-19) [i586-linux]\n        => 0\n\n        ruby 1.6.4 (2001-05-02) [i586-linux]\n        => 012\n\n: ((<File::Stat>))#size\n\n  1G byte 以上のファイルに対して正しくファイルサイズを返していませんでした。\n\n        File.open(\"/tmp/1GB\", \"w\") {|f|\n          f.seek(2**30-1, 0)\n          f.puts\n          f.flush\n          p f.stat.size\n        }\n\n        # => ruby 1.6.3 (2001-04-03) [i586-linux]\n             -1073741824\n        # => ruby 1.6.4 (2001-04-19) [i586-linux]\n             1073741824\n\n: ((<Float>))#modulo, ((<Float>))#divmod\n\n  なんか修正されたみたいです ((<ruby-dev:12718>))\n\n: ((<ObjectSpace>))#_id2ref\n\n  不正に例外を返す場合がありました。\n\n: malloc の再帰呼び出し問題\n\n  stdio が内部で malloc() を呼び出す場合、Thread と相性が悪かったことに対\n  処しました。(setvbuf() を使用することで malloc() が呼ばれるのを避けた)\n  ((<ruby-dev:12795>))\n\n: ((<File>))#flock\n\n  File#flock がロック済みの場合に false を返さず Errno::EACCES 例外を\n  あげる場合がありました(flock()がないシステムの場合)\n\n: ((<File::Stat>)).new(filename)\n\n  追加 ((<ruby-dev:12803>))\n\n: ((<Bignum>))#% の計算誤り\n\n  % の計算に誤りが出ることがあるバグが(再度)修正されました\n\n        a = 677330545177305025495135714080\n        b = 14269972710765292560\n        p a % b  #=> 0\n        p -a % b #=> \n\n        => ruby 1.6.3 (2001-04-02) [i386-cygwin]\n           0\n           14269972710765292560\n\n        => ruby 1.6.4 (2001-04-19) [i586-linux]\n           0\n           0\n\n: ((<Marshal>))\n  Bignum を dump -> load した結果が元の値と異なる場合がありました。\n\n  これに関連する修正が 1.6.3 リリース後、3回ほど行われています。\n  stable-snapshot の\n    ruby 1.6.3 (2001-03-22)\n  以降を使用してください。\n\n: Universal Naming Convention(UNC) のサポート(win32)\n  UNC 形式のパス名 (//host/share) がサポートされました。\n  バックスラッシュ(`(({\\}))')ではなくスラッシュ(`(({/}))')を使います。\n  (元もとサポートされてたのがバグ修正された？？)\n\n: ((<Dir>)).glob (win32)\n  カレントディレクトリ(./)に対するglobが失敗していました。\n        p Dir[\"./*.c\"]\n        => []\n\n== 1.6.2 -> 1.6.3 (2001-03-19)\n\n: do .. end と { .. }\n  結合強度の違いがなくなっていたバグが修正されました。\n\n  1.6.0 から 1.6.2 までのバージョンでは、\n     method v { .. }\n     method v do .. end\n  の両者に違いがありませんでした。本来の挙動は((<メソッド呼び出し/イテレータ>))\n  に書かれた通りです。\n\n: ((<Bignum>))#% の計算誤り\n  % の計算に誤りが出ることがあるバグが修正されました\n\n    ruby-1.6.2 -ve 'p 6800000000%4000000000'\n    => ruby 1.6.2 (2000-12-25) [i586-linux]\n       -1494967296\n\n    ruby-1.6.3 -ve 'p 6800000000%4000000000'\n    => ruby 1.6.3 (2001-03-10) [i586-linux]\n       2800000000\n\n: 特異メソッド定義\n  通常のメソッド定義と同様に rescue, ensure 節の指定が可能になりました\n\n    obj = Object.new\n    def obj.foo\n    rescue\n    ensure\n    end\n\n: ((<String>))#count\n: ((<String>))#delete\n: ((<String>))#squeeze\n: ((<String>))#tr\n: ((<String>))#tr_s\n  '\\-' で '-' を指定可能になりました(tr! 等、bang method も同様)。\n  以前は、文字列の先頭または末尾の'-'だけを'-'と見なしていました。\n\n    p \"-\".tr(\"a-z\",  \"+\")  # => \"-\"\n    p \"-\".tr(\"-az\",  \"+\")  # => \"+\"\n    p \"-\".tr(\"az-\",  \"+\")  # => \"+\"\n    p \"-\".tr('a\\-z', \"+\")  # => \"+\" # シングルクォート文字列であることに注意\n    p \"-\".tr(\"a\\\\-z\", \"+\") # => \"+\" # \"\" では二重に\\が必要\n\n: ((<Regexp>))#==\n  すべてのオプションも同じならば同じと判断するようになりました。\n  以前は、漢字コード指定と /i (case-insensitive) の指定が同じで\n  あれば同じと判断していました。\n\n: %q(), %w()\n  リテラルの終了文字(`)'など)をバックスラッシュエスケープ可能になりました。\n\n: ((<Dir>)).glob\n  \"**/\" がシンボリックリンクを辿らなくなりました。\n\n: ((<String>))#[]\n  \"a\"[1,2] が \"\" を返すようになりました。\n\n    p \"a\"[1,2]\n    => \"\"\n\n  これは本来の挙動です。過去のバージョン(1.4.6など)もこの値を返していました。\n  1.6.0 以降 1.6.2 までは上記は (({nil})) になります。\n\n  (({p \"a\"[2,1]})) は、(({nil})) を返します。\n\n: ((<Object>))#taint\n  ((<freeze|Object>)) したオブジェクトに対して (({taint})) できなくなりました\n\n    obj = Object.new.freeze\n    obj.taint\n    => -:2:in `taint': can't modify frozen object (TypeError)\n               from -:2",
          "snippets": []
        }
      ],
      "related_entries": []
    },
    {
      "signature": "Thread#status -> String | false | nil",
      "score": 85.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "生きているスレッドの状態を文字列 \"run\"、\"sleep\", \"aborting\" のいず\nれかで返します。正常終了したスレッドに対して false、例外によ\nり終了したスレッドに対して nil を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/status.html",
          "description": "生きているスレッドの状態を文字列 \"run\"、\"sleep\", \"aborting\" のいず\nれかで返します。正常終了したスレッドに対して false、例外によ\nり終了したスレッドに対して nil を返します。\n\nThread#alive? が真を返すなら、このメソッドも真です。\n\n例:\n  a = Thread.new { raise(\"die now\") }\n  b = Thread.new { Thread.stop }\n  c = Thread.new { Thread.exit }\n  d = Thread.new { sleep }\n  d.kill                  #=> #<Thread:0x401b3678 aborting>\n  a.status                #=> nil\n  b.status                #=> \"sleep\"\n  c.status                #=> false\n  d.status                #=> \"aborting\"\n  Thread.current.status   #=> \"run\"\n\n@see Thread#alive?, Thread#stop?",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "File#flock(operation) -> 0 | false",
      "score": 73.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "ファイルをロックします。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/File/i/flock.html",
          "description": "ファイルをロックします。\n\nロックを取得するまでブロックされます。\nロックの取得に成功した場合は 0 を返します。\nFile::LOCK_NB (ノンブロッキング) を指定すると、本来ならブロックされる場合に\nブロックされずに false を返すようになります。\n\n@param operation ロックに対する操作の種類を示す定数を指定します。\n                 どのような定数が利用可能かは以下を参照して下さい。\n\n@raise IOError 自身が close されている場合に発生します。\n\n@raise Errno::EXXX operation に不正な整数を与えた場合などに発生します。\n\n引数 operation に有効な定数は以下の通りです。定数は File::Constants で定義されていますが、\nFile クラスの親クラスの IO が File::Constants をインクルードしているので、\nこれらの定数は File::LOCK_SH などとして参照可能です。\n\n: LOCK_SH\n 共有ロック。複数のプロセスが同時にロックを共有できます。\n システムによってはロック対象のファイルは読み込みモード\n (\"r\", \"r+\" など)でオープンされている必要があります。そのよ\n うなシステムでは読み込み可能でないファイルに対するロックは例外\n Errno::EXXX が発生するかもしれません。\n: LOCK_EX\n 排他ロック。同時にはただひとつのプロセスだけがロックを保持できます。\n システムによってはロック対象のファイルは書き込みモード\n (\"w\", \"r+\" など)でオープンされている必要があります。そのよ\n うなシステムでは書き込み可能でないファイルに対するロックは例外\n Errno::EXXX が発生するかもしれません。\n: LOCK_UN\n アンロック。\n この明示的なアンロック以外に、ファイルのcloseやRubyインタプリタの終了\n (プロセスの終了)によっても自動的にロック状態は解除されます。\n: LOCK_NB\n ノンブロックモード。\n File::LOCK_SH | File::LOCK_NB のように他の指定と or することで指\n 定します。この指定がない場合、ブロックされる条件での flock\n の呼び出しはロックが解除されるまでブロックされます。\n\nFile::LOCK_NB の指定がある場合、ブロックされる条件での\nflock は false を返します。\n\n「ブロックされる条件」とは以下のいずれかです。\n  * 他のプロセスが排他ロックをすでに行っている場合にロックを行う\n  * 他のプロセスがロックしている状態で排他ロックを行う\n\n//emlist[例1:][ruby]{\n# 書き込みロック(write lock)を使用してカウンタを更新。\n# ロック前にファイルを切り詰めてしまうので、\n# モードに\"w\"を使ってはいけません。\nFile.open(\"counter\", File::RDWR|File::CREAT, 0644) {|f|\n  f.flock(File::LOCK_EX)\n  value = f.read.to_i + 1\n  f.rewind\n  f.write(\"#{value}\\n\")\n  f.flush\n  f.truncate(f.pos)\n}\n\n# 読み込みロック(read lock)を使用してカウンタを読み込み。\nFile.open(\"counter\", \"r\") {|f|\n  f.flock(File::LOCK_SH)\n  p f.read\n}\n//}\n\n//emlist[例2:][ruby]{\nf = File.open(\"/tmp/foo\", \"w\")\n\nf.flock(File::LOCK_EX)\nputs \"locked by process1\"\n\nfork {\n  f = File.open(\"/tmp/foo\", \"r\")\n  f.flock(File::LOCK_SH)\n  puts \"locked by process2\"\n  sleep 5\n  puts \"unlocked by process2\"\n}\n\nsleep 5\n\nf.flock(File::LOCK_UN)\nputs \"unlocked by process1\"\nsleep 1 # <- 子プロセスが確実に先にロックするための sleep\nf.flock(File::LOCK_EX)\nputs \"re-locked by process1\"\n\n# => locked by process1\n#    unlocked by process1\n#    locked by process2\n#    unlocked by process2\n#    re-locked by process1\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Errno::EXXX",
          "label": "Errno::EXXX",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Errno%3A%3AEXXX/"
        },
        {
          "key": "File",
          "label": "File",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:File/"
        },
        {
          "key": "File::Constants",
          "label": "File::Constants",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:File%3A%3AConstants/"
        }
      ]
    },
    {
      "signature": "Kernel.#exec(env, program, *args, options={}) -> ()",
      "score": 73.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "引数で指定されたコマンドを実行します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Kernel/m/exec.html",
          "description": "引数で指定されたコマンドを実行します。\n\nプロセスの実行コードはそのコマンド(あるいは shell)になるので、\n起動に成功した場合、このメソッドからは戻りません。\n\nこの形式では、常に shell を経由せずに実行されます。\n\nexec(3) でコマンドを実行すると、\n元々のプログラムの環境をある程度(ファイルデスクリプタなど)引き継ぎます。\nHash を options として渡すことで、この挙動を変更できます。\n詳しくは Kernel.#spawn を参照してください。\n\n=== 引数の解釈\n\nこの形式で呼び出した場合、空白や shell のメタキャラクタも\nそのまま program の引数に渡されます。\n先頭の引数が2要素の配列であった場合、第1要素の文字列が実際に\n起動するプログラムのパスであり、第2要素が「みせかけ」のプロ\nグラム名になります。\nまた、第1要素はフルパスで指定しなくても環境変数 PATH から探します。\n\n@param program 文字列か2要素の配列を指定します。\n@param args 渡される引数です。0 個以上の文字列を指定します。\n@param env 更新する環境変数を表す Hash\n@param options オプションパラメータ Hash\n@raise ArgumentError 第一引数が配列かつ要素数が 2 でない場合に発生します。\n@raise Errno::EXXX 起動に失敗し、ruby インタプリタに制御が戻った場合に発生します。\n\n\n\n//emlist[例][ruby]{\n# a.rb\nexec ['sleep', 'mysleep'], '600'\n//}\n\n上記スクリプトを実行すると以下のようになります。\n\n  $ ruby a.rb\n  ## sleep してるので制御が戻ってこない。別の仮想端末に切替えて以下を実行\n  $ ps aux|grep sleep\n  xxxx    32754  0.0  0.0   2580   468 pts/3    S+   22:01   0:00 mysleep 600\n  xxxx    32761  0.0  0.0   2824   792 pts/6    S+   22:01   0:00 grep sleep\n\n@see Kernel.#system,Kernel.#`,Kernel.#spawn,Kernel.#fork,IO.popen,IO.pipe,Kernel.#open,exec(3)",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Kernel/"
        }
      ]
    },
    {
      "signature": "Kernel.#exec(program, *args, options={}) -> ()",
      "score": 73.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "引数で指定されたコマンドを実行します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Kernel/m/exec.html",
          "description": "引数で指定されたコマンドを実行します。\n\nプロセスの実行コードはそのコマンド(あるいは shell)になるので、\n起動に成功した場合、このメソッドからは戻りません。\n\nこの形式では、常に shell を経由せずに実行されます。\n\nexec(3) でコマンドを実行すると、\n元々のプログラムの環境をある程度(ファイルデスクリプタなど)引き継ぎます。\nHash を options として渡すことで、この挙動を変更できます。\n詳しくは Kernel.#spawn を参照してください。\n\n=== 引数の解釈\n\nこの形式で呼び出した場合、空白や shell のメタキャラクタも\nそのまま program の引数に渡されます。\n先頭の引数が2要素の配列であった場合、第1要素の文字列が実際に\n起動するプログラムのパスであり、第2要素が「みせかけ」のプロ\nグラム名になります。\nまた、第1要素はフルパスで指定しなくても環境変数 PATH から探します。\n\n@param program 文字列か2要素の配列を指定します。\n@param args 渡される引数です。0 個以上の文字列を指定します。\n@param env 更新する環境変数を表す Hash\n@param options オプションパラメータ Hash\n@raise ArgumentError 第一引数が配列かつ要素数が 2 でない場合に発生します。\n@raise Errno::EXXX 起動に失敗し、ruby インタプリタに制御が戻った場合に発生します。\n\n\n\n//emlist[例][ruby]{\n# a.rb\nexec ['sleep', 'mysleep'], '600'\n//}\n\n上記スクリプトを実行すると以下のようになります。\n\n  $ ruby a.rb\n  ## sleep してるので制御が戻ってこない。別の仮想端末に切替えて以下を実行\n  $ ps aux|grep sleep\n  xxxx    32754  0.0  0.0   2580   468 pts/3    S+   22:01   0:00 mysleep 600\n  xxxx    32761  0.0  0.0   2824   792 pts/6    S+   22:01   0:00 grep sleep\n\n@see Kernel.#system,Kernel.#`,Kernel.#spawn,Kernel.#fork,IO.popen,IO.pipe,Kernel.#open,exec(3)",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Kernel/"
        }
      ]
    },
    {
      "signature": "Thread",
      "score": 73.0,
      "metadata": {
        "type": "class",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドを表すクラスです。スレッドとはメモリ空間を共有して同時に実行される制御の流れです。\nThread を使うことで並行プログラミングが可能になります。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/class/Thread.html",
          "description": "スレッドを表すクラスです。スレッドとはメモリ空間を共有して同時に実行される制御の流れです。\nThread を使うことで並行プログラミングが可能になります。\n\n\n=== 実装\nネイティブスレッドを用いて実装されていますが、\n現在の実装では Ruby VM は Giant VM lock (GVL) を有しており、同時に実行される\nネイティブスレッドは常にひとつです。\nただし、IO 関連のブロックする可能性があるシステムコールを行う場合には\nGVL を解放します。その場合にはスレッドは同時に実行され得ます。\nまた拡張ライブラリから GVL を操作できるので、複数のスレッドを\n同時に実行するような拡張ライブラリは作成可能です。\n\n=== スケジューリング\nRuby のスレッドスケジューリングはネイティブスレッドのそれを利用しています。\nよって詳細はプラットフォームに依存します。\n\n=== メインスレッド\n\nプログラムの開始と同時に生成されるスレッドを「メインスレッド」と呼\nびます。なんらかの理由でメインスレッドが終了する時には、他の全てのスレッ\nドもプログラム全体も終了します。ユーザからの割込みによって発生した例外\nはメインスレッドに送られます。\n\n=== スレッドの終了\n\nスレッドの起動時に指定したブロックの実行が終了するとスレッドの実行も終\n了します。ブロックの終了は正常な終了も例外などによる異常終了も含みます。\n\n===[a:exception] 例外発生時のスレッドの振る舞い\n\nあるスレッドで例外が発生し、そのスレッド内で rescue で捕捉されなかっ\nた場合、通常はそのスレッドだけがなにも警告なしに終了されます。ただ\nしその例外で終了するスレッドを Thread#join で待っている他の\nスレッドがある場合、その待っているスレッドに対して、同じ例外が再度\n発生します。\n\n  begin\n    t = Thread.new do\n      Thread.pass    # メインスレッドが確実にjoinするように\n      raise \"unhandled exception\"\n    end\n    t.join\n  rescue\n    p $!  # => \"unhandled exception\"\n  end\n\nまた、以下の 3 つの方法により、いずれかのスレッドが例外によって終\n了した時に、インタプリタ全体を中断させるように指定することができま\nす。\n\n  * 組み込み変数 $DEBUG を真に設定する(デバッグモード)\n    ruby インタプリタを -d オプション 付きで起動した場合も同様。\n    (オプションの詳細に関してはspec/rubycmd を参照)\n  * Thread.abort_on_exception でフラグを設定する。\n  * Thread#abort_on_exception で指定\n    したスレッドのフラグを設定する。\n\n上記3つのいずれかが設定されていた場合、インタプリタ全体が中断されます。\n\n=== スレッド終了時の ensure 節の実行\n\nスレッド終了時には ensure 節が実行されます。\nこれはスレッドが正常に終了する時はもちろんですが、他のスレッドから Thread#kill\nなどによって終了させられた時も同様に実行されます。\n\nメインスレッドの終了時の詳細に関しては spec/terminate を参照して下さい。\n\n=== スレッドの状態\n\n個々のスレッドは、以下の実行状態を持ちます。これらの状態は\nObject#inspect や\nThread#status によって見ることができます。\n\n p Thread.new {sleep 1} # => #<Thread:0xa039de0 sleep>\n\n: run (実行or実行可能状態)\n 生成されたばかりのスレッドや Thread#run や\n Thread#wakeup で起こされたスレッドはこの状態です。\n Thread#join でスレッドの終了を待っているスレッドもスレッドの\n 終了によりこの状態になります。\n \n この状態のスレッドは「生きて」います。\n\n: sleep (停止状態)\n Thread.stop や Thread#join により停止されたスレッ\n ドはこの状態になります。\n \n この状態のスレッドは「生きて」います。\n\n: aborting (終了処理中)\n Thread#kill 等で終了されるスレッドは一時的にこの状態になりま\n す。この状態から停止状態(sleep)になることもあります。\n \n この状態のスレッドはまだ「生きて」います。\n\n: dead (終了状態)\n Thread#kill 等で終了したスレッドはこの状態になります。この状\n 態のスレッドはどこからも参照されていなければ GC によりメモリ上から\n なくなります。\n \n この状態のスレッドは「死んで」います。\n\n\n=== デッドロックの検出\n@todo",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "spec/rubycmd",
          "label": "spec/rubycmd",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:spec%2Frubycmd/"
        },
        {
          "key": "spec/terminate",
          "label": "spec/terminate",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:spec%2Fterminate/"
        }
      ]
    },
    {
      "signature": "ruby 1.8.3 feature",
      "score": 73.0,
      "metadata": {
        "type": "document",
        "versions": [
          "3.3"
        ]
      },
      "summary": "ruby 1.8.3 feature \n*((<ruby 1.8 feature>))\n*((<ruby 1.8.2 feature>))",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/doc/news=2f1=2e8=2e3.html",
          "description": "ruby 1.8.3 feature \n*((<ruby 1.8 feature>))\n*((<ruby 1.8.2 feature>))\n\nruby 1.8.2 から ruby 1.8.3 までの変更点です。\n\n掲載方針\n\n*バグ修正の影響も含めて動作が変わるものを収録する。\n*単にバグを直しただけのものは収録しない。\n*ライブラリへの単なる定数の追加は収録しない。\n\n以下は各変更点に付けるべきタグです。\n\n記号について(特に重要なものは大文字(主観))\n\n* カテゴリ\n  * [ruby]: ruby インタプリタの変更\n  * [api]: 拡張ライブラリ API\n  * [lib]: ライブラリ\n* レベル\n  * [bug]: バグ修正\n  * [new]: 追加されたクラス／メソッドなど\n  * [compat]: 変更されたクラス／メソッドなど\n    * 互換性のある変更\n    * only backward-compatibility\n    * 影響の範囲が小さいと思われる変更もこちら\n  * [change]: 変更されたクラス／メソッドなど(互換性のない変更)\n  * [obsolete]: 廃止された(される予定の)機能\n  * [platform]: 対応プラットフォームの追加\n\nbundled libraryである(rubyの一部ではない)soap4rの変更点については、以下を参考にしてください。\nsoap4r-1.5.3がruby-1.8.2、soap4r-1.5.5がruby-1.8.3にbundleされています。\n * ((<URL:http://dev.ctor.org/soap4r/wiki/Changes-154>))\n * ((<URL:http://dev.ctor.org/soap4r/wiki/Changes-155>))\n\n== 1.8.2 (2004-12-25) -> 1.8.3 (2005-09-21)\n\n=== 2005-09-19\n: FileUtils.remove_entry_secure [lib] [new]\n: FileUtils.remove_entry        [lib] [new]\n: FileUtils.chmod_R             [lib] [new]\n: FileUtils.chown               [lib] [new]\n: FileUtils.chown_R             [lib] [new]\n: FileUtils.commands            [lib] [new]\n: FileUtils.options             [lib] [new]\n: FileUtils.have_option?        [lib] [new]\n: FileUtils.options_of          [lib] [new]\n: FileUtils.collect_method      [lib] [new]\n\n  追加。\n\n: FileUtils.rm_r  [lib] [compat]\n: FileUtils.rm_rf [lib] [compat]\n: FileUtils.cd    [lib] [compat]\n: FileUtils.cp_r  [lib] [compat]\n\n  rm_f と rm_rf が :secure オプションを受け付けるようになりました。\n  cd が :noop オプションを受け付けなくなりました。\n  cp_r が :dereference_root オプションを受け付けるようになりました。\n\n=== 2005-09-16\n: File.join [ruby] [compat]\n\n  型チェックを厳密にするようになりました。\n\n    $ ruby-1.8.2 -e 'p File.join(1, 2)'\n    \"1/2\"\n    \n    $ ruby-1.8.3 -e 'p File.join(1, 2)'\n    -e:1:in `join': can't convert Fixnum into String (TypeError)\n            from -e:1\n\n=== 2005-09-16\n: File.extname [ruby] [compat]\n\n  与えられた pathname がピリオドで終る場合、ピリオドではなく空の文字列を返すようになりました。\n\n    $ ruby-1.8.2 -e 'p File.extname(\"a.\")'\n    \".\"\n    $ ruby-1.8.3 -e 'p File.extname(\"a.\")'\n    \"\"\n\n=== 2005-09-13\n: Logger#formatter  [lib] [new]\n: Logger#formatter= [lib] [new]\n: Logger::Formatter [lib] [new]\n\n  追加。\n\n=== 2005-09-13\n: Net::HTTP\n\n  https での Proxy 認証をサポートするようになりました。\n \n: Net::HTTP.post_form(url, params) [lib] [new]\n\n: Net::HTTPHeader#content_length=  [lib] [new]\n: Net::HTTPHeader#content_type     [lib] [new]\n: Net::HTTPHeader#main_type        [lib] [new]\n: Net::HTTPHeader#sub_type         [lib] [new]\n: Net::HTTPHeader#type_params      [lib] [new]\n: Net::HTTPHeader#content_type=    [lib] [new]\n: Net::HTTPHeader#set_content_type [lib] [new]\n\n: Net::HTTPRequest#body(=)         [lib] [new]\n: Net::HTTPRequest#body_stream(=)  [lib] [new]\n\n  追加。\n\n: Net::HTTPHeader#each_capitalized      [lib] [compat]\n: Net::HTTPHeader#each_capitalized_name [lib] [new]\n\n  Net::HTTPHeader#canonical_each は Net::HTTPHeader#each_capitalized\n  に名前が変わりました。canonical_each も each_capitalized の別名とし\n  て提供されます。\n\n: net/http [lib] [new]\n\n  WebDAV のメソッドをサポートするようになりました。\n  PROPPATCH, LOCK, UNLOCK, OPTIONS, PROPFIND, DELETE, MOVE, COPY, MKCOL。\n  \n: Net::HTTPRequest#body_exist?  [lib] [obsolete]\n: Net::HTTPResponse#response    [lib] [obsolete]\n: Net::HTTPResponse#header      [lib] [obsolete]\n: Net::HTTPResponse#read_header [lib] [obsolete]\n  \n  obsolete になりました。VERBOSE モードの時、警告が出ます。\n\n=== 2005-09-10\n: OpenSSL::PKCS7::RecipientInfo [lib] [new]\n: OpenSSL::PKCS7::SignerInfo    [lib] [compat]\n\n  新クラス、追加。OpenSSL::PKCS7::Signer が OpenSSL::PKCS7::SignerInfo に名前が変わりました。Signer も別名として\n  引続き提供されます。\n\n=== 2005-09-10\n: OpenSSL::Digest::SHA224\n: OpenSSL::Digest::SHA256\n: OpenSSL::Digest::SHA384\n: OpenSSL::Digest::SHA512\n\n  新クラス、追加。OpenSSL 0.9.8 以降とともにコンパイルされた時のみ。\n\n=== 2005-09-09\n: $SAFE [ruby] [compat]\n\n  メソッドが定義された時の $SAFE レベルを記憶するようになりました。\n  メソッドは定義された時の $SAFE レベルで実行されます。\n  $SAFE レベル 3 以上の環境下において定義されたメソッドを呼び出すことは、$SAFE レベル が 0 のとき\n  禁止されるようになりました。\n\n    $ cat mthd_taint.rb\n    th = Thread.new{\n      $SAFE = 3\n      class Hoge\n        def foo\n          puts \"safe level: #{$SAFE}\"\n        end\n      end\n    }    \n    th.join\n    p $SAFE\n    Hoge.new.foo\n\n    $ ruby-1.8.2 mthd_taint.rb\n    0\n    \"safe level: 0\"\n    \n    $ ruby-1.8.3 mthd_taint.rb\n    0\n    mthd_taint.rb:11:in `foo': calling insecure method: foo (SecurityError)\n            from mthd_taint.rb:11\n\n=== 2005-09-09\n: String#*  [ruby] [compat]\n: String#[] [ruby] [compat]\n  空文字にも taint が伝播するようになりました。((<ruby-dev:26900>)) ((<ruby-dev:27121>))\n    $ ruby-1.8.2 -e 'p (\"x\".taint * 0).tainted?'\n    false\n    \n    $ ruby-1.8.3 -e 'p (\"x\".taint * 0).tainted?'\n    true\n\n    $ ruby-1.8.2 -e 'p (\"x\".taint[1..-1]).tainted?'\n    false\n    \n    $ ruby-1.8.3 -e 'p (\"x\".taint[1..-1]).tainted?'\n    true\n\n  Range オブジェクトが taint されている場合、\"string\"[range] も taint されるようになりました。((<ruby-dev:27121>))\n\n    $ ruby-1.8.2 -e 'p (\"x\"[(0..-1).taint]).tainted?'\n    false\n    \n    $ ruby-1.8.3 -e 'p (\"x\"[(0..-1).taint]).tainted?'\n    true\n\n=== 2005-08-29\n: Time.parse [lib] [compat]\n\n  Time.parse が小数点以下の秒も扱えるようになりました。((<ruby-talk:153859>))\n\n    $ ruby-1.8.2 -r time -e 'p  Time.parse(\"23 Aug 2005 19:00:01.1\").to_f'\n    1124791201.0\n    \n    $ ruby-1.8.3 -r time -e 'p  Time.parse(\"23 Aug 2005 19:00:01.1\").to_f'\n    1124791201.1\n\n=== 2005-08-20\n: Logger [lib] [bug]\n  ファイルをシフト時のレースコンディションが修正されました。\n\n=== 2005-08-07\n: WIN32OLE_EVENT#on_event [lib] [bug]\n  最後に定義したイベントハンドラが有効になるように修正しました。\n\n=== 2005-07-27\n: Dir#each    [ruby] [bug]\n: Dir#entries [ruby] [bug]\n\n  1回メソッドを呼んでしまうと空になるバグを修正しました。\n\n    $ ruby-1.8.2 -e '\n    d = Dir.new(\"/\")\n    d.entries\n    p d.entries\n    '\n    []\n     \n    $ ruby-1.8.3 -e '\n    d = Dir.new(\"/\")\n    d.entries\n    p d.entries\n    '\n    [\".\", \"..\", \"dev\", \"home\", \"proc\", \"var\", \"tmp\", \"etc\", \"usr\", \"sbin\", \"bin\", \"boot\"]\n\n\n\n=== 2005-07-11\n: 正規表現 [ruby] [bug]\n\n  正規表現リテラル中で \\c\\\\ 表記があるとパースエラーになるバグを修正しました。\n\n    $ cat r.rb\n    p /[\\c\\\\]/ =~ \"\\c\\\\\"\n    p /\\c\\\\/ =~ \"\\c\\\\\"\n    \n    $ ruby-1.8.2 r.rb\n    r.rb:1: premature end of regular expression: /[\\c\\\\]/\n    r.rb:2: invalid regular expression; '\\' can't be last character: /\\c\\\\/\n    \n    $ ruby-1.8.3 r.rb\n    0\n    0\n\n=== 2005-06-30\n: Delegator [lib] [compat]\n\n  Delegator オブジェクトが生成された後に定義されたメソッドに関しても、適切に委譲するようになりました。\n  ((<ruby-talk:146776>)) ((<ruby-talk:146894>))\n    $ cat test_dlg.rb\n    foo = Object.new\n    foo2 = SimpleDelegator.new(foo)\n    def foo.bar\n      puts \"bar\"\n    end\n    foo2.bar  \n     \n    $ ruby-1.8.2 -r delegate test_dlg.rb\n    test_dlg.rb:6: undefined method `bar' for #<Object:0x4021b0a0> (NoMethodError)\n    \n    $ ruby-1.8.3 -r delegate test_dlg.rb\n    bar\n\n=== 2005-06-20\n: DBM#closed? [lib] [new]\n: GDBM#closed? [lib] [new]\n: SDBM#closed? [lib] [new]\n\n=== 2005-06-16\n\n: Time.parse [lib] [compat]\n\n  うるう秒 \"Fri Jan  1 08:59:60 +0900 1999\" をサポートしている環境において、Time.parse が\n  適切に振舞うようになりました。\n\n=== 2005-06-08\n: Curses.insertln [lib] [new]\n: Curses::Window.insertln [lib] [new]\n\n=== 2005-06-08\n: ext/socket [lib] [compat]\n\n  拡張ライブラリ socket が AIX 上でコンパイルされるようになりました。((<ruby-list:40832>))\n\n=== 2005-06-07\n: Module#class_variable_get [ruby] [new]\n: Module#class_variable_set [ruby] [new]\n  \n  クラスメソッドから((<変数と定数/クラス変数>))にアクセスするための\n  ((<Module#class_variable_get|Module/class_variable_get>)) と\n  ((<Module#class_variable_set|Module/class_variable_set>)) が\n  追加されました。((<ruby-talk:144741>))\n\n    class Fred\n      @@foo = 99\n      def foo\n        @@foo\n      end\n    end\n    \n    def Fred.foo\n      @@foo = 101      #=> @@foo は Fred クラスのクラス変数ではない。\n    end\n    \n    def Fred.foo_foo   \n      class_variable_set(:@@foo, 101)  # self が Fred クラス自身であることに注意。クラス変数 @@foo に値をセットする。\n    end\n    \n    Fred.foo           # メソッドを呼んでも、Fred クラスのクラス変数 @@foo は変わらない。\n    p Fred.new.foo     #=> 99 \n\n    Fred.foo_foo       # \n    p Fred.new.foo     #=> 101\n\n\n=== 2005-05-28\n: WEBrick::CGI::Socket#request_line [lib] [compat]\n\n  WEBrick を CGI 環境下で使う場合、\n  request_line メソッドは REQUEST_URI ヘッダがあればそちらを優先して使うようになりました。\n  ((<ruby-dev:26235>))\n\n=== 2005-05-27\n: mkmf [lib] [bug]\n  MSYS 環境下において、PATHの区切り値にセミコロンを使うよう修正しました。((<ruby-dev:26232>))\n\n=== 2005-05-24\n: getopts [lib] [obsolete]\n  getopts が deprecated になりました。deprecated であるという警告は、\n  オプションに -w を付けた時に出ます。((<ruby-dev:26201>))\n\n=== 2005-05-22\n: OpenSSL::SSL::SSLServer#initialize(svr, ctx, session_id=nil)\n  session_id を受け付けるようになりました。((<ruby-core:4663>))\n\n=== 2005-05-19\n: REXML::Encoding#decode_sjis [lib] [bug]\n: REXML::Encoding#encode_sjis [lib] [bug]\n  decode_sjis と encode_sjis が\n  逆に定義されていたバグを修正しました。((<ruby-core:4772>))\n\n=== 2005-05-16\n: singleton class [ruby] [change]\n  特異クラスは複製できなくなりました。((<ruby-talk:142749>))\n\n    $ ruby-1.8.3 -e 'class << \"str\"; self end.dup'\n    -e:1:in `initialize_copy': can't copy singleton class (TypeError)\n            from -e:1\n\n=== 2005-05-15\n: Pathname#unlink [lib] [compat]\n  ディレクトリへのシンボリックリンクも削除されるようになりました。((<ruby-core:4992>))\n\n=== 2005-05-14\n: NameError\n: SystemCallError\n: SystemExit\n  各例外クラスのインスタンスが生成される時に、親クラスのコンストラクタ\n  である Exception#initialize が呼ばれるようになりました。((<ruby-talk:142593>)) ((<ruby-dev:26177>))\n\n=== 2005-05-11\n: break [ruby] [bug]\n  メソッドを越えて break が有効になるバグを修正しました。((<ruby-list:40818>))\n    \n    $ cat brk.rb\n    def stop(n)\n      break  if n == 2\n    end\n    \n    (1..5).each do |i|\n      stop(i)\n      puts i\n    end\n    \n    $ ruby-1.8.2 brk.rb\n    1\n    \n    $ ruby-1.8.3 brk.rb\n    1\n    brk.rb:2:in `stop': unexpected break (LocalJumpError)\n            from brk.rb:6\n            from brk.rb:5\n\n=== 2005-05-11\n: WEBrick::CGI#[]     [lib] [new]\n: WEBrick::CGI#logger [lib] [new]\n: WEBrick::CGI#config [lib] [new]\n\n=== 2005-05-01\n: ruby -s option [ruby] [bug]\n  オプション -s でアクセスできないグローバル変数ができてしまうバグを修正\n  しました。- を _ に変換してグローバル変数を定義するようになりました。- 以外の\n  記号がふくまれる場合は、例外 NameError を投げます。\n  \n    $ ruby-1.8.2 -se 'puts global_variables.grep(/foo/)' -- --foo-bar\n    $-foo-bar\n    $ ruby-1.8.3 -se 'puts global_variables.grep(/foo/)' -- --foo-bar\n    $_foo_bar\n\n    $ ruby-1.8.3 -se 'puts global_variables.grep(/foo/)' -- --foo\\@bar    \n    -e: invalid name for global variable - --foo@bar (NameError)\n\n=== 2005-04-18\n: WIN32OLE.codepage [lib] [new]\n: WIN32OLE.codepage= [lib] [new]\n\n=== 2005-04-10\n: WIN32OLE#invoke [lib] [bug]\n  nil を VT_ERROR に変換して Invokeを呼び出して失敗するときには VT_EMPTYに変換して\n  再度 Invokeを呼び出すようにしました。\n    \n=== 2005-04-09\n: rss [lib][new][compat]\n\n  複数のDublin Coreの要素を扱えるようになりました。\n\n  このためdc_#{Dublin Coreの要素名の複数形}というメソッドが導入されました。\n\n  互換性のために以前のdc_#{Dublin Coreの要素名の単数形}というメソッドも残されています。\n\n=== 2005-03-07\n: String#<=> [ruby][compat]\n\n  比較できないものを渡された時に false ではなく nil を返すようになりました。\n  ((<ruby-dev:25811>))\n\n    $ ruby-1.8.2 -e 'p \"a\" <=> 1'\n    false \n    $ ruby-1.8.3 -e 'p \"a\" <=> 1'\n    nil\n\n\n=== 2005-03-06\n: HTTPHeader#get_fields [lib][new]\n: HTTPHeader#add_field [lib][new]\n\n  追加。((<ruby-list:40629>))\n\n=== 2005-02-23\n: local variable and method [ruby][bug]\n  レシーバを指定したメソッド呼び出しが、同名のローカル変数の有無によっ\n  て影響されるバグが修正されました。\n  ((<ruby-dev:25737>))\n  ((<URL:http://yowaken.dip.jp/tdiary/20050220.html#p01>))\n\n=== 2005-02-17\n: Open3.popen3 [lib] [compat]\n  Open3.popen3実行後の$?.exitstatusが0になるように修正されました。\n\n: ((<クラス／メソッドの定義/defined?>)) [ruby][bug]\n  (({defined?(@a = b)}))のような NODE_IASGN が nil ではなく\n  \"assignment\" を返すようになりました。\n  ((<\"[yarv-dev:418]\"|URL:http://www.atdot.net/mla/yarv-dev/418>))\n\n=== 2005-02-17\n: Test::Unit::AutoRunner.run [lib] [change]\n  第一引数の意味が変わりました。\n\n=== 2005-02-14\n\n: OpenSSL::SSL::SSLSocket#post_connection_check [lib][new]\n\n  追加 ((<ruby-dev:25690>))\n\n=== 2005-02-13\n\n: ERB::Util.html_escape [lib] [compat]\n: ERB::Util.url_encode [lib] [compat]\n\n  モジュール関数としても使えるようになりました。((<ruby-dev:25687>))\n\n=== 2005-02-12\n\n: open-uri [lib] [new]\n  https をサポートするようになりました。\n\n=== 2005-02-11\n\n: URI::HTTP#proxy_open [lib][new]\n\n  (({:http_basic_authentication})) オプションの追加\n  ((<ruby-core:4416>))\n\n: OpenSSL::X509::Store#set_default_paths [lib][new]\n\n  追加 ((<ruby-dev:25670>))\n\n=== 2005-02-06\n: Resolv::DNS::Resource::TXT#strings [lib] [new]\n: Resolv::DNS::Message::MessageEncoder#put_string_list [lib] [new]\n: Resolv::DNS::Message::MessageDecoder#get_string_list [lib] [new]\n  追加。((<ruby-talk:129732>))\n\n=== 2005-02-04\n\n: RSS Parser/Maker [lib] [new]\n\n  ((<Imageモジュール|URL:http://web.resource.org/rss/1.0/modules/image/>))のサポート\n\n=== 2005-02-03\n\n: RSS::Element#convert(value) [lib] [new]\n   valueのエンコーディングを変換するメソッドを公開。\n   \n   valueのエンコーディングは要素の内部エンコーディングからoutput_encoding=で設定したエンコーディングへ変換されます。\n\n: StringIO [lib] [compat]\n  close, close_read, close_write が ((<IO>)) と同じように、\n  nil を返すようになりました。((<ruby-dev:25623>))\n\n=== 2005-01-29\n\n: Resolv::DNS::Resource::IN::SRV [lib] [new]\n\n  追加\n  (RFC2782)\n\n=== 2005-01-26\n: File#flock [ruby] [bug]\n  Windows 上での File#flock(File::LOCK_UN) が正しく理解されないバグが\n  修正されました。((<ruby-dev:25574>)) \n\n=== 2005-01-25\n: RUBYOPT [ruby] [bug]\n  環境変数 RUBYOPT の -T オプションを適切に解釈するようになりました。\n  またハイフン - を省略できるようになりました。((<ruby-dev:25512>))\n\n    $ env RUBYOPT='Ke rnet/http' ruby  -e 'p Net::HTTP'  \n    Net::HTTP\n\n=== 2005-01-17\n: WEBrick::Config::SSL [lib] [compat]\n  オプション :SSLEnable のデフォルトが false になりました。\n\n: WEBrick::HTTPUtils#escape_path [lib] [new]\n\n=== 2005-01-15\n\n: RSS::VERSION [lib]\n\n  0.1.2 -> 0.1.3\n\n: RSS::Parser [lib] [bug]\n\n  継承するとエラーになるバグを修正。 ((<ruby-talk:126104>))\n\n=== 2005-01-12\n: Class#superclass [ruby] [bug]\n  特異クラスのメソッド superclass が特異クラスを返すように修正されました。\n  ((<ruby-list:40519>))\n\n=== 2005-01-09\n\n: IO#read [obsolete]\n: IO#readpartial [new]\n\n  nonblocking IO に対する IO#read の挙動は ruby 1.9 以降で変化します ((<ruby-dev:25101>))。そのため、\n  ruby 1.8.3 以降では、VERBOSE モードの時に IO#read がノンブロッキングモードで\n  データの読み込みに失敗して ((<Errno::EAGAIN|Errno::EXXX>)) エラーが発生した場合、\n  \"nonblocking IO#read is obsolete\" という警告が出るようになりました。\n  そして ruby 1.8 の nonblocking IO#read の移行先として\n  ruby 1.8.3 に IO#((<IO/readpartial>)) が追加されました。\n  ((<ruby-dev:25430>)) ((<ruby-dev:25443>))\n\n    $ ruby -e 'sleep 1; print \"hoge\"' | ruby-1.8.2 -rio/nonblock -we '\n                                          io = IO.open(0)\n                                          io.nonblock = true\n                                          p io.read(4)'\n    -e:4:in `read': Resource temporarily unavailable (Errno::EAGAIN)\n            from -e:4\n    \n    $ ruby -e 'sleep 1; print \"hoge\"' | ruby-1.8.3 -rio/nonblock -we '\n                                          io = IO.open(0)\n                                          io.nonblock = true\n                                          p io.read(4)'\n    -e:4: warning: nonblocking IO#read is obsolete; use IO#readpartial or IO#sysread\n    -e:4:in `read': Resource temporarily unavailable (Errno::EAGAIN)\n            from -e:4\n    \n    $ ruby -e 'sleep 1; print \"hoge\"' | ruby-1.8.3 -rio/nonblock -we '\n                                          io = IO.open(0)\n                                          io.nonblock = true\n                                          p io.readpartial(4)'\n    \"hoge\"\n\n    $ ruby -e 'sleep 1; print \"hoge\"' | ruby-1.9 -rio/nonblock -we '\n                                          io = IO.open(0)\n                                          io.nonblock = true\n                                          p io.read(4)'\n    \"hoge\"\n\n=== 2005-01-05\n\n: srand(bignum) [compat]\n\n  srand が引数として unsigned long よりも大きな値も受け付けるようになりました。\n\n: rand(bignum)  [bug]\n\n  負の ((<Bignum>)) を受け取っても 正の ((<Bignum>)) を返すようになりました。\n\n=== 2005-01-03\n\n: srand [compat]\n\n  引数を与えない場合、可能なら /dev/urandom を参照するようになりました。((<ruby-dev:25392>))",
          "snippets": []
        }
      ],
      "related_entries": []
    },
    {
      "signature": "スレッド",
      "score": 73.0,
      "metadata": {
        "type": "document",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッド \nスレッドとはメモリ空間を共有して同時に実行される制御の流れです。\nRuby ではスレッドはThread クラスのインスタンスとして表されます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/doc/spec=2fthread.html",
          "description": "スレッド \nスレッドとはメモリ空間を共有して同時に実行される制御の流れです。\nRuby ではスレッドはThread クラスのインスタンスとして表されます。\n\n\n=== 実装\nネイティブスレッドを用いて実装されていますが、\n現在の実装では Ruby VM は Giant VM lock (GVL) を有しており、同時に実行される\nネイティブスレッドは常にひとつです。\nただし、IO 関連のブロックする可能性があるシステムコールを行う場合には\nGVL を解放します。その場合にはスレッドは同時に実行され得ます。\nまた拡張ライブラリから GVL を操作できるので、複数のスレッドを\n同時に実行するような拡張ライブラリは作成可能です。\n\n=== スケジューリング\nRuby のスレッドスケジューリングはネイティブスレッドのそれを利用しています。\nよって詳細はプラットフォームに依存します。\n\n=== メインスレッド\n\nプログラムの開始と同時に生成されるスレッドを「メインスレッド」と呼\nびます。なんらかの理由でメインスレッドが終了する時には、他の全てのスレッ\nドもプログラム全体も終了します。ユーザからの割込みによって発生した例外\nはメインスレッドに送られます。\n\n=== スレッドの終了\n\nスレッドの起動時に指定したブロックの実行が終了するとスレッドの実行も終\n了します。ブロックの終了は正常な終了も例外などによる異常終了も含みます。\n\n===[a:exception] 例外発生時のスレッドの振る舞い\n\nあるスレッドで例外が発生し、そのスレッド内で rescue で捕捉されなかっ\nた場合、通常はそのスレッドだけがなにも警告なしに終了されます。ただ\nしその例外で終了するスレッドを Thread#join で待っている他の\nスレッドがある場合、その待っているスレッドに対して、同じ例外が再度\n発生します。\n\n  begin\n    t = Thread.new do\n      Thread.pass    # メインスレッドが確実にjoinするように\n      raise \"unhandled exception\"\n    end\n    t.join\n  rescue\n    p $!  # => \"unhandled exception\"\n  end\n\nまた、以下の 3 つの方法により、いずれかのスレッドが例外によって終\n了した時に、インタプリタ全体を中断させるように指定することができま\nす。\n\n  * 組み込み変数 $DEBUG を真に設定する(デバッグモード)\n    ruby インタプリタを -d オプション 付きで起動した場合も同様。\n    (オプションの詳細に関してはspec/rubycmd を参照)\n  * Thread.abort_on_exception でフラグを設定する。\n  * Thread#abort_on_exception で指定\n    したスレッドのフラグを設定する。\n\n上記3つのいずれかが設定されていた場合、インタプリタ全体が中断されます。\n\n=== スレッド終了時の ensure 節の実行\n\nスレッド終了時には ensure 節が実行されます。\nこれはスレッドが正常に終了する時はもちろんですが、他のスレッドから Thread#kill\nなどによって終了させられた時も同様に実行されます。\n\nメインスレッドの終了時の詳細に関しては spec/terminate を参照して下さい。\n\n=== スレッドの状態\n\n個々のスレッドは、以下の実行状態を持ちます。これらの状態は\nObject#inspect や\nThread#status によって見ることができます。\n\n p Thread.new {sleep 1} # => #<Thread:0xa039de0 sleep>\n\n: run (実行or実行可能状態)\n 生成されたばかりのスレッドや Thread#run や\n Thread#wakeup で起こされたスレッドはこの状態です。\n Thread#join でスレッドの終了を待っているスレッドもスレッドの\n 終了によりこの状態になります。\n \n この状態のスレッドは「生きて」います。\n\n: sleep (停止状態)\n Thread.stop や Thread#join により停止されたスレッ\n ドはこの状態になります。\n \n この状態のスレッドは「生きて」います。\n\n: aborting (終了処理中)\n Thread#kill 等で終了されるスレッドは一時的にこの状態になりま\n す。この状態から停止状態(sleep)になることもあります。\n \n この状態のスレッドはまだ「生きて」います。\n\n: dead (終了状態)\n Thread#kill 等で終了したスレッドはこの状態になります。この状\n 態のスレッドはどこからも参照されていなければ GC によりメモリ上から\n なくなります。\n \n この状態のスレッドは「死んで」います。\n\n\n=== デッドロックの検出\n@todo",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Thread/"
        },
        {
          "key": "spec/rubycmd",
          "label": "spec/rubycmd",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:spec%2Frubycmd/"
        },
        {
          "key": "spec/terminate",
          "label": "spec/terminate",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:spec%2Fterminate/"
        }
      ]
    },
    {
      "signature": "File::Stat#birthtime -> Time",
      "score": 55.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "作成された時刻を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/File=3a=3aStat/i/birthtime.html",
          "description": "作成された時刻を返します。\n\n@raise NotImplementedError  Windows のような birthtime のない環境で発生します。\n\n//emlist[][ruby]{\nFile.write(\"testfile\", \"foo\")\nsleep 10\nFile.write(\"testfile\", \"bar\")\nsleep 10\nFile.chmod(0644, \"testfile\")\nsleep 10\nFile.read(\"testfile\")\nFile.stat(\"testfile\").birthtime   #=> 2014-02-24 11:19:17 +0900\nFile.stat(\"testfile\").mtime       #=> 2014-02-24 11:19:27 +0900\nFile.stat(\"testfile\").ctime       #=> 2014-02-24 11:19:37 +0900\nFile.stat(\"testfile\").atime       #=> 2014-02-24 11:19:47 +0900\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "File::Stat",
          "label": "File::Stat",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:File%3A%3AStat/"
        }
      ]
    },
    {
      "signature": "NEWS for Ruby 2.0.0",
      "score": 55.0,
      "metadata": {
        "type": "document",
        "versions": [
          "3.3"
        ]
      },
      "summary": "NEWS for Ruby 2.0.0 \nこのドキュメントは前回リリース以降のバグ修正を除くユーザーに影響のある機能の変更のリストです。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/doc/news=2f2_0_0.html",
          "description": "NEWS for Ruby 2.0.0 \nこのドキュメントは前回リリース以降のバグ修正を除くユーザーに影響のある機能の変更のリストです。\n\nそれぞれのエントリーは参照情報があるため短いです。\n十分な情報と共に書かれた全ての変更のリストは ChangeLog ファイルか bugs.ruby-lang.org の issue を参照してください。\n\n== 1.9.3 以降の変更\n\n=== 言語仕様の変更\n\n  * キーワード引数を追加しました\n  * %i, %I をシンボルの配列作成のために追加しました。(%w, %W に似ています)\n  * デフォルトのソースエンコーディングを US-ASCII から UTF-8 に変更しました\n  * '_' で始まる使用されていない変数は警告しなくなりました\n\n=== 組み込みクラスの更新\n\n  * ARGF.class\n    * 追加: ARGF.class#codepoints, ARGF.class#each_codepoint\n      IO にある同名のメソッドに対応します\n\n  * Array\n    * 追加: Array#bsearch 二分探索します\n    * 非互換:\n      * Array#shuffle! と Array#sample の random パラメータには最大値のみを指定することが可能になりました\n      * Array#values_at に Range オブジェクトを与えた場合、配列の範囲外のインデックスについては nil を返します\n\n  * Enumerable\n    * 追加: Enumerable#lazy 遅延列挙のためのメソッドです\n\n  * Enumerator\n    * 追加: Enumerator#size サイズを遅延評価するためのメソッドです\n    * 拡張: Enumerator.new サイズの遅延評価のための引数を一つ受け取るようになりました\n    * 新規クラス: Enumerator::Lazy 遅延列挙用のクラス\n\n  * ENV\n    * ENV.to_h は ENV.to_hash へのエイリアスです\n\n  * Fiber\n    * 非互換: Fiber#resume は Fiber#transfer を呼び出したファイバーを再開できなくなりました\n\n  * File\n    * 拡張: File.fnmatch? は File::FNM_EXTGLOB(File::Constants::FNM_EXTGLOB) オプションが与えられていればブレースを展開します\n        \n  * GC\n    * 改良:\n      * ビットマップマーキングを導入しました。Copy-on-Write を使用してページをコピーするのでメモリ使用量が減少します\n      * 非再帰的なマーキングを導入しました。期待しないスタックオーバーフローを避けるためです\n\n  * GC::Profiler\n    * 追加: GC::Profiler.raw_data GCの加工していないプロファイルデータを返します\n\n  * Hash\n    * 追加: Hash#to_h 明示的に変換するメソッドです。Array#to_a に似ています\n    * 拡張: Hash#default_proc= default proc をクリアするために nil を渡せるようになりました\n\n  * IO\n    * 非推奨: IO#lines, #bytes, #chars, #codepoints\n\n  * Kernel\n    * 追加: Kernel.#Hash という変換メソッド。Kernel.#Array, Kernel.#Float に似ています\n    * 追加: Kernel.#__dir__ 現在のソースファイル(__FILE__)のあるディレクトリ名を正規化された絶対パ スで返します。\n    * 追加: Kernel.#caller_locations フレーム情報の配列を返します\n    * 拡張: Kernel.#warn Kernel.#puts のように複数の引数を受け付けるようになりました\n    * 拡張: Kernel.#caller 第2引数で取得するスタックのサイズを指定できるようになりました\n    * 拡張: Object#to_enum Object#enum_for サイズの遅延評価のためにブロックを受け取るようになりました\n    * 非互換: Kernel.#system, Kernel.#exec は非標準のファイルディスクリプタを閉じます\n      :close_others オプションのデフォルト値を true に変更しました\n    * 非互換: respond_to? は protected なメソッドに対して false を返します。第2引数に true を指定すると true を返します。\n    * 非互換: Kernel.#__callee__ はオリジナルの振舞いに戻りました。定義したときの名前ではなく呼び出したときの名前を返します。\n    * 非互換: Object#inspect は #to_s を呼び出さなくなりました。再定義された #to_s を呼び出すためです。\n\n  * LoadError\n    * 追加: LoadError#path ロードできなかったファイルのパスを返します\n\n  * Module\n    * 追加: Module#prepend 指定したモジュールを self の継承チェインの先頭に\n      「追加する」ことで self の定数、メソッド、モジュール変数を「上書き」します。 \n    * 追加: Module.prepended, Module.prepend_features は Module.included と Module.append_features に似ています\n    * 追加(実験的): Module#refine, スコープを限定してクラスやモジュールを拡張します。\n    * 拡張: Module#define_method は UnboundMethod を受け付けるようになりました\n    * 拡張: Module#const_get 修飾された定数名の文字列を受け付けるようになりました。\n//emlist{\n        Object.const_get(\"Foo::Bar::Baz\")\n//}\n\n  * Mutex\n    * 追加(実験的): Mutex#owned? mutex が現在のスレッドに所持されているかどうかを返します\n    * 非互換: \n      * Mutex#lock, Mutex#unlock, Mutex#try_lock, Mutex#synchronize, Mutex#sleep\n        はトラップハンドラの中では使えなくなりました。そのようなときは ThreadError が発生します\n      * Mutex#sleep may spurious wakeup. Check after wakeup.\n\n  * NilClass\n    * 追加: NilClass#to_h 空のハッシュを返します\n\n  * ObjectSpace::WeakMap\n    * 弱い参照を保持するための低レベルのクラスです。\n\n  * Proc\n    * 非互換: Proc#== と #eql? を削除。\n\n  * Process\n    * 追加: Process#getsid  session id を取得します(unix のみ)。\n\n  * Range\n    * 追加: Range#size サイズの遅延評価\n    * 追加: Range#bsearch 二分探索\n\n  * RubyVM (MRI specific)\n    * 追加: RubyVM::InstructionSequence.of to get the instruction sequence\n      from a method or a block.\n    * 追加: RubyVM::InstructionSequence#path,\n      RubyVM::InstructionSequence#absolute_path,\n      RubyVM::InstructionSequence#label,\n      RubyVM::InstructionSequence#base_label,\n      RubyVM::InstructionSequence#first_lineno to retrieve information from where\n      the instruction sequence was defined.\n    * スタックの使用量を指定するための環境変数を追加(起動時にチェックします):\n      * RUBY_THREAD_VM_STACK_SIZE: vm stack size used at thread creation.\n        default: 128KB (32bit CPU) or 256KB (64bit CPU).\n      * RUBY_THREAD_MACHINE_STACK_SIZE: machine stack size used at thread\n        creation. default: 512KB or 1024KB.\n      * RUBY_FIBER_VM_STACK_SIZE: vm stack size used at fiber creation.\n        default: 64KB or 128KB.\n      * RUBY_FIBER_MACHINE_STACK_SIZE: machine stack size used at fiber\n        creation. default: 256KB or 512KB.\n    * 追加: RubyVM::DEFAULT_PARAMS という定数を追加しました。RubyVM のデフォルトのパラメータを返します。\n\n  * Signal\n    * 追加: Signal.signame シグナルの名前を返します\n   \n    * 非互換: Signal.trap は :SEGV, :BUS, :ILL, :FPE, :VTALRM が指定されると ArgumentError を発生させます\n\n  * String\n    * 追加: String#b エンコーディングを ASCII-8BIT に設定したコピーされた文字列を返します\n    * 返り値変更:\n      * String#lines Enumerator ではなく Array を返します\n      * String#chars Enumerator ではなく Array を返します\n      * String#codepoints Enumerator ではなく Array を返します\n      * String#bytes Enumerator ではなく Array を返します\n\n  * Struct\n    * 追加: Struct#to_h インスタンス変数の名前と値をハッシュのキーと値にしたハッシュを生成して返します\n\n  * Thread\n    * 追加: Thread#thread_variable_get スレッドローカルな変数を取得します\n      (these are different than Fiber local variables).\n    * 追加: Thread#thread_variable_set スレッドローカルな変数をセットします\n    * 追加: Thread#thread_variables スレッドローカルな変数の名前のリストを取得します\n    * 追加: Thread#thread_variable? 与えられた名前がスレッドローカルな変数であるかどうか返します\n    * 追加: Thread.handle_interrupt as well as instance and singleton methods\n      Thread.pending_interrupt? for asynchronous handling of exceptions\n    * 追加: Thread#backtrace_locations Kernel#caller_locations に似た情報を返します\n    * 新規クラス: Thread::Backtrace::Location to hold backtrace location\n      information. These are returned by Thread#backtrace_locations and\n      Kernel#caller_locations\n    * 非互換: Thread#join, Thread#value は対象のスレッドがメインスレッドか現在のスレッドである場合、\n      ThreadError を発生させます\n\n  * Time\n    * 返り値変更:\n      * Time#to_s now returns US-ASCII encoding instead of BINARY.\n\n  * TracePoint\n    * new class. This class is replacement of set_trace_func.\n      Easy to use and efficient implementation.\n\n  * toplevel\n    * added method:\n      * added main.define_method which defines a global function.\n      * added main.using, which imports refinements into the current file or\n        eval string. [experimental]\n\n=== 組み込みクラスの互換性 (機能追加とバグ修正を除く)\n\n  * Array#values_at\n    上を参照\n\n  * String#lines, String#chars, String#codepoints, String#bytes\n    これらのメソッドはもはや Enumerator を返しませんが、ブロックを与えた場合の動作は後方互換性のためまだサポートしています。\n//emlist{\n    str.lines.with_index(1) {|line, lineno| ... } # str.lines が配列を返すのでもう動かない\n    str.each_line.with_index(1) {|line, lineno| ... } # このように each_line に置き換える\n//}\n\n  * IO#lines, IO#chars, IO#codepoints, IO#bytes, ARGF#lines, ARGF#chars,\n    ARGF#bytes, StringIO#lines, StringIO#chars, StringIO#codepoints, StringIO#bytes,\n    Zlib::GzipReader#lines, Zlib::GzipReader#bytes\n    * これらのメソッドは非推奨になりました。each_line, each_byte, each_char, each_codepoint を使ってください。\n\n  * Proc#==, m:Proc#eql?\n    * 削除されました。2つの Proc オブジェクトは同じオブジェクトである場合のみ等しい。\n\n  * Fixnum, Bignum, Float\n    * フリーズされました。\n\n  * Signal.trap\n    * 上を参照\n\n  * Onigmo をマージしました。\n    https://github.com/k-takata/Onigmo\n\n  * The :close_others option is true by default for system() and exec().\n    Also, the close-on-exec flag is set by default for all new file descriptors.\n    This means file descriptors doesn't inherit to spawned process unless\n    explicitly requested such as system(..., fd=>fd).\n\n  * Kernel#respond_to? against a protected method now returns false\n    unless the second argument is true.\n\n  * Object#respond_to_missing?, Object#initialize_clone, Object#initialize_dup\n    * private になりました\n\n  * Thread#join, Thread#value\n    * 上を参照\n\n  * Mutex#lock, Mutex#unlock, Mutex#try_lock, Mutex#synchronize, Mutex#sleep\n    * 上を参照\n\n=== 標準添付ライブラリの更新 (優れたもののみ)\n\n  * cgi\n    * HTML5 用のタグメーカーを追加しました\n    * CGI#header は CGI#http_header に名前を変更しました。CGI#header は別名として残っています。\n    * HTML5 用のタグメーカーを呼び出すと CGI#header を header 要素を生成するために上書きします。\n\n  * csv\n    * CSV.dump と CSV.load を削除しました。ユーザーを危険なシリアライゼーションに関する脆弱性から保護するためです。\n\n  * iconv\n    * 削除しました。String#encode を使ってください。\n\n  * io/console\n    * 追加: IO#cooked which sets the terminal to cooked mode within the given block.\n    * 追加: IO#cooked! which sets the terminal to cooked.\n    * 拡張: IO#raw, IO#raw!, IO#getch キーワード引数 :min, :time を受け付けます。\n\n  * io/wait\n    * 追加: IO#wait_writable\n    * 追加: IO#wait_readable は IO#wait の別名です。\n\n  * json\n    * 1.7.7 に更新\n\n  * net/http\n    * 新機能\n      * Proxies are now automatically detected from the http_proxy environment\n        variable.  See Net::HTTP.new for details.\n      * gzip and deflate compression are now requested for all requests by\n        default.  See Net::HTTP for details.\n      * SSL sessions are now reused across connections for a single instance.\n        This speeds up connection by using a previously negotiated session.\n      * Requests may be created from a URI which sets the request_uri and host\n        header of the request (but does not change the host connected to).\n      * Responses contain the URI requested which allows easier implementation of\n        redirect following.\n    * 追加: Net::HTTP#local_host\n    * 追加: Net::HTTP#local_host=\n    * 追加: Net::HTTP#local_port\n    * 追加: Net::HTTP#local_port=\n    * 拡張: Net::HTTP#connect uses local_host and local_port if specified.\n\n  * net/imap\n    * 追加: Net::IMAP.default_port\n    * 追加: Net::IMAP.default_imap_port\n    * 追加: Net::IMAP.default_tls_port\n    * 追加: Net::IMAP.default_ssl_port\n    * 追加: Net::IMAP.default_imaps_port\n\n  * objspace\n    * 追加: ObjectSpace.#reachable_objects_from\n\n  * openssl\n    * Consistently raise an error when trying to encode nil values. All instances\n      of OpenSSL::ASN1::Primitive now raise TypeError when calling to_der on an\n      instance whose value is nil. All instances of OpenSSL::ASN1::Constructive\n      raise NoMethodError in the same case. Constructing such values is still\n      permitted.\n    * TLS 1.1 & 1.2 support by setting OpenSSL::SSL::SSLContext#ssl_version to\n      :TLSv1_2, :TLSv1_2_server, :TLSv1_2_client or :TLSv1_1, :TLSv1_1_server\n      :TLSv1_1_client. The version being effectively used can be queried\n      with OpenSSL::SSL#ssl_version. Furthermore, it is also possible to\n      blacklist the new TLS versions with OpenSSL::SSL:OP_NO_TLSv1_1 and\n      OpenSSL::SSL::OP_NO_TLSv1_2.\n    * Added OpenSSL::SSL::SSLContext#renegotiation_cb. A user-defined callback\n      may be set which gets called whenever a new handshake is negotiated. This\n      also allows to programmatically decline (client) renegotiation attempts.\n    * Support for \"0/n\" splitting of records as BEAST mitigation via\n      OpenSSL::SSL::OP_DONT_INSERT_EMPTY_FRAGMENTS.\n    * The default options for OpenSSL::SSL::SSLContext have changed to\n      OpenSSL::SSL::OP_ALL & ~OpenSSL::SSL::OP_DONT_INSERT_EMPTY_FRAGMENTS\n      instead of OpenSSL::SSL::OP_ALL only. This enables the countermeasure for\n      the BEAST attack by default.\n    * OpenSSL requires passwords for decrypting PEM-encoded files to be at least\n      four characters long. This led to awkward situations where an export with\n      a password with fewer than four characters was possible, but accessing the\n      file afterwards failed. OpenSSL::PKey::RSA, OpenSSL::PKey::DSA and\n      OpenSSL::PKey::EC therefore now enforce the same check when exporting a\n      private key to PEM with a password - it has to be at least four characters\n      long.\n    * SSL/TLS support for the Next Protocol Negotiation extension. Supported\n      with OpenSSL 1.0.1 and higher.\n    * OpenSSL::OPENSSL_FIPS allows client applications to detect whether OpenSSL\n      is FIPS-enabled. OpenSSL.fips_mode= allows turning on and off FIPS mode\n      manually in order to adapt to situations where FIPS mode would be an\n      explicit requirement.\n    * Authenticated Encryption with Associated Data (AEAD) is supported via\n      Cipher#auth_data= and Cipher#auth_tag/Cipher#auth_tag=.\n      Currently (OpenSSL 1.0.1c), only GCM mode is supported.\n\n  * ostruct\n    * 追加: OpenStruct#[] , OpenStruct#[]=\n    * 追加: OpenStruct#each_pair\n    * 追加: OpenStruct#eql?\n    * 追加: OpenStruct#hash\n    * 追加: OpenStruct#to_h\n    * 拡張: OpenStruct.new OpenStruct/Struct のインスタンスを受け付けるようになりました\n\n  * pathname\n    * 拡張: Pathname#find ブロックを与えない場合 Enumerator を返すようになりました\n\n  * rake\n    * 0.9.5 に更新\n      * This version is backwards-compatible with previous rake versions and\n        contains many bug fixes.\n      * See http://rake.rubyforge.org/doc/release_notes/rake-0_9_5_rdoc.html\n\n  * rdoc\n    * 4.0 に更新\n      * 後方互換性に関する大きな変更がありました。注目すべき最大の変更は ri データベースのフォーマットを変更したことです。\n        (riのデータを再生成する必要があります)\n        その他のAPIの変更は内部的なものなので、ほとんどのユーザーに影響はないでしょう。\n    * 注目すべき変更\n      * riがページをサポートしました。これはGemでも動作します。\n//emlist{\n  # ruby に含まれるページリストを表示する\n  $ ri ruby:\n  # リテラルに関する文法を表示する\n  $ ri ruby:syntax/literals\n  # RSpec の README を表示する\n  $ ri rspec:README\n//}\n    * Markdown をサポートしました。RDoc::Markdown を見てください。\n    * https://github.com/ruby/rdoc/blob/master/History.rdoc\n\n  * resolv\n    * 追加: Resolv::DNS#timeouts=\n    * 追加: Resolv::DNS::Config#timeouts=\n\n  * rexml\n    * REXML::Document#write はハッシュ引数をサポートしました\n    * REXML::Document#write は :encoding オプションをサポートしました。\n      XMLドキュメントのエンコーディングを変更します。:encodingオプションなしの場合、XMLの宣言をXMLドキュメントのエンコーディングとして使います。\n\n  * rubygems\n    * 2.0.0に更新。\n      * RubyGems 2.0.0 は以下の改良を含みます。\n      * Ruby2.0.0以上で導入した default gems のサポートを改良しました\n      * 任意のメタデータを持てるようになりました Gem::Specification#metadata\n      * `gem search` はデフォルトでリモートの gem を探すようになりました\n      * --document オプションを追加して --rdoc, --ri オプションを置き換えました。\n        --no-document オプションを使ってドキュメントの生成を無効化することができます。\n        --document=rdoc を使うと rdoc だけを生成できます。\n      * デフォルトでは ri フォーマットだけを生成します\n      * `gem server` はHTMLを生成するために RDoc::Servlet を使います。\n      * https://github.com/rubygems/rubygems/blob/master/History.txt\n\n  * shellwords\n    * Shellwords#shellescape 与えられたオブジェクトを to_s で文字列化するようになりました\n    * Shellwords#shelljoin 与えられた配列に含まれる文字列でないオブジェクトは to_s で文字列化するようになりました\n\n  * stringio\n    * 非推奨: StringIO#lines, StringIO#bytes, StringIO#chars, StringIO#codepoints\n\n  * syslog\n    * 追加: Syslog::Logger Syslog上に Logger API を提供します\n    * 追加: Syslog::Priority, Syslog::Level, Syslog::Option, Syslog::Macros\n      システムで定義されている定数を簡単に検知するために導入しました。\n\n  * tmpdir\n    * 非互換: Dir.mktmpdir は FileUtils.#remove_entry_secure ではなく FileUtils.#remove_entry を使うようになりました。\n      これはアプリケーションが作成された一時ディレクトリを全ユーザから書き込み可能に変更すべきではないことを意味します。\n\n  * yaml\n    * Syck は削除しました。インストールされている libyaml に依存するようになりました。\n    * libyaml がインストールされていない場合のために libyaml を同梱するようになりました。\n\n  * zlib\n    * Zlib::Inflate, Zlib::Deflate にストリーミングサポートを追加しました。\n      大量のメモリを消費せずに、ストリームを処理できるようになりました。\n    * 展開用に新しい戦略を追加しました。Zlib::RLE, Zlib::FIXED\n    * Zlib のストリームは GVL なしで処理するようになりました。gzip, zlib, deflate のストリームを並列に処理できるようになりました。\n    * 非推奨: Zlib::GzipReader#lines, Zlib::GzipReader#bytes\n\n=== 標準添付ライブラリの互換性 (機能追加とバグ修正を除く)\n\n  * OpenStruct の新しいメソッドはカスタム属性の名前を衝突するかもしれません。\n    \"each_pair\", \"eql?\", \"hash\" or \"to_h\".\n\n  * Dir.mktmpdir は lib/tmpdir.rb にあります。上を参照してください。\n  \n=== C API の更新\n\n  * 追加: NUM2SHORT(), NUM2USHORT()\n    これは NUM2INT に似ています。\n\n  * 追加: rb_newobj_of(), NEWOBJ_OF()\n    与えられたクラスの新しいオブジェクトを作ります",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "ARGF.class",
          "label": "ARGF.class",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:ARGF.class/"
        },
        {
          "key": "ArgumentError",
          "label": "ArgumentError",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:ArgumentError/"
        },
        {
          "key": "Array",
          "label": "Array",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Array/"
        },
        {
          "key": "Bignum",
          "label": "Bignum",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Bignum/"
        },
        {
          "key": "ENV",
          "label": "ENV",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:ENV/"
        },
        {
          "key": "Enumerable",
          "label": "Enumerable",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Enumerable/"
        },
        {
          "key": "Enumerator",
          "label": "Enumerator",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Enumerator/"
        },
        {
          "key": "Enumerator::Lazy",
          "label": "Enumerator::Lazy",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Enumerator%3A%3ALazy/"
        },
        {
          "key": "Fiber",
          "label": "Fiber",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Fiber/"
        },
        {
          "key": "File",
          "label": "File",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:File/"
        },
        {
          "key": "Fixnum",
          "label": "Fixnum",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Fixnum/"
        },
        {
          "key": "Float",
          "label": "Float",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Float/"
        },
        {
          "key": "GC",
          "label": "GC",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:GC/"
        },
        {
          "key": "GC::Profiler",
          "label": "GC::Profiler",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:GC%3A%3AProfiler/"
        },
        {
          "key": "Hash",
          "label": "Hash",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Hash/"
        },
        {
          "key": "IO",
          "label": "IO",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:IO/"
        },
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Kernel/"
        },
        {
          "key": "LoadError",
          "label": "LoadError",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:LoadError/"
        },
        {
          "key": "Module",
          "label": "Module",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Module/"
        },
        {
          "key": "Mutex",
          "label": "Mutex",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Mutex/"
        },
        {
          "key": "NilClass",
          "label": "NilClass",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:NilClass/"
        },
        {
          "key": "ObjectSpace::WeakMap",
          "label": "ObjectSpace::WeakMap",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:ObjectSpace%3A%3AWeakMap/"
        },
        {
          "key": "OpenStruct",
          "label": "OpenStruct",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:OpenStruct/"
        },
        {
          "key": "Proc",
          "label": "Proc",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Proc/"
        },
        {
          "key": "Process",
          "label": "Process",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Process/"
        },
        {
          "key": "RDoc::Markdown",
          "label": "RDoc::Markdown",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:RDoc%3A%3AMarkdown/"
        },
        {
          "key": "RDoc::Servlet",
          "label": "RDoc::Servlet",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:RDoc%3A%3AServlet/"
        },
        {
          "key": "Range",
          "label": "Range",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Range/"
        },
        {
          "key": "RubyVM",
          "label": "RubyVM",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:RubyVM/"
        },
        {
          "key": "Signal",
          "label": "Signal",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Signal/"
        },
        {
          "key": "String",
          "label": "String",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:String/"
        },
        {
          "key": "Struct",
          "label": "Struct",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Struct/"
        },
        {
          "key": "Syslog::Level",
          "label": "Syslog::Level",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Syslog%3A%3ALevel/"
        },
        {
          "key": "Syslog::Logger",
          "label": "Syslog::Logger",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Syslog%3A%3ALogger/"
        },
        {
          "key": "Syslog::Macros",
          "label": "Syslog::Macros",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Syslog%3A%3AMacros/"
        },
        {
          "key": "Syslog::Option",
          "label": "Syslog::Option",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Syslog%3A%3AOption/"
        },
        {
          "key": "Syslog::Priority",
          "label": "Syslog::Priority",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Syslog%3A%3APriority/"
        },
        {
          "key": "Thread",
          "label": "Thread",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Thread/"
        },
        {
          "key": "Thread::Backtrace::Location",
          "label": "Thread::Backtrace::Location",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Thread%3A%3ABacktrace%3A%3ALocation/"
        },
        {
          "key": "ThreadError",
          "label": "ThreadError",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:ThreadError/"
        },
        {
          "key": "Time",
          "label": "Time",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Time/"
        },
        {
          "key": "TracePoint",
          "label": "TracePoint",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:TracePoint/"
        },
        {
          "key": "UnboundMethod",
          "label": "UnboundMethod",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:UnboundMethod/"
        },
        {
          "key": "Zlib::Deflate",
          "label": "Zlib::Deflate",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Zlib%3A%3ADeflate/"
        },
        {
          "key": "Zlib::FIXED",
          "label": "Zlib::FIXED",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Zlib%3A%3AFIXED/"
        },
        {
          "key": "Zlib::Inflate",
          "label": "Zlib::Inflate",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Zlib%3A%3AInflate/"
        },
        {
          "key": "Zlib::RLE",
          "label": "Zlib::RLE",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Zlib%3A%3ARLE/"
        },
        {
          "key": "cgi",
          "label": "cgi",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:cgi/"
        },
        {
          "key": "csv",
          "label": "csv",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:csv/"
        },
        {
          "key": "io/console",
          "label": "io/console",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:io%2Fconsole/"
        },
        {
          "key": "io/wait",
          "label": "io/wait",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:io%2Fwait/"
        },
        {
          "key": "json",
          "label": "json",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:json/"
        },
        {
          "key": "net/http",
          "label": "net/http",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:net%2Fhttp/"
        },
        {
          "key": "net/imap",
          "label": "net/imap",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:net%2Fimap/"
        },
        {
          "key": "objspace",
          "label": "objspace",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:objspace/"
        },
        {
          "key": "openssl",
          "label": "openssl",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:openssl/"
        },
        {
          "key": "ostruct",
          "label": "ostruct",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:ostruct/"
        },
        {
          "key": "pathname",
          "label": "pathname",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:pathname/"
        },
        {
          "key": "rake",
          "label": "rake",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rake/"
        },
        {
          "key": "rdoc",
          "label": "rdoc",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rdoc/"
        },
        {
          "key": "resolv",
          "label": "resolv",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:resolv/"
        },
        {
          "key": "rexml",
          "label": "rexml",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rexml/"
        },
        {
          "key": "rubygems",
          "label": "rubygems",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems/"
        },
        {
          "key": "shellwords",
          "label": "shellwords",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:shellwords/"
        },
        {
          "key": "stringio",
          "label": "stringio",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:stringio/"
        },
        {
          "key": "syslog",
          "label": "syslog",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:syslog/"
        },
        {
          "key": "tmpdir",
          "label": "tmpdir",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:tmpdir/"
        },
        {
          "key": "yaml",
          "label": "yaml",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:yaml/"
        },
        {
          "key": "zlib",
          "label": "zlib",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:zlib/"
        }
      ]
    },
    {
      "signature": "Thread#join -> self",
      "score": 55.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッド self の実行が終了するまで、カレントスレッドを停止し\nます。self が例外により終了していれば、その例外がカレントス\nレッドに対して発生します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/join.html",
          "description": "スレッド self の実行が終了するまで、カレントスレッドを停止し\nます。self が例外により終了していれば、その例外がカレントス\nレッドに対して発生します。\n\nlimit を指定して、limit 秒過ぎても自身が終了しない場合、nil を返します。\n\n@param limit タイムアウトする時間を整数か小数で指定します。単位は秒です。\n\n@raise ThreadError join を実行することによってデッドロックが起きる場合に発生します。またカレントスレッドを join したときにも発生します。\n\n以下は、生成したすべてのスレッドの終了を待つ例です。\n\n   threads = []\n   threads.push(Thread.new { n = rand(5); sleep n; n })\n   threads.push(Thread.new { n = rand(5); sleep n; n })\n   threads.push(Thread.new { n = rand(5); sleep n; n })\n\n   threads.each {|t| t.join}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#join(limit) -> self | nil",
      "score": 55.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッド self の実行が終了するまで、カレントスレッドを停止し\nます。self が例外により終了していれば、その例外がカレントス\nレッドに対して発生します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/join.html",
          "description": "スレッド self の実行が終了するまで、カレントスレッドを停止し\nます。self が例外により終了していれば、その例外がカレントス\nレッドに対して発生します。\n\nlimit を指定して、limit 秒過ぎても自身が終了しない場合、nil を返します。\n\n@param limit タイムアウトする時間を整数か小数で指定します。単位は秒です。\n\n@raise ThreadError join を実行することによってデッドロックが起きる場合に発生します。またカレントスレッドを join したときにも発生します。\n\n以下は、生成したすべてのスレッドの終了を待つ例です。\n\n   threads = []\n   threads.push(Thread.new { n = rand(5); sleep n; n })\n   threads.push(Thread.new { n = rand(5); sleep n; n })\n   threads.push(Thread.new { n = rand(5); sleep n; n })\n\n   threads.each {|t| t.join}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#value -> object",
      "score": 55.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッド self が終了するまで待ち(Thread#join と同じ)、\nそのスレッドのブロックが返した値を返します。スレッド実行中に例外が\n発生した場合には、その例外を再発生させます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/value.html",
          "description": "スレッド self が終了するまで待ち(Thread#join と同じ)、\nそのスレッドのブロックが返した値を返します。スレッド実行中に例外が\n発生した場合には、その例外を再発生させます。\n\nスレッドが Thread#kill によって終了した場合は、返り値は不定です。\n\n以下は、生成したすべてのスレッドの終了を待ち結果を出力する例です。\n\n   threads = []\n   threads.push(Thread.new { n = rand(5); sleep n; n })\n   threads.push(Thread.new { n = rand(5); sleep n; n })\n   threads.push(Thread.new { n = rand(5); sleep n; n })\n\n   threads.each {|t| p t.value}\n\n最後の行で、待ち合わせを行っていることがわかりにくいと思うなら以下\nのように書くこともできます。\n\n   threads.each {|t| p t.join.value}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread.list -> [Thread]",
      "score": 55.0,
      "metadata": {
        "type": "singleton-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "全ての生きているスレッドを含む配列を生成して返します。aborting 状態であるスレッド\nも要素に含まれます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/s/list.html",
          "description": "全ての生きているスレッドを含む配列を生成して返します。aborting 状態であるスレッド\nも要素に含まれます。\n\n  Thread.new do\n    sleep \n  end\n  sleep 0.1\n  \n  p Thread.list   #=> [#<Thread:0x40377a54 sleep>, #<Thread:0x4022e6fc run>]",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "IO#eof -> bool",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "ストリームがファイルの終端に達した場合、true を返します。そうでない場合、false を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/IO/i/eof.html",
          "description": "ストリームがファイルの終端に達した場合、true を返します。そうでない場合、false を返します。\n\n   f = File.new(\"testfile\")\n   dummy = f.readlines\n   f.eof   #=> true\n\n自身がパイプやソケットなどのストリームであった場合、相手がデータを送るか close するまでブロックします。\n\n   r, w = IO.pipe\n   Thread.new { sleep 10; w.close }\n   r.eof?  #=> 10秒ブロックしてから true を返す。\n\n   r, w = IO.pipe\n   Thread.new { sleep 10; w.puts \"a\" }\n   r.eof?  #=> 10秒ブロックしてから false を返す。\n\n   r, w = IO.pipe\n   r.eof?  # 永久にブロックします。\n\neof, eof? は入力バッファにデータを読み込むので、IO#sysread と同時に使うと正常に\n動作しません。\n\n@raise IOError 自身が読み込み用にオープンされていなければ発生します。",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "IO",
          "label": "IO",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:IO/"
        }
      ]
    },
    {
      "signature": "IO#eof? -> bool",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "ストリームがファイルの終端に達した場合、true を返します。そうでない場合、false を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/IO/i/eof.html",
          "description": "ストリームがファイルの終端に達した場合、true を返します。そうでない場合、false を返します。\n\n   f = File.new(\"testfile\")\n   dummy = f.readlines\n   f.eof   #=> true\n\n自身がパイプやソケットなどのストリームであった場合、相手がデータを送るか close するまでブロックします。\n\n   r, w = IO.pipe\n   Thread.new { sleep 10; w.close }\n   r.eof?  #=> 10秒ブロックしてから true を返す。\n\n   r, w = IO.pipe\n   Thread.new { sleep 10; w.puts \"a\" }\n   r.eof?  #=> 10秒ブロックしてから false を返す。\n\n   r, w = IO.pipe\n   r.eof?  # 永久にブロックします。\n\neof, eof? は入力バッファにデータを読み込むので、IO#sysread と同時に使うと正常に\n動作しません。\n\n@raise IOError 自身が読み込み用にオープンされていなければ発生します。",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "IO",
          "label": "IO",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:IO/"
        }
      ]
    },
    {
      "signature": "Kernel.#fork -> Integer | nil",
      "score": 37.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "fork(2) システムコールを使ってプロセスの複製を作\nります。親プロセスでは子プロセスのプロセスIDを、子プロセスでは\nnil を返します。ブロックを指定して呼び出した場合には、生成し\nた子プロセスでブロックを評価します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Kernel/m/fork.html",
          "description": "fork(2) システムコールを使ってプロセスの複製を作\nります。親プロセスでは子プロセスのプロセスIDを、子プロセスでは\nnil を返します。ブロックを指定して呼び出した場合には、生成し\nた子プロセスでブロックを評価します。\n\nfork 前に STDOUT と STDERR を IO#flush します。\n\n@raise NotImplementedError 実行環境がこのメソッドに対応していないとき発生します。\n\n//emlist[ブロックを指定しなかった場合][ruby]{\nif child_pid = fork\n  puts \"parent process. pid: #{Process.pid}, child pid: #{child_pid}\"\n  # => parent process. pid: 81060, child pid: 81329\n\n  # 親プロセスでの処理\n  # ...\n\n  # 子プロセスの終了を待って終了。\n  Process.waitpid(child_pid)\nelse\n  puts \"child process. pid: #{Process.pid}\"\n  # => child process. pid: 81329\n\n  # 子プロセスでの処理\n  sleep(1)\nend\n//}\n\n//emlist[ブロックを指定した場合][ruby]{\nchild_pid = fork do\n  puts \"child process. pid: #{Process.pid}\"\n  # => child process. pid: 79602\n\n  # 子プロセスでの処理\n  sleep(1)\nend\n\nputs \"parent process. pid: #{Process.pid}, child pid: #{child_pid}\"\n# => parent process. pid: 79055, child pid: 79602\n\n# 親プロセスでの処理\n# ...\n\n# 子プロセスの終了を待って終了。\nProcess.waitpid(child_pid)\n//}\n\n\n@see IO.popen,IO.pipe,Kernel.#at_exit,Kernel.#exit!, fork(2)",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Kernel/"
        }
      ]
    },
    {
      "signature": "Kernel.#fork { ... } -> Integer | nil",
      "score": 37.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "fork(2) システムコールを使ってプロセスの複製を作\nります。親プロセスでは子プロセスのプロセスIDを、子プロセスでは\nnil を返します。ブロックを指定して呼び出した場合には、生成し\nた子プロセスでブロックを評価します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Kernel/m/fork.html",
          "description": "fork(2) システムコールを使ってプロセスの複製を作\nります。親プロセスでは子プロセスのプロセスIDを、子プロセスでは\nnil を返します。ブロックを指定して呼び出した場合には、生成し\nた子プロセスでブロックを評価します。\n\nfork 前に STDOUT と STDERR を IO#flush します。\n\n@raise NotImplementedError 実行環境がこのメソッドに対応していないとき発生します。\n\n//emlist[ブロックを指定しなかった場合][ruby]{\nif child_pid = fork\n  puts \"parent process. pid: #{Process.pid}, child pid: #{child_pid}\"\n  # => parent process. pid: 81060, child pid: 81329\n\n  # 親プロセスでの処理\n  # ...\n\n  # 子プロセスの終了を待って終了。\n  Process.waitpid(child_pid)\nelse\n  puts \"child process. pid: #{Process.pid}\"\n  # => child process. pid: 81329\n\n  # 子プロセスでの処理\n  sleep(1)\nend\n//}\n\n//emlist[ブロックを指定した場合][ruby]{\nchild_pid = fork do\n  puts \"child process. pid: #{Process.pid}\"\n  # => child process. pid: 79602\n\n  # 子プロセスでの処理\n  sleep(1)\nend\n\nputs \"parent process. pid: #{Process.pid}, child pid: #{child_pid}\"\n# => parent process. pid: 79055, child pid: 79602\n\n# 親プロセスでの処理\n# ...\n\n# 子プロセスの終了を待って終了。\nProcess.waitpid(child_pid)\n//}\n\n\n@see IO.popen,IO.pipe,Kernel.#at_exit,Kernel.#exit!, fork(2)",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Kernel/"
        }
      ]
    },
    {
      "signature": "NEWS for Ruby 3.0.0",
      "score": 37.0,
      "metadata": {
        "type": "document",
        "versions": [
          "3.3"
        ]
      },
      "summary": "NEWS for Ruby 3.0.0 \nこのドキュメントは前回リリース以降のバグ修正を除くユーザーに影響のある機能の変更のリストです。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/doc/news=2f3_0_0.html",
          "description": "NEWS for Ruby 3.0.0 \nこのドキュメントは前回リリース以降のバグ修正を除くユーザーに影響のある機能の変更のリストです。\n\nそれぞれのエントリーは参照情報があるため短いです。\n十分な情報と共に書かれた全ての変更のリストはリンク先を参照してください。\n\n== 言語仕様の変更\n\n  * Keyword arguments are now separated from positional arguments.\n    Code that resulted in deprecation warnings in Ruby 2.7 will now\n    result in ArgumentError or different behavior. 14183\n  * Procs accepting a single rest argument and keywords are no longer\n    subject to autosplatting.  This now matches the behavior of Procs\n    accepting a single rest argument and no keywords.\n    16166\n\n//emlist[][ruby]{\npr = proc{|*a, **kw| [a, kw]}\n\npr.call([1])\n# 2.7 => [[1], {}]\n# 3.0 => [[[1]], {}]\n\npr.call([1, {a: 1}])\n# 2.7 => [[1], {:a=>1}] # and deprecation warning\n# 3.0 => a=>1}, {}]\n//}\n\n  * Arguments forwarding (`...`) now supports leading arguments.\n    16378\n\n//emlist{\ndef method_missing(meth, ...)\n  send(:\"do_#{meth}\", ...)\nend\n//}\n\n    * Pattern matching (`case/in`) is no longer experimental. 17260\n    * One-line pattern matching is redesigned.  [EXPERIMENTAL]\n        * `=>` is added. It can be used like a rightward assignment.\n          17260\n      * `in` is changed to return `true` or `false`. 17371\n\n//emlist{\n0 => a\np a #=> 0\n\n{b: 0, c: 1} => {b:}\np b #=> 0\n//}\n\n//emlist{\n# version 3.0\n0 in 1 #=> false\n\n# version 2.7\n0 in 1 #=> raise NoMatchingPatternError\n//}\n\n  * Find-pattern is added.  [EXPERIMENTAL]\n    16828\n\n//emlist{\ncase [\"a\", 1, \"b\", \"c\", 2, \"d\", \"e\", \"f\", 3]\nin [*pre, String => x, String => y, *post]\n  p pre  #=> [\"a\", 1]\n  p x    #=> \"b\"\n  p y    #=> \"c\"\n  p post #=> [2, \"d\", \"e\", \"f\", 3]\nend\n//}\n\n  * Endless method definition is added.  [EXPERIMENTAL]\n    16746\n\n//emlist{\ndef square(x) = x * x\n//}\n\n  * Interpolated String literals are no longer frozen when\n    `# frozen-string-literal: true` is used. 17104\n  * Magic comment `shareable_constant_value` added to freeze constants.\n    See {Magic Comments}[rdoc-ref:doc/syntax/comments.rdoc@Magic+Comments] for more details.\n    17273\n  * A {static analysis}[rdoc-label:label-Static+analysis] foundation is\n    introduced.\n      * {RBS}[rdoc-label:label-RBS] is introduced. It is a type definition\n        language for Ruby programs.\n      * {TypeProf}[rdoc-label:label-TypeProf] is experimentally bundled. It is a\n        type analysis tool for Ruby programs.\n  * Deprecation warnings are no longer shown by default (since Ruby 2.7.2).\n    Turn them on with `-W:deprecated` (or with `-w` to show other warnings too).\n    16345\n  * `$SAFE` and `$KCODE` are now normal global variables with no special behavior.\n    C-API methods related to `$SAFE` have been removed.\n    16131 17136\n  * yield in singleton class definitions in methods is now a SyntaxError\n    instead of a warning. yield in a class definition outside of a method\n    is now a SyntaxError instead of a LocalJumpError.  15575\n  * When a class variable is overtaken by the same definition in an\n    ancestor class/module, a RuntimeError is now raised (previously,\n    it only issued a warning in verbose mode).  Additionally, accessing a\n    class variable from the toplevel scope is now a RuntimeError.\n    14541\n  * Assigning to a numbered parameter is now a SyntaxError instead of\n    a warning.\n\n== Command line options\n\n=== `--help` option\n\nWhen the environment variable `RUBY_PAGER` or `PAGER` is present and has\na non-empty value, and the standard input and output are tty, the `--help`\noption shows the help message via the pager designated by the value.\n16754\n\n=== `--backtrace-limit` option\n\nThe `--backtrace-limit` option limits the maximum length of a backtrace.\n8661\n\n== Core classes updates\n\nOutstanding ones only.\n\n  * Array\n    * The following methods now return Array instances instead of subclass instances when called on subclass instances: 6087\n      * Array#drop\n      * Array#drop_while\n      * Array#flatten\n      * Array#slice!\n      * Array#slice / Array#[]\n      * Array#take\n      * Array#take_while\n      * Array#uniq\n      * Array#*\n    * Can be sliced with Enumerator::ArithmeticSequence\n\n//emlist[][ruby]{\ndirty_data = ['--', 'data1', '--', 'data2', '--', 'data3']\ndirty_data[(1..).step(2)] # take each second element\n# => [\"data1\", \"data2\", \"data3\"]\n//}\n\n  * Binding\n    * Binding#eval when called with one argument will use `\"(eval)\"` for `__FILE__` and `1` for `__LINE__` in the evaluated code. 4352 17419\n  * ConditionVariable\n    * ConditionVariable#wait may now invoke the `block`/`unblock` scheduler hooks in a non-blocking context. 16786\n  * Dir\n    * Dir.glob and Dir.[] now sort the results by default, and accept the `sort:` keyword option.  8709\n  * ENV\n    * ENV.except has been added, which returns a hash excluding the given keys and their values.  15822\n    * Windows: Read ENV names and values as UTF-8 encoded Strings 12650\n  * Encoding\n    * Added new encoding IBM720.  16233\n    * Changed default for Encoding.default_external to UTF-8 on Windows 16604\n  * Fiber\n    * Fiber.new(blocking: true/false) allows you to create non-blocking execution contexts. 16786\n    * Fiber#blocking? tells whether the fiber is non-blocking. 16786\n    * Fiber#backtrace and Fiber#backtrace_locations provide per-fiber backtrace. 16815\n    * The limitation of Fiber#transfer is relaxed. 17221\n  * GC\n    * GC.auto_compact= and GC.auto_compact have been added to control when compaction runs.  Setting `auto_compact=` to `true` will cause compaction to occur during major collections.  At the moment, compaction adds significant overhead to major collections, so please test first!  17176\n  * Hash\n    * Hash#transform_keys and Hash#transform_keys! now accept a hash that maps keys to new keys.  16274\n    * Hash#except has been added, which returns a hash excluding the given keys and their values.  15822\n  * IO\n    * IO#nonblock? now defaults to `true`. 16786\n    * IO#wait_readable, IO#wait_writable, IO#read, IO#write and other related methods (e.g. IO#puts, IO#gets) may invoke the scheduler hook `#io_wait(io, events, timeout)` in a non-blocking execution context. 16786\n  * Kernel\n    * Kernel#clone when called with the `freeze: false` keyword will call `#initialize_clone` with the `freeze: false` keyword. 14266\n    * Kernel#clone when called with the `freeze: true` keyword will call `#initialize_clone` with the `freeze: true` keyword, and will return a frozen copy even if the receiver is unfrozen. 16175\n    * Kernel#eval when called with two arguments will use `\"(eval)\"` for `__FILE__` and `1` for `__LINE__` in the evaluated code. 4352\n    * Kernel#lambda now warns if called without a literal block. 15973\n    * Kernel.sleep invokes the scheduler hook `#kernel_sleep(...)` in a non-blocking execution context. 16786\n  * Module\n    * Module#include and Module#prepend now affect classes and modules that have already included or prepended the receiver, mirroring the behavior if the arguments were included in the receiver before the other modules and classes included or prepended the receiver. 9573\n    * Module#public, Module#protected, Module#private, Module#public_class_method, Module#private_class_method, toplevel \"private\" and \"public\" methods now accept single array argument with a list of method names. 17314\n    * Module#attr_accessor, Module#attr_reader, Module#attr_writer and Module#attr methods now return an array of defined method names as symbols. 17314\n    * Module#alias_method now returns the defined alias as a symbol. 17314\n\n//emlist[][ruby]{\nclass C; end\nmodule M1; end\nmodule M2; end\nC.include M1\nM1.include M2\np C.ancestors #=> [C, M1, M2, Object, Kernel, BasicObject]\n//}\n\n  * Mutex\n    * `Mutex` is now acquired per-`Fiber` instead of per-`Thread`. This change should be compatible for essentially all usages and avoids blocking when using a scheduler. 16792\n  * Proc\n    * Proc#== and Proc#eql? are now defined and will return true for separate Proc instances if the procs were created from the same block. 14267\n  * Queue / SizedQueue\n    * Queue#pop, SizedQueue#push and related methods may now invoke the `block`/`unblock` scheduler hooks in a non-blocking context. 16786\n  * Ractor\n    * New class added to enable parallel execution. See rdoc-ref:ractor.md for more details.\n  * Random\n    * `Random::DEFAULT` now refers to the `Random` class instead of being a `Random` instance, so it can work with `Ractor`. 17322\n    * `Random::DEFAULT` is deprecated since its value is now confusing and it is no longer global, use `Kernel.rand`/`Random.rand` directly, or create a `Random` instance with `Random.new` instead. 17351\n  * String\n    * The following methods now return or yield String instances instead of subclass instances when called on subclass instances: 10845\n      * String#*\n      * String#capitalize\n      * String#center\n      * String#chomp\n      * String#chop\n      * String#delete\n      * String#delete_prefix\n      * String#delete_suffix\n      * String#downcase\n      * String#dump\n      * String#each_char\n      * String#each_grapheme_cluster\n      * String#each_line\n      * String#gsub\n      * String#ljust\n      * String#lstrip\n      * String#partition\n      * String#reverse\n      * String#rjust\n      * String#rpartition\n      * String#rstrip\n      * String#scrub\n      * String#slice!\n      * String#slice / String#[]\n      * String#split\n      * String#squeeze\n      * String#strip\n      * String#sub\n      * String#succ / String#next\n      * String#swapcase\n      * String#tr\n      * String#tr_s\n      * String#upcase\n  * Symbol\n    * Symbol#to_proc now returns a lambda Proc.  16260\n    * Symbol#name has been added, which returns the name of the symbol if it is named.  The returned string is frozen.  16150\n  * Fiber\n    * Introduce Fiber.set_scheduler for intercepting blocking operations and Fiber.scheduler for accessing the current scheduler. See rdoc-ref:fiber.md for more details about what operations are supported and how to implement the scheduler hooks. 16786\n    * Fiber.blocking? tells whether the current execution context is blocking. 16786\n    * Thread#join invokes the scheduler hooks `block`/`unblock` in a non-blocking execution context. 16786\n  * Thread\n    * Thread.ignore_deadlock accessor has been added for disabling the default deadlock detection, allowing the use of signal handlers to break deadlock. 13768\n  * Warning\n    * Warning#warn now supports a category keyword argument. 17122\n\n== Stdlib updates\n\nOutstanding ones only.\n\n  * BigDecimal\n    * Update to BigDecimal 3.0.0\n    * This version is Ractor compatible.\n  * Bundler\n    * Update to Bundler 2.2.3\n  * CGI\n    * Update to 0.2.0\n    * This version is Ractor compatible.\n  * CSV\n    * Update to CSV 3.1.9\n  * Date\n    * Update to Date 3.1.1\n    * This version is Ractor compatible.\n  * Digest\n    * Update to Digest 3.0.0\n    * This version is Ractor compatible.\n  * Etc\n    * Update to Etc 1.2.0\n    * This version is Ractor compatible.\n  * Fiddle\n    * Update to Fiddle 1.0.5\n  * IRB\n    * Update to IRB 1.2.6\n  * JSON\n    * Update to JSON 2.5.0\n    * This version is Ractor compatible.\n  * Set\n    * Update to set 1.0.0\n    * SortedSet has been removed for dependency and performance reasons.\n    * Set#join is added as a shorthand for `.to_a.join`.\n    * Set#<=> is added.\n  * Socket\n    * Add :connect_timeout to TCPSocket.new 17187\n  * Net::HTTP\n    * Net::HTTP#verify_hostname= and Net::HTTP#verify_hostname have been added to skip hostname verification.  16555\n    * Net::HTTP.get, Net::HTTP.get_response, and Net::HTTP.get_print can take the request headers as a Hash in the second argument when the first argument is a URI.  16686\n  * Net::SMTP\n    * Add SNI support.\n    * Net::SMTP.start arguments are keyword arguments.\n    * TLS should not check the host name by default.\n  * OpenStruct\n    * Initialization is no longer lazy. 12136\n    * Builtin methods can now be overridden safely. 15409\n    * Implementation uses only methods ending with `!`.\n    * Ractor compatible.\n    * Improved support for YAML. 8382\n    * Use officially discouraged. Read OpenStruct@Caveats section.\n  * Pathname\n    * Ractor compatible.\n  * Psych\n    * Update to Psych 3.3.0\n    * This version is Ractor compatible.\n  * Reline\n    * Update to Reline 0.1.5\n  * RubyGems\n    * Update to RubyGems 3.2.3\n  * StringIO\n    * Update to StringIO 3.0.0\n    * This version is Ractor compatible.\n  * StringScanner\n    * Update to StringScanner 3.0.0\n    * This version is Ractor compatible.\n\n== Compatibility issues\n\nExcluding feature bug fixes.\n\n  * Regexp literals and all Range objects are frozen. 8948 16377 15504\n\n//emlist[][ruby]{\n/foo/.frozen? #=> true\n(42...).frozen? # => true\n//}\n\n  * EXPERIMENTAL: Hash#each consistently yields a 2-element array. 12706\n    * Now `{ a: 1 }.each(&->(k, v) { })` raises an ArgumentError due to lambda's arity check.\n  * When writing to STDOUT redirected to a closed pipe, no broken pipe error message will be shown now.  14413\n  * `TRUE`/`FALSE`/`NIL` constants are no longer defined.\n  * Integer#zero? overrides Numeric#zero? for optimization.  16961\n  * Enumerable#grep and Enumerable#grep_v when passed a Regexp and no block no longer modify Regexp.last_match. 17030\n  * Requiring 'open-uri' no longer redefines `Kernel#open`. Call `URI.open` directly or `use URI#open` instead. 15893\n  * SortedSet has been removed for dependency and performance reasons.\n\n== Stdlib compatibility issues\n\n  * Default gems\n    * The following libraries are promoted to default gems from stdlib.\n      * English\n      * abbrev\n      * base64\n      * drb\n      * debug\n      * erb\n      * find\n      * net-ftp\n      * net-http\n      * net-imap\n      * net-protocol\n      * open-uri\n      * optparse\n      * pp\n      * prettyprint\n      * resolv-replace\n      * resolv\n      * rinda\n      * set\n      * securerandom\n      * shellwords\n      * tempfile\n      * tmpdir\n      * time\n      * tsort\n      * un\n      * weakref\n    * The following extensions are promoted to default gems from stdlib.\n      * digest\n      * io-nonblock\n      * io-wait\n      * nkf\n      * pathname\n      * syslog\n      * win32ole\n  * Bundled gems\n    * net-telnet and xmlrpc have been removed from the bundled gems. If you are interested in maintaining them, please comment on your plan to https://github.com/ruby/xmlrpc or https://github.com/ruby/net-telnet.\n  * SDBM has been removed from the Ruby standard library. 8446\n    * The issues of sdbm will be handled at https://github.com/ruby/sdbm\n  * WEBrick has been removed from the Ruby standard library. 17303\n    * The issues of WEBrick will be handled at https://github.com/ruby/webrick\n\n== C API updates\n\n  * C API functions related to `$SAFE` have been removed. 16131\n  * C API header file `ruby/ruby.h` was split. https://github.com/ruby/ruby/pull/2991 This should have no impact on extension libraries, but users might experience slow compilations.\n  * Memory view interface [EXPERIMENTAL]\n    * The memory view interface is a C-API set to exchange a raw memory area, such as a numeric array or a bitmap image, between extension libraries. The extension libraries can share also the metadata of the memory area that consists of the shape, the element format, and so on. Using these kinds of metadata, the extension libraries can share even a multidimensional array appropriately. This feature is designed by referring to Python's buffer protocol. 13767 14722\n  * Ractor related C APIs are introduced (experimental) in \"include/ruby/ractor.h\".\n\n== Implementation improvements\n\n  * New method cache mechanism for Ractor. 16614\n    * Inline method caches pointed from ISeq can be accessed by multiple Ractors in parallel and synchronization is needed even for method caches. However, such synchronization can be overhead so introducing new inline method cache mechanisms, (1) Disposable inline method cache (2) per-Class method cache and (3) new invalidation mechanism. (1) can avoid per-method call synchronization because it only uses atomic operations. See the ticket for more details.\n  * The number of hashes allocated when using a keyword splat in a method call has been reduced to a maximum of 1, and passing a keyword splat to a method that accepts specific keywords does not allocate a hash.\n  * `super` is optimized when the same type of method is called in the previous call if it's not refinements or an attr reader or writer.\n\n=== JIT\n\n  * Performance improvements of JIT-ed code\n    * Microarchitectural optimizations\n        * Native functions shared by multiple methods are deduplicated on JIT compaction.\n        * Decrease code size of hot paths by some optimizations and partitioning cold paths.\n    * Instance variables\n        * Eliminate some redundant checks.\n        * Skip checking a class and a object multiple times in a method when possible.\n        * Optimize accesses in some core classes like Hash and their subclasses.\n    * Method inlining support for some C methods\n        * `Kernel`: `#class`, `#frozen?`\n        * `Integer`: `#-@`, `#~`, `#abs`, `#bit_length`, `#even?`, `#integer?`, `#magnitude`, `#odd?`, `#ord`, `#to_i`, `#to_int`, `#zero?`\n        * `Struct`: reader methods for 10th or later members\n    * Constant references are inlined.\n    * Always generate appropriate code for `==`, `nil?`, and `!` calls depending on a receiver class.\n    * Reduce the number of PC accesses on branches and method returns.\n    * Optimize C method calls a little.\n  * Compilation process improvements\n    * It does not keep temporary files in /tmp anymore.\n    * Throttle GC and compaction of JIT-ed code.\n    * Avoid GC-ing JIT-ed code when not necessary.\n    * GC-ing JIT-ed code is executed in a background thread.\n    * Reduce the number of locks between Ruby and JIT threads.\n\n== Static analysis\n\n=== RBS\n\n  * RBS is a new language for type definition of Ruby programs. It allows writing types of classes and modules with advanced types including union types, overloading, generics, and _interface types_ for duck typing.\n  * Ruby ships with type definitions for core/stdlib classes.\n  * `rbs` gem is bundled to load and process RBS files.\n\n=== TypeProf\n\n  * TypeProf is a type analysis tool for Ruby code based on abstract interpretation.\n    * It reads non-annotated Ruby code, tries inferring its type signature, and prints the analysis result in RBS format.\n    * Though it supports only a subset of the Ruby language yet, we will continuously improve the coverage of language features, analysis performance, and usability.\n\n//emlist[][ruby]{\n# test.rb\ndef foo(x)\n  if x > 10\n    x.to_s\n  else\n    nil\n  end\nend\n\nfoo(42)\n//}\n\n//emlist{\n$ typeprof test.rb\n# Classes\nclass Object\n  def foo : (Integer) -> String?\nend\n//}\n\n== Miscellaneous changes\n\n  * Methods using `ruby2_keywords` will no longer keep empty keyword splats, those are now removed just as they are for methods not using `ruby2_keywords`.\n  * When an exception is caught in the default handler, the error message and backtrace are printed in order from the innermost. 8661\n  * Accessing an uninitialized instance variable no longer emits a warning in verbose mode. 17055",
          "snippets": [
            " YAML. 8382\n    * Use officially discouraged. Read OpenStruct@Caveats section.\n  * Pathname\n    * Ractor compatible.\n  * Psych\n    * Update to Psych<span class=\"keyword\"> 3.3</span>.0\n    * This version is Ractor compatible.\n  * Reline\n    * Update to Reline 0.1.5\n  * RubyGems\n    * Update to RubyGems 3.2.3\n  * StringIO\n    * U"
          ]
        }
      ],
      "related_entries": []
    },
    {
      "signature": "Thread#backtrace -> [String] | nil",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドの現在のバックトレースを返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/backtrace.html",
          "description": "スレッドの現在のバックトレースを返します。\n\nスレッドがすでに終了している場合は nil を返します。\n\n//emlist[例][ruby]{\nclass C1\n  def m1\n    sleep 5\n  end\n  def m2\n    m1\n  end\nend\n\nth = Thread.new {C1.new.m2; Thread.stop}\nth.backtrace\n# => [\n#      [0] \"(irb):3:in `sleep'\",\n#      [1] \"(irb):3:in `m1'\",\n#      [2] \"(irb):6:in `m2'\",\n#      [3] \"(irb):10:in `block in irb_binding'\"\n#    ]\n\nth.kill\nth.backtrace   # => nil\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#backtrace_locations(range) -> [Thread::Backtrace::Location] | nil",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドの現在のバックトレースを Thread::Backtrace::Location の配\n列で返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/backtrace_locations.html",
          "description": "スレッドの現在のバックトレースを Thread::Backtrace::Location の配\n列で返します。\n\n引数で指定した値が範囲外の場合、スレッドがすでに終了している場合は nil\nを返します。\n\n@param start 開始フレームの位置を数値で指定します。\n\n@param length 取得するフレームの個数を指定します。\n\n@param range 取得したいフレームの範囲を示す Range オブジェクトを指定します。\n\nKernel.#caller_locations と似ていますが、本メソッドは self に限定\nした情報を返します。\n\n//emlist[例][ruby]{\nthread = Thread.new { sleep 1 }\nthread.run\nthread.backtrace_locations # => [\"/path/to/test.rb:1:in `sleep'\", \"/path/to/test.rb:1:in `block in <main>'\"]\n//}\n\n@see Thread::Backtrace::Location",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        },
        {
          "key": "Thread::Backtrace::Location",
          "label": "Thread::Backtrace::Location",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Thread%3A%3ABacktrace%3A%3ALocation/"
        }
      ]
    },
    {
      "signature": "Thread#backtrace_locations(start = 0, length = nil) -> [Thread::Backtrace::Location] | nil",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドの現在のバックトレースを Thread::Backtrace::Location の配\n列で返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/backtrace_locations.html",
          "description": "スレッドの現在のバックトレースを Thread::Backtrace::Location の配\n列で返します。\n\n引数で指定した値が範囲外の場合、スレッドがすでに終了している場合は nil\nを返します。\n\n@param start 開始フレームの位置を数値で指定します。\n\n@param length 取得するフレームの個数を指定します。\n\n@param range 取得したいフレームの範囲を示す Range オブジェクトを指定します。\n\nKernel.#caller_locations と似ていますが、本メソッドは self に限定\nした情報を返します。\n\n//emlist[例][ruby]{\nthread = Thread.new { sleep 1 }\nthread.run\nthread.backtrace_locations # => [\"/path/to/test.rb:1:in `sleep'\", \"/path/to/test.rb:1:in `block in <main>'\"]\n//}\n\n@see Thread::Backtrace::Location",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        },
        {
          "key": "Thread::Backtrace::Location",
          "label": "Thread::Backtrace::Location",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Thread%3A%3ABacktrace%3A%3ALocation/"
        }
      ]
    },
    {
      "signature": "Thread#exit -> self",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドの実行を終了させます。終了時に ensure 節が実行されます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/exit.html",
          "description": "スレッドの実行を終了させます。終了時に ensure 節が実行されます。\n\nただし、スレッドは終了処理中(aborting)にはなりますが、\n直ちに終了するとは限りません。すでに終了している場合は何もしません。このメソッドにより\n終了したスレッドの Thread#value の返り値は不定です。\n自身がメインスレッドであるか最後のスレッドである場合は、プロセスを Kernel.#exit(0) \nにより終了します。\n\nKernel.#exit と違い例外  SystemExit を発生しません。\n\n  th1 = Thread.new do\n    begin\n      sleep 10\n    ensure\n      p \"this will be displayed\"\n    end\n  end\n\n  sleep 0.1\n  th1.kill\n\n  #=> \"this will be displayed\"\n\n@see Kernel.#exit, Kernel.#exit!",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "SystemExit",
          "label": "SystemExit",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:SystemExit/"
        },
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#kill -> self",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドの実行を終了させます。終了時に ensure 節が実行されます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/exit.html",
          "description": "スレッドの実行を終了させます。終了時に ensure 節が実行されます。\n\nただし、スレッドは終了処理中(aborting)にはなりますが、\n直ちに終了するとは限りません。すでに終了している場合は何もしません。このメソッドにより\n終了したスレッドの Thread#value の返り値は不定です。\n自身がメインスレッドであるか最後のスレッドである場合は、プロセスを Kernel.#exit(0) \nにより終了します。\n\nKernel.#exit と違い例外  SystemExit を発生しません。\n\n  th1 = Thread.new do\n    begin\n      sleep 10\n    ensure\n      p \"this will be displayed\"\n    end\n  end\n\n  sleep 0.1\n  th1.kill\n\n  #=> \"this will be displayed\"\n\n@see Kernel.#exit, Kernel.#exit!",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "SystemExit",
          "label": "SystemExit",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:SystemExit/"
        },
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#raise(error_type, message, traceback) -> ()",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "自身が表すスレッドで強制的に例外を発生させます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/raise.html",
          "description": "自身が表すスレッドで強制的に例外を発生させます。\n\n@param error_type Kernel.#raise を参照してください。\n\n@param message Kernel.#raise を参照してください。\n\n@param traceback Kernel.#raise を参照してください。\n\n  Thread.new {\n    sleep 1\n    Thread.main.raise \"foobar\"\n  }\n\n  begin\n    sleep\n  rescue\n    p $!, $@\n  end\n\n  => #<RuntimeError: foobar>\n     [\"-:3\"]",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#run -> self",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "停止状態(stop)のスレッドを再開させます。\nThread#wakeup と異なりすぐにスレッドの切り替え\nを行います。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/run.html",
          "description": "停止状態(stop)のスレッドを再開させます。\nThread#wakeup と異なりすぐにスレッドの切り替え\nを行います。\n\n@raise ThreadError 死んでいるスレッドに対して実行すると発生します。\n\n//emlist[例][ruby]{\na = Thread.new { puts \"a\"; Thread.stop; puts \"c\" }\nsleep 0.1 while a.status!='sleep'\nputs \"Got here\"\na.run\na.join\n# => a\n# => Got here\n# => c\n//}\n\n@see Thread#wakeup, Thread.stop",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#terminate -> self",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドの実行を終了させます。終了時に ensure 節が実行されます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/exit.html",
          "description": "スレッドの実行を終了させます。終了時に ensure 節が実行されます。\n\nただし、スレッドは終了処理中(aborting)にはなりますが、\n直ちに終了するとは限りません。すでに終了している場合は何もしません。このメソッドにより\n終了したスレッドの Thread#value の返り値は不定です。\n自身がメインスレッドであるか最後のスレッドである場合は、プロセスを Kernel.#exit(0) \nにより終了します。\n\nKernel.#exit と違い例外  SystemExit を発生しません。\n\n  th1 = Thread.new do\n    begin\n      sleep 10\n    ensure\n      p \"this will be displayed\"\n    end\n  end\n\n  sleep 0.1\n  th1.kill\n\n  #=> \"this will be displayed\"\n\n@see Kernel.#exit, Kernel.#exit!",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "SystemExit",
          "label": "SystemExit",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:SystemExit/"
        },
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#wakeup -> self",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "停止状態(stop)のスレッドを実行可能状態(run)にします。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/wakeup.html",
          "description": "停止状態(stop)のスレッドを実行可能状態(run)にします。\n\n@raise ThreadError 死んでいるスレッドに対して実行すると発生します。\n\n//emlist[例][ruby]{\nc = Thread.new { Thread.stop; puts \"hey!\" }\nsleep 0.1 while c.status!='sleep'\nc.wakeup\nc.join\n# => \"hey!\"\n//}\n\n@see Thread#run, Thread.stop",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread.stop -> nil",
      "score": 37.0,
      "metadata": {
        "type": "singleton-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "他のスレッドから Thread#run メソッドで再起動されるまで、カレ\nントスレッドの実行を停止します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/s/stop.html",
          "description": "他のスレッドから Thread#run メソッドで再起動されるまで、カレ\nントスレッドの実行を停止します。\n\n//emlist[例][ruby]{\na = Thread.new { print \"a\"; Thread.stop; print \"c\" }\nsleep 0.1 while a.status!='sleep'\nprint \"b\"\na.run\na.join\n# => \"abc\"\n//}\n\n@see Thread#run, Thread#wakeup",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "ThreadGroup#add(thread) -> self",
      "score": 37.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッド thread が属するグループを自身に変更します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/ThreadGroup/i/add.html",
          "description": "スレッド thread が属するグループを自身に変更します。\n\n@param thread 自身に加えたいスレッドを指定します。\n\n@raise ThreadError 自身が freeze されているか enclose されている場合に、発生します。また引数 thread が属する ThreadGroup が freeze されているか enclose されている場合にも発生します。\n\n//emlist[例][ruby]{\nputs \"Initial group is #{ThreadGroup::Default.list}\"\n# => Initial group is [#<Thread:0x4a49168 run>]\n\ntg = ThreadGroup.new\nt1 = Thread.new { sleep }\nt2 = Thread.new { sleep }\nputs \"t1 is #{t1}\" # => t1 is #<Thread:0x50bef60>\nputs \"t2 is #{t2}\" # => t2 is #<Thread:0x50beed0>\ntg.add(t1)\nputs \"Initial group now #{ThreadGroup::Default.list}\"\n# => Initial group now [#<Thread:0x3039168 run>, #<Thread:0x50beed0 run>]\nputs \"tg group now #{tg.list}\"\n# => tg group now [#<Thread:0x50bef60 run>]\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "ThreadGroup",
          "label": "ThreadGroup",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:ThreadGroup/"
        }
      ]
    },
    {
      "signature": "rdoc/markdown",
      "score": 37.0,
      "metadata": {
        "type": "library",
        "versions": [
          "3.3"
        ]
      },
      "summary": "Markdown 形式で記述されたドキュメントを rdoc 上で解析するための\nサブライブラリです。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/library/rdoc=2fmarkdown.html",
          "description": "Markdown 形式で記述されたドキュメントを rdoc 上で解析するための\nサブライブラリです。\n\n詳しくは以下を参照してください。\n\n * https://daringfireball.net/projects/markdown/syntax\n\nMarkdown 形式をデフォルトのフォーマットにする場合は、\nlib:rdoc#saved_options を参考に プロジェクトのデフォルトを\n.rdoc_options ファイルで設定してください。\n\n=== 拡張\n\n以降の Markdown の拡張は RDoc のパーサ独自にサポートされているも\nのです。ただし、全てがデフォルトで有効になっている訳ではありません。\n\n==== RDoc\n\nRDoc の Markdown のパーサは以下の無効にできない機能があります。\n\nUnderscores embedded in words are never interpreted as emphasis.  (While the\n[markdown dingus][dingus] emphasizes in-word underscores, neither the\nMarkdown syntax nor MarkdownTest mention this behavior.)\n\nまた URL を記述すると HTML を出力する際に自動でリンクを作成します。URL\nはそのまま表示されます。\n\n==== Break on Newline\n\nRDoc::Markdown#break_on_newline を設定する事で改行を保持した状態\nで出力が行えます。詳しくは以下を参照してください。この拡張はデフォルト\nでは無効になっています。\n\n * Github Flavored Markdown: https://github.github.com/gfm/\n\n==== CSS\n\nRDoc::Markdown#css を設定する事で CSS を記述した場合に出力に含め\nる事ができます。ただし、それを常に RDoc の出力に含める事はできま\nせん。この拡張はデフォルトでは無効になっています。\n\n例:\n\n  <style type=\"text/css\">\n  h1 { font-size: 3em }\n  </style>\n\n==== 定義リスト\n\nRDoc::Markdown#definition_lists を設定する事で定義リストを出力す\nる事ができます。詳しくは以下を参照してください。この拡張はデフォルトで\n有効になっています。\n\n * PHP Markdown Extra syntax: https://michelf.ca/projects/php-markdown/extra/#def-list\n\n例:\n\n  cat\n  :   A small furry mammal that seems to sleep a lot\n\n  ant\n  :   A little insect that is known to enjoy picnics\n\n出力例:\n\n: cat\n  A small furry mammal that seems to sleep a lot\n\n: ant\n  A little insect that is known to enjoy picnics\n\n==== Github\n\nRDoc::Markdown#github を設定する事で Github Flavored Markdown 拡\n張の一部を有効にして出力が行えます。詳しくは以下を参照してください。こ\nの拡張はデフォルトで有効になっています。\n\n * Github Flavored Markdown: https://github.github.com/gfm/\n\n上記の URL のうち以下のものがサポートされます。:\n\n===== Fenced code block\n\nコード周辺を「```」で囲む事で、4 スペースによるインデントの代わりになります。\n\n===== シンタックスハイライト\n\nコードを「``` ruby」と「```」で囲む事でシンタックスハイライトを有効にで\nきます。(現在は Ruby のみがサポートされています)\n\n==== HTML\n\nRDoc::Markdown#html を設定する事で HTML を記述した場合にそのまま\n出力する事ができます。この拡張はデフォルトで有効になっています。\n\n例:\n\n    <table>\n    ...\n    </table>\n\n==== Notes\n\nRDoc::Markdown#notes を設定する事で脚注を出力する事ができます。こ\nの拡張はデフォルトで有効になっています。\n\n例:\n\n    Here is some text[^1] including an inline footnote ^[for short footnotes]\n\n    ...\n\n    [^1]: With the footnote text down at the bottom\n\n\n=== 制限事項\n\n * リンクタイトルは使用されない\n * 脚注は単一の段落にまとめられる\n\n=== 著者\n\nこの Markdown パーサは John MacFarlane が開発した\npeg-markdown(https://github.com/jgm/peg-markdown)を kpeg に移植\nしました。\n\nこれは MIT ライセンスで提供されています。:\n\n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n\nkpeg への移植は Eric Hodel と Evan Phoenix によって行われました。",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "RDoc::Markdown",
          "label": "RDoc::Markdown",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:RDoc%3A%3AMarkdown/"
        },
        {
          "key": "rdoc",
          "label": "rdoc",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rdoc/"
        },
        {
          "key": "rdoc/markdown/entities",
          "label": "rdoc/markdown/entities",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rdoc%2Fmarkdown%2Fentities/"
        },
        {
          "key": "rubygems",
          "label": "rubygems",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems/"
        },
        {
          "key": "rubygems/builder",
          "label": "rubygems/builder",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fbuilder/"
        },
        {
          "key": "rubygems/defaults",
          "label": "rubygems/defaults",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fdefaults/"
        },
        {
          "key": "rubygems/dependency",
          "label": "rubygems/dependency",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fdependency/"
        },
        {
          "key": "rubygems/digest/sha2",
          "label": "rubygems/digest/sha2",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fdigest%2Fsha2/"
        },
        {
          "key": "rubygems/exceptions",
          "label": "rubygems/exceptions",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fexceptions/"
        },
        {
          "key": "rubygems/gem_path_searcher",
          "label": "rubygems/gem_path_searcher",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fgem_path_searcher/"
        },
        {
          "key": "rubygems/platform",
          "label": "rubygems/platform",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fplatform/"
        },
        {
          "key": "rubygems/remote_fetcher",
          "label": "rubygems/remote_fetcher",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fremote_fetcher/"
        },
        {
          "key": "rubygems/requirement",
          "label": "rubygems/requirement",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Frequirement/"
        },
        {
          "key": "rubygems/source_index",
          "label": "rubygems/source_index",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fsource_index/"
        },
        {
          "key": "rubygems/source_info_cache",
          "label": "rubygems/source_info_cache",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fsource_info_cache/"
        },
        {
          "key": "rubygems/source_info_cache_entry",
          "label": "rubygems/source_info_cache_entry",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fsource_info_cache_entry/"
        },
        {
          "key": "rubygems/spec_fetcher",
          "label": "rubygems/spec_fetcher",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fspec_fetcher/"
        },
        {
          "key": "rubygems/specification",
          "label": "rubygems/specification",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fspecification/"
        },
        {
          "key": "rubygems/user_interaction",
          "label": "rubygems/user_interaction",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fuser_interaction/"
        },
        {
          "key": "rubygems/version",
          "label": "rubygems/version",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:rubygems%2Fversion/"
        }
      ]
    },
    {
      "signature": "File::Stat#<=>(o) -> Integer | nil",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "ファイルの最終更新時刻を比較します。self が other よりも\n新しければ正の数を、等しければ 0 を古ければ負の数を返します。\n比較できない場合は nil を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/File=3a=3aStat/i/=3c=3d=3e.html",
          "description": "ファイルの最終更新時刻を比較します。self が other よりも\n新しければ正の数を、等しければ 0 を古ければ負の数を返します。\n比較できない場合は nil を返します。\n\n@param o File::Stat のインスタンスを指定します。\n\n//emlist[][ruby]{\nrequire 'tempfile' # for Tempfile\n\nfp1 = Tempfile.open(\"first\")\nfp1.print \"古い方\\n\"\nsleep(1)\nfp2 = Tempfile.open(\"second\")\nfp2.print \"新しい方\\n\"\n\np File::Stat.new(fp1.path) <=> File::Stat.new(fp2.path) #=> -1\np File::Stat.new(fp2.path) <=> File::Stat.new(fp1.path) #=>  1\np File::Stat.new(fp1.path) <=> fp2.path #=> nil\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "File::Stat",
          "label": "File::Stat",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:File%3A%3AStat/"
        }
      ]
    },
    {
      "signature": "Interrupt",
      "score": 19.0,
      "metadata": {
        "type": "class",
        "versions": [
          "3.3"
        ]
      },
      "summary": "SIGINT シグナルを捕捉していないときに\nSIGINT シグナルを受け取ると発生します。\nSIGINT 以外のシグナルを受信したときに発生する例外については\nSignalException を参照してください。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/class/Interrupt.html",
          "description": "SIGINT シグナルを捕捉していないときに\nSIGINT シグナルを受け取ると発生します。\nSIGINT 以外のシグナルを受信したときに発生する例外については\nSignalException を参照してください。\n\n使用例\n\n  =begin\n  #SIGINTを捕捉したい場合\n  Signal.trap('INT'){\n    print \"\\nINTを捕捉した。\\n\"\n    exit 1\n  }\n  =end\n\n  begin\n    begin\n      print \"z\"\n      $stdout.flush\n      sleep(1)\n    end while true\n  rescue Interrupt\n    print \"!!\\n\"\n    exit 1\n  end",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "SignalException",
          "label": "SignalException",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:SignalException/"
        }
      ]
    },
    {
      "signature": "Observable",
      "score": 19.0,
      "metadata": {
        "type": "module",
        "versions": [
          "3.3"
        ]
      },
      "summary": "Observer パターンを提供するモジュールです。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/class/Observable.html",
          "description": "Observer パターンを提供するモジュールです。\n\nMix-in により Observer パターンを提供します。\n\nObservable モジュールを include したクラスは\nObservable#changed メソッドにより更新フラグを立て、\nObservable#notify_observers が呼び出されると\n更新フラグが立っている場合はオブザーバに通知します\n(オブザーバの update メソッドを呼び出す)。\nObservable#notify_observers の引数は\nそのままオブザーバの update メソッドに渡されます。\n\n=== サンプルコード\n  require \"observer\"\n\n  class Ticker          ### Periodically fetch a stock price.\n    include Observable\n\n    def initialize(symbol)\n      @symbol = symbol\n    end\n\n    def run\n      last_price = nil\n      loop do\n        price = Price.fetch(@symbol)\n        print \"Current price: #{price}\\n\"\n        if price != last_price\n          changed                 # notify observers\n          last_price = price\n          notify_observers(Time.now, price)\n        end\n        sleep 1\n      end\n    end\n  end\n\n  class Price           ### A mock class to fetch a stock price (60 - 140).\n    def self.fetch(symbol)\n      60 + rand(80)\n    end\n  end\n\n  class Warner          ### An abstract observer of Ticker objects.\n    def initialize(ticker, limit)\n      @limit = limit\n      ticker.add_observer(self)\n    end\n  end\n\n  class WarnLow < Warner\n    def update(time, price)       # callback for observer\n      if price < @limit\n        print \"--- #{time.to_s}: Price below #@limit: #{price}\\n\"\n      end\n    end\n  end\n\n  class WarnHigh < Warner\n    def update(time, price)       # callback for observer\n      if price > @limit\n        print \"+++ #{time.to_s}: Price above #@limit: #{price}\\n\"\n      end\n    end\n  end\n\n  ticker = Ticker.new(\"MSFT\")\n  WarnLow.new(ticker, 80)\n  WarnHigh.new(ticker, 120)\n  ticker.run\n\n  # => Current price: 126\n  # => +++ 2017-11-02 12:09:36 +0900: Price above 120: 126\n  # => Current price: 102\n  # => Current price: 87\n  # => Current price: 121",
          "snippets": []
        }
      ],
      "related_entries": []
    },
    {
      "signature": "Open3.#pipeline_start(*cmds) -> [Thread]",
      "score": 19.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "指定したコマンドのリストをパイプで繋いで順番に実行します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Open3/m/pipeline_start.html",
          "description": "指定したコマンドのリストをパイプで繋いで順番に実行します。\n\n@param cmds 実行するコマンドのリストを指定します。それぞれのコマンドは\n            以下のように String か Array で指定します。\n            commandline にはコマンド全体(例. \"nroff -man\")を表す\n            String を指定します。\n            options には Hash で指定します。\n            env には環境変数を Hash で指定します。\n            cmdname にはコマンド名を表す String を指定します。\n            1、2、3 は shell 経由で実行されます。\n\n (1) commandline\n (2) [commandline, options]\n (3) [env, commandline, options]\n (4) [env, cmdname, arg1, arg2, ..., options]\n (5) [env, [cmdname, argv0], arg1, ..., options]\n\n@return ブロックを指定した場合はブロックの最後に評価された値を返します。\n        ブロックを指定しなかった場合は実行したプロセスを待つためのスレッ\n        ドの配列を返します。\n\n例:\n\n  require \"open3\"\n  \n  # xeyesを10秒だけ実行する。\n  Open3.pipeline_start(\"xeyes\") {|ts|\n    sleep 10\n    t = ts[0]\n    Process.kill(\"TERM\", t.pid)\n    p t.value #=> #<Process::Status: pid 911 SIGTERM (signal 15)>\n  }\n\n@see Open3.#popen3",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Open3",
          "label": "Open3",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Open3/"
        }
      ]
    },
    {
      "signature": "Open3.#pipeline_start(*cmds) {|wait_thrs| ... } -> ()",
      "score": 19.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "指定したコマンドのリストをパイプで繋いで順番に実行します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Open3/m/pipeline_start.html",
          "description": "指定したコマンドのリストをパイプで繋いで順番に実行します。\n\n@param cmds 実行するコマンドのリストを指定します。それぞれのコマンドは\n            以下のように String か Array で指定します。\n            commandline にはコマンド全体(例. \"nroff -man\")を表す\n            String を指定します。\n            options には Hash で指定します。\n            env には環境変数を Hash で指定します。\n            cmdname にはコマンド名を表す String を指定します。\n            1、2、3 は shell 経由で実行されます。\n\n (1) commandline\n (2) [commandline, options]\n (3) [env, commandline, options]\n (4) [env, cmdname, arg1, arg2, ..., options]\n (5) [env, [cmdname, argv0], arg1, ..., options]\n\n@return ブロックを指定した場合はブロックの最後に評価された値を返します。\n        ブロックを指定しなかった場合は実行したプロセスを待つためのスレッ\n        ドの配列を返します。\n\n例:\n\n  require \"open3\"\n  \n  # xeyesを10秒だけ実行する。\n  Open3.pipeline_start(\"xeyes\") {|ts|\n    sleep 10\n    t = ts[0]\n    Process.kill(\"TERM\", t.pid)\n    p t.value #=> #<Process::Status: pid 911 SIGTERM (signal 15)>\n  }\n\n@see Open3.#popen3",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Open3",
          "label": "Open3",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Open3/"
        }
      ]
    },
    {
      "signature": "Pathname#ctime -> Time",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "File.ctime(self.to_s) を渡したものと同じです。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Pathname/i/ctime.html",
          "description": "File.ctime(self.to_s) を渡したものと同じです。\n\n//emlist[例][ruby]{\nrequire 'pathname'\n\nIO.write(\"testfile\", \"test\")\npathname = Pathname(\"testfile\")\npathname.ctime # => 2019-01-14 00:39:51 +0900\nsleep 1\npathname.chmod(0755)\npathname.ctime # => 2019-01-14 00:39:52 +0900\n//}\n\n@see File.ctime",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Pathname",
          "label": "Pathname",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Pathname/"
        }
      ]
    },
    {
      "signature": "Process.#detach(pid) -> Thread",
      "score": 19.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "子プロセス pid の終了を監視するスレッドを生成して返します。\n生成したスレッドは子プロセスが終了した後に終了ステータス (Process::Status) を返します。\n指定した子プロセスが存在しなければ即座に nil で終了します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Process/m/detach.html",
          "description": "子プロセス pid の終了を監視するスレッドを生成して返します。\n生成したスレッドは子プロセスが終了した後に終了ステータス (Process::Status) を返します。\n指定した子プロセスが存在しなければ即座に nil で終了します。\n\n@param pid 子スレッドのプロセス ID を整数で指定します。\n\n@raise NotImplementedError メソッドが現在のプラットフォームで実装されていない場合に発生します。\n\n    pid = fork {\n      # child\n      sleep 3\n    }\n\n    p pid # => 7762\n    th = Process.detach(pid)\n    p th.value\n    # => #<Process::Status: pid 7762 exit 0>",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Process",
          "label": "Process",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Process/"
        },
        {
          "key": "Process::Status",
          "label": "Process::Status",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Process%3A%3AStatus/"
        }
      ]
    },
    {
      "signature": "Process.#wait(pid = -1, flags = 0) -> Integer | nil",
      "score": 19.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "pid で指定される特定の子プロセスの終了を待ち、そのプロセスが\n終了した時に pid を返します。\nwait2, waitpid2 は子プロセスの pid と終了ステータスを表す\nProcess::Status オブジェクトの配列を返します。\nノンブロッキングモードで子プロセスがまだ終了していない時には\nnil を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Process/m/wait.html",
          "description": "pid で指定される特定の子プロセスの終了を待ち、そのプロセスが\n終了した時に pid を返します。\nwait2, waitpid2 は子プロセスの pid と終了ステータスを表す\nProcess::Status オブジェクトの配列を返します。\nノンブロッキングモードで子プロセスがまだ終了していない時には\nnil を返します。\n\n$? に終了した子プロセスの Process::Status オブジェクトがセットされます。\n\n@param pid 子プロセスのプロセス ID を整数で指定します。\n       0 以上なら指定されたプロセス ID の子プロセスを待ちます。\n       0 なら呼び出し元のプロセスとプロセスグループ ID が同じ任意の子プロセスを待ちます。\n       -1 (省略時のデフォルト) は任意の子プロセスを待ちます。\n       -1 未満なら pid の絶対値とプロセスグループ ID が同じ任意の子プロセスを待ちます。\n\n@param flags Process モジュールの定数 Process::WNOHANG(ノンブロッキングモード)と\n             Process::WUNTRACED の論理和を指定します。省略したときの値は 0 です。\n             ノンブロッキングモードで子プロセスがまだ終了していない時には\n             nil を返します。waitpid(2) か wait4(2) の実装されていないマシンでは\n             flags はいつも nil または 0 を指定する必要があります。\n\n@raise Errno::ECHILD 子プロセスが存在しない場合に発生します。\n\n//emlist[][ruby]{\npid = fork { sleep 1 }\nProcess.wait2 # => [70024, #<Process::Status: pid 70024 exit 0>]\n//}\n\n@see wait(2), waitpid(2)",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Process",
          "label": "Process",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Process/"
        },
        {
          "key": "Process::Status",
          "label": "Process::Status",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Process%3A%3AStatus/"
        }
      ]
    },
    {
      "signature": "Process.#wait2(pid = -1, flags = 0) -> [Integer, Process::Status] | nil",
      "score": 19.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "pid で指定される特定の子プロセスの終了を待ち、そのプロセスが\n終了した時に pid を返します。\nwait2, waitpid2 は子プロセスの pid と終了ステータスを表す\nProcess::Status オブジェクトの配列を返します。\nノンブロッキングモードで子プロセスがまだ終了していない時には\nnil を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Process/m/wait.html",
          "description": "pid で指定される特定の子プロセスの終了を待ち、そのプロセスが\n終了した時に pid を返します。\nwait2, waitpid2 は子プロセスの pid と終了ステータスを表す\nProcess::Status オブジェクトの配列を返します。\nノンブロッキングモードで子プロセスがまだ終了していない時には\nnil を返します。\n\n$? に終了した子プロセスの Process::Status オブジェクトがセットされます。\n\n@param pid 子プロセスのプロセス ID を整数で指定します。\n       0 以上なら指定されたプロセス ID の子プロセスを待ちます。\n       0 なら呼び出し元のプロセスとプロセスグループ ID が同じ任意の子プロセスを待ちます。\n       -1 (省略時のデフォルト) は任意の子プロセスを待ちます。\n       -1 未満なら pid の絶対値とプロセスグループ ID が同じ任意の子プロセスを待ちます。\n\n@param flags Process モジュールの定数 Process::WNOHANG(ノンブロッキングモード)と\n             Process::WUNTRACED の論理和を指定します。省略したときの値は 0 です。\n             ノンブロッキングモードで子プロセスがまだ終了していない時には\n             nil を返します。waitpid(2) か wait4(2) の実装されていないマシンでは\n             flags はいつも nil または 0 を指定する必要があります。\n\n@raise Errno::ECHILD 子プロセスが存在しない場合に発生します。\n\n//emlist[][ruby]{\npid = fork { sleep 1 }\nProcess.wait2 # => [70024, #<Process::Status: pid 70024 exit 0>]\n//}\n\n@see wait(2), waitpid(2)",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Process",
          "label": "Process",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Process/"
        },
        {
          "key": "Process::Status",
          "label": "Process::Status",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Process%3A%3AStatus/"
        }
      ]
    },
    {
      "signature": "Process.#waitpid(pid = -1, flags = 0) -> Integer | nil",
      "score": 19.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "pid で指定される特定の子プロセスの終了を待ち、そのプロセスが\n終了した時に pid を返します。\nwait2, waitpid2 は子プロセスの pid と終了ステータスを表す\nProcess::Status オブジェクトの配列を返します。\nノンブロッキングモードで子プロセスがまだ終了していない時には\nnil を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Process/m/wait.html",
          "description": "pid で指定される特定の子プロセスの終了を待ち、そのプロセスが\n終了した時に pid を返します。\nwait2, waitpid2 は子プロセスの pid と終了ステータスを表す\nProcess::Status オブジェクトの配列を返します。\nノンブロッキングモードで子プロセスがまだ終了していない時には\nnil を返します。\n\n$? に終了した子プロセスの Process::Status オブジェクトがセットされます。\n\n@param pid 子プロセスのプロセス ID を整数で指定します。\n       0 以上なら指定されたプロセス ID の子プロセスを待ちます。\n       0 なら呼び出し元のプロセスとプロセスグループ ID が同じ任意の子プロセスを待ちます。\n       -1 (省略時のデフォルト) は任意の子プロセスを待ちます。\n       -1 未満なら pid の絶対値とプロセスグループ ID が同じ任意の子プロセスを待ちます。\n\n@param flags Process モジュールの定数 Process::WNOHANG(ノンブロッキングモード)と\n             Process::WUNTRACED の論理和を指定します。省略したときの値は 0 です。\n             ノンブロッキングモードで子プロセスがまだ終了していない時には\n             nil を返します。waitpid(2) か wait4(2) の実装されていないマシンでは\n             flags はいつも nil または 0 を指定する必要があります。\n\n@raise Errno::ECHILD 子プロセスが存在しない場合に発生します。\n\n//emlist[][ruby]{\npid = fork { sleep 1 }\nProcess.wait2 # => [70024, #<Process::Status: pid 70024 exit 0>]\n//}\n\n@see wait(2), waitpid(2)",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Process",
          "label": "Process",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Process/"
        },
        {
          "key": "Process::Status",
          "label": "Process::Status",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Process%3A%3AStatus/"
        }
      ]
    },
    {
      "signature": "Process.#waitpid2(pid = -1, flags = 0) -> [Integer, Process::Status] | nil",
      "score": 19.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "pid で指定される特定の子プロセスの終了を待ち、そのプロセスが\n終了した時に pid を返します。\nwait2, waitpid2 は子プロセスの pid と終了ステータスを表す\nProcess::Status オブジェクトの配列を返します。\nノンブロッキングモードで子プロセスがまだ終了していない時には\nnil を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Process/m/wait.html",
          "description": "pid で指定される特定の子プロセスの終了を待ち、そのプロセスが\n終了した時に pid を返します。\nwait2, waitpid2 は子プロセスの pid と終了ステータスを表す\nProcess::Status オブジェクトの配列を返します。\nノンブロッキングモードで子プロセスがまだ終了していない時には\nnil を返します。\n\n$? に終了した子プロセスの Process::Status オブジェクトがセットされます。\n\n@param pid 子プロセスのプロセス ID を整数で指定します。\n       0 以上なら指定されたプロセス ID の子プロセスを待ちます。\n       0 なら呼び出し元のプロセスとプロセスグループ ID が同じ任意の子プロセスを待ちます。\n       -1 (省略時のデフォルト) は任意の子プロセスを待ちます。\n       -1 未満なら pid の絶対値とプロセスグループ ID が同じ任意の子プロセスを待ちます。\n\n@param flags Process モジュールの定数 Process::WNOHANG(ノンブロッキングモード)と\n             Process::WUNTRACED の論理和を指定します。省略したときの値は 0 です。\n             ノンブロッキングモードで子プロセスがまだ終了していない時には\n             nil を返します。waitpid(2) か wait4(2) の実装されていないマシンでは\n             flags はいつも nil または 0 を指定する必要があります。\n\n@raise Errno::ECHILD 子プロセスが存在しない場合に発生します。\n\n//emlist[][ruby]{\npid = fork { sleep 1 }\nProcess.wait2 # => [70024, #<Process::Status: pid 70024 exit 0>]\n//}\n\n@see wait(2), waitpid(2)",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Process",
          "label": "Process",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Process/"
        },
        {
          "key": "Process::Status",
          "label": "Process::Status",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Process%3A%3AStatus/"
        }
      ]
    },
    {
      "signature": "SignalException#signm -> String",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "self.message のエイリアスです。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/SignalException/i/signm.html",
          "description": "self.message のエイリアスです。\n\n//emlist[例][ruby]{\nbegin\n  Process.kill('HUP', Process.pid)\n  sleep\nrescue SignalException => e\n  puts e.signm  # => SIGHUP\nend\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "SignalException",
          "label": "SignalException",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:SignalException/"
        }
      ]
    },
    {
      "signature": "SignalException#signo -> Integer",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "self のシグナル番号を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/SignalException/i/signo.html",
          "description": "self のシグナル番号を返します。\n\n//emlist[例][ruby]{\np Signal.signame(1) # => \"HUP\"\nbegin\n  Process.kill('HUP', Process.pid)\n  sleep\nrescue SignalException => e\n  p e.signo # => 1\nend\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "SignalException",
          "label": "SignalException",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:SignalException/"
        }
      ]
    },
    {
      "signature": "Thread#abort_on_exception -> bool",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "真の場合、そのスレッドが例外によって終了した時に、インタプリタ\n全体を中断させます。false の場合、あるスレッドで起こった例\n外は、Thread#join などで検出されない限りそのスレッ\nドだけをなにも警告を出さずに終了させます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/abort_on_exception.html",
          "description": "真の場合、そのスレッドが例外によって終了した時に、インタプリタ\n全体を中断させます。false の場合、あるスレッドで起こった例\n外は、Thread#join などで検出されない限りそのスレッ\nドだけをなにも警告を出さずに終了させます。\n\nデフォルトは偽です。c:Thread#exceptionを参照してください。\n\n@param newstate 自身を実行中に例外発生した場合、インタプリタ全体を終了させるかどうかを true か false で指定します。\n\n//emlist[例][ruby]{\nthread = Thread.new { sleep 1 }\nthread.abort_on_exception # => false\nthread.abort_on_exception = true\nthread.abort_on_exception # => true\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#abort_on_exception=(newstate)",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "真の場合、そのスレッドが例外によって終了した時に、インタプリタ\n全体を中断させます。false の場合、あるスレッドで起こった例\n外は、Thread#join などで検出されない限りそのスレッ\nドだけをなにも警告を出さずに終了させます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/abort_on_exception.html",
          "description": "真の場合、そのスレッドが例外によって終了した時に、インタプリタ\n全体を中断させます。false の場合、あるスレッドで起こった例\n外は、Thread#join などで検出されない限りそのスレッ\nドだけをなにも警告を出さずに終了させます。\n\nデフォルトは偽です。c:Thread#exceptionを参照してください。\n\n@param newstate 自身を実行中に例外発生した場合、インタプリタ全体を終了させるかどうかを true か false で指定します。\n\n//emlist[例][ruby]{\nthread = Thread.new { sleep 1 }\nthread.abort_on_exception # => false\nthread.abort_on_exception = true\nthread.abort_on_exception # => true\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#priority -> Integer",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドの優先度を返します。この値が大きいほど優先度が高くなります。\nメインスレッドのデフォルト値は 0 です。新しく生成されたスレッドは親スレッドの\npriority を引き継ぎます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/priority.html",
          "description": "スレッドの優先度を返します。この値が大きいほど優先度が高くなります。\nメインスレッドのデフォルト値は 0 です。新しく生成されたスレッドは親スレッドの\npriority を引き継ぎます。\n\n@param val スレッドの優先度を指定します。プラットフォームに依存します。\n\n//emlist[例][ruby]{\nThread.current.priority   # => 0\n\ncount1 = count2 = 0\na = Thread.new do\n      loop { count1 += 1 }\n    end\na.priority = -1\n\nb = Thread.new do\n      loop { count2 += 1 }\n    end\nb.priority = -2\ncount1 = count2 = 0 # reset\nsleep 1   # => 1\ncount1    # => 13809431\ncount2    # => 11571921\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread#priority=(val)",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドの優先度を返します。この値が大きいほど優先度が高くなります。\nメインスレッドのデフォルト値は 0 です。新しく生成されたスレッドは親スレッドの\npriority を引き継ぎます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread/i/priority.html",
          "description": "スレッドの優先度を返します。この値が大きいほど優先度が高くなります。\nメインスレッドのデフォルト値は 0 です。新しく生成されたスレッドは親スレッドの\npriority を引き継ぎます。\n\n@param val スレッドの優先度を指定します。プラットフォームに依存します。\n\n//emlist[例][ruby]{\nThread.current.priority   # => 0\n\ncount1 = count2 = 0\na = Thread.new do\n      loop { count1 += 1 }\n    end\na.priority = -1\n\nb = Thread.new do\n      loop { count2 += 1 }\n    end\nb.priority = -2\ncount1 = count2 = 0 # reset\nsleep 1   # => 1\ncount1    # => 13809431\ncount2    # => 11571921\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread/"
        }
      ]
    },
    {
      "signature": "Thread::ConditionVariable#broadcast -> self",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "状態変数を待っているスレッドをすべて再開します。再開された\nスレッドは Thread::ConditionVariable#wait\nで指定した mutex のロックを試みます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread=3a=3aConditionVariable/i/broadcast.html",
          "description": "状態変数を待っているスレッドをすべて再開します。再開された\nスレッドは Thread::ConditionVariable#wait\nで指定した mutex のロックを試みます。\n\n@return 常に self を返します。\n\n//emlist[例][ruby]{\nmutex = Mutex.new\ncv = ConditionVariable.new\nflg = true\n\n3.times {\n  Thread.start {\n    mutex.synchronize {\n      puts \"a1\"\n      while (flg)\n        cv.wait(mutex)\n      end\n      puts \"a2\"\n    }\n  }\n}\n\nThread.start {\n  mutex.synchronize {\n    flg = false\n    cv.broadcast\n  }\n}\n\nsleep 1\n\n# => a1\n# => a1\n# => a1\n# => a2\n# => a2\n# => a2\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread::ConditionVariable",
          "label": "Thread::ConditionVariable",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread%3A%3AConditionVariable/"
        }
      ]
    },
    {
      "signature": "Thread::ConditionVariable#signal -> self",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "状態変数を待っているスレッドを1つ再開します。再開された\nスレッドは Thread::ConditionVariable#wait\nで指定した mutex のロックを試みます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread=3a=3aConditionVariable/i/signal.html",
          "description": "状態変数を待っているスレッドを1つ再開します。再開された\nスレッドは Thread::ConditionVariable#wait\nで指定した mutex のロックを試みます。\n\n@return 常に self を返します。\n\n//emlist[例][ruby]{\nmutex = Mutex.new\ncv = ConditionVariable.new\nflg = true\n\n3.times {\n  Thread.start {\n    mutex.synchronize {\n      puts \"a1\"\n      while (flg)\n        cv.wait(mutex)\n      end\n      puts \"a2\"\n    }\n  }\n}\n\nThread.start {\n  mutex.synchronize {\n    flg = false\n    cv.signal\n  }\n}\n\nsleep 1\n\n# => a1\n# => a1\n# => a1\n# => a2\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread::ConditionVariable",
          "label": "Thread::ConditionVariable",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread%3A%3AConditionVariable/"
        }
      ]
    },
    {
      "signature": "Thread::Queue#num_waiting -> Integer",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "キューを待っているスレッドの数を返します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Thread=3a=3aQueue/i/num_waiting.html",
          "description": "キューを待っているスレッドの数を返します。\n\n//emlist[例][ruby]{\nrequire 'thread'\n\nq = SizedQueue.new(1)\nq.push(1)\nt = Thread.new { q.push(2) }\nsleep 0.05 until t.stop?\nq.num_waiting # => 1\n\nq.pop\nt.join\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread::Queue",
          "label": "Thread::Queue",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Thread%3A%3AQueue/"
        }
      ]
    },
    {
      "signature": "ThreadGroup",
      "score": 19.0,
      "metadata": {
        "type": "class",
        "versions": [
          "3.3"
        ]
      },
      "summary": "スレッドグループを表すクラスです。グループに属する Thread をまとめて\n操作することができます。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/class/ThreadGroup.html",
          "description": "スレッドグループを表すクラスです。グループに属する Thread をまとめて\n操作することができます。\n\nThread は必ずいずれかひとつのスレッドグループに属します。\n生成されたばかりの Thread は、生成した Thread のグループを引き継ぎます。\nメインスレッドはデフォルトでは ThreadGroup::Default に属します。\n\n: 例:\n\n生成したすべてのThreadが終了するのを待つ\n\n    5.times {\n       Thread.new { sleep 1; puts \"#{Thread.current} finished\" }\n    }\n    \n    (ThreadGroup::Default.list - [Thread.current]).each {|th| th.join}\n    \n    puts \"all threads finished\"\n\n対象の Thread が Thread を起こす可能性がある場合\n(Thread.exclusive参照)\n\n    Thread.exclusive do\n      (ThreadGroup::Default.list - [Thread.current]).each {|th| th.join}\n    end\n\n=== ThreadGroup#freeze と ThreadGroup#enclose の違い\n\nどちらのメソッドでも ThreadGroup#add によるスレッドの追加ができなくなる点は同じですが、\nThread.new に関して違いがあります。現在のスレッドが属する ThreadGroup が freeze \nされている場合、Thread.new{ ... } はエラーになります。ThreadGroup が enclose されているだけでは、\nThread.new{ ... } はエラーになりません。生成されたスレッドは従来通り 親スレッドの ThreadGroup に属します。",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Thread",
          "label": "Thread",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Thread/"
        }
      ]
    },
    {
      "signature": "ThreadGroup#enclose -> self",
      "score": 19.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "自身への ThreadGroup#add によるスレッドの追加・削除を禁止します。\nenclose された ThreadGroup に追加や削除を行うと例外 ThreadError が発生します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/ThreadGroup/i/enclose.html",
          "description": "自身への ThreadGroup#add によるスレッドの追加・削除を禁止します。\nenclose された ThreadGroup に追加や削除を行うと例外 ThreadError が発生します。\n\nただし、Thread.new によるスレッドの追加は禁止されません。enclose されたスレッドグループ A に\n属するスレッドが新たにスレッドを生成した場合、生成されたスレッドはスレッドグループ A に属します。\n\n追加の例:\n\n  thg = ThreadGroup.new.enclose\n  thg.add Thread.new {}\n\n  => -:2:in `add': can't move to the enclosed thread group (ThreadError)\n\n削除の例:\n\n  thg1 = ThreadGroup.new\n  thg2 = ThreadGroup.new\n\n  th = Thread.new {sleep 1}\n\n  thg1.add th\n  thg1.enclose\n  thg2.add th\n\n  => -:8:in `add': can't move from the enclosed thread group (ThreadError)",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "ThreadError",
          "label": "ThreadError",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:ThreadError/"
        },
        {
          "key": "ThreadGroup",
          "label": "ThreadGroup",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:ThreadGroup/"
        }
      ]
    },
    {
      "signature": "Timeout.#timeout(sec, exception_class = nil) {|i| ... } -> object",
      "score": 19.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "ブロックを sec 秒の期限付きで実行します。\nブロックの実行時間が制限を過ぎたときは例外\nTimeout::Error が発生します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Timeout/m/timeout.html",
          "description": "ブロックを sec 秒の期限付きで実行します。\nブロックの実行時間が制限を過ぎたときは例外\nTimeout::Error が発生します。\n\nexception_class を指定した場合には Timeout::Error の代わりに\nその例外が発生します。\nブロックパラメータ i は sec がはいります。\n\nまた sec が 0 もしくは nil のときは制限時間なしで\nブロックを実行します。\n\n@param sec タイムアウトする時間を秒数で指定します.\n@param exception_class タイムアウトした時、発生させる例外を指定します.\n@param message エラーメッセージを指定します.省略した場合は\n               \"execution expired\" になります.\n\n例 長い計算のタイムアウト\n  require 'timeout'\n\n  def calc_pi(min)\n    loop do\n      x = rand\n      y = rand\n      x**2 + y**2 < 1.0 ?  min[0] += 1 : min[1] += 1\n    end\n  end\n \n  t = 5\n  min = [ 0, 0]\n  begin\n    Timeout.timeout(t){\n      calc_pi(min)\n    }\n  rescue Timeout::Error\n    puts \"timeout\"\n  end\n\n  printf \"%d: pi = %f\\n\", min[0] + min[1], min[0]*4.0/(min[0]+min[1])\n  #例\n  #=> 417519: pi = 3.141443\n\n例 独自の例外を発生させるタイムアウト\n  #!/usr/bin/env ruby\n\n  require 'timeout'\n\n  class MYError < Exception;end\n  begin\n    Timeout.timeout(5, MYError) {\n      sleep(30)\n    }\n  rescue MYError => err\n    puts \"MYError\"\n    puts err\n  end\n\n=== 注意\n\ntimeout による割り込みは Thread によって実現されています。\nC 言語レベルで実装され、\nRuby のスレッドが割り込めない処理に対して timeout は無力です。\nそのようなものは実用レベルでは少ないのですが、\nSocket などは DNSの名前解決に時間がかかった場合割り込めません\n(resolv-replace を使用する必要があります)。\nその処理を Ruby で実装しなおすか C 側で Ruby\nのスレッドを意識してあげる必要があります。\n\n以下の例では、gethostbyname(およそ0.6秒処理に時間がかかっている) が終了した直後((A)の箇所)で TimeoutError 例外があがっています。\n\n例 timeout が割り込めない\n  require 'timeout'\n  require 'socket'\n\n  t = 0.1\n  start = Time.now\n  begin\n    Timeout.timeout(t) {\n      p TCPSocket.gethostbyname(\"www.ruby-lang.org\")\n      # (A)\n    }\n  ensure\n    p Time.now - start\n  end\n  # 実行例\n  => [\"helium.ruby-lang.org\", [], 2, \"210.251.121.214\"]\n     0.689331\n     /usr/local/lib/ruby/1.6/timeout.rb:37: execution expired (TimeoutError)\n           from -:6:in `timeout'\n           from -:6\n  # gethostbyname が0.1秒かからない場合は例外が発生しないので\n  # その場合は、t に小さい数値(0.000001のような)に変える。\n\n\ntimeout による割り込みは Kernel.#system によって呼び出された外部プログラムを\nタイムアウトさせる事はできないので、IO.popen、Kernel.#openを使用するなどの工夫が必要です。\n\n例 外部コマンドのタイムアウト\n  require 'timeout'\n\n  # テスト用のシェルをつくる。\n  File.open(\"loop.sh\", \"w\"){|fp|\n    fp.print <<SHELL_EOT\n  #!/bin/bash\n\n  S=\"scale=10\"\n  M=32767\n\n  trap 'echo \"$S; $m1/($m1+$m2)*4\" | bc ; echo \"count = $((m1+m2))\" ; exit 0' INT\n  m1=0\n  m2=0\n\n  while true\n  do\n    x=\"($RANDOM/$M)\"\n    y=\"($RANDOM/$M)\"\n    c=$(echo \"$S;$x^2+$y^2 < 1.0\" | bc)\n    echo $x $y $c\n    if [ $c -eq 1 ]\n    then\n      let m1++\n    else\n      let m2++\n    fi\n  done\n  SHELL_EOT\n  }\n\n  File.chmod(0755, \"loop.sh\")\n  t = 10 # 10 秒でタイムアウト\n  begin\n    pid = nil\n    com = nil\n    Timeout.timeout(t) {\n      # system だととまらない\n      # system(\"./loop.sh\")\n      com = IO.popen(\"./loop.sh\")\n      pid = com.pid\n      while line = com.gets\n        print line\n      end\n    }\n  rescue Timeout::Error => err\n    puts \"timeout: shell execution.\"\n    Process.kill('SIGINT', pid)\n    printf \"[result]\\t%s\", com.read\n    com.close unless com.nil?\n  end\n\n  #止まっているか確認する。\n  #system(\"ps au\")",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Timeout",
          "label": "Timeout",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Timeout/"
        },
        {
          "key": "Timeout::Error",
          "label": "Timeout::Error",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Timeout%3A%3AError/"
        },
        {
          "key": "resolv-replace",
          "label": "resolv-replace",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:resolv-replace/"
        }
      ]
    },
    {
      "signature": "Timeout.#timeout(sec, exception_class, message) {|i| ... } -> object",
      "score": 19.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "ブロックを sec 秒の期限付きで実行します。\nブロックの実行時間が制限を過ぎたときは例外\nTimeout::Error が発生します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Timeout/m/timeout.html",
          "description": "ブロックを sec 秒の期限付きで実行します。\nブロックの実行時間が制限を過ぎたときは例外\nTimeout::Error が発生します。\n\nexception_class を指定した場合には Timeout::Error の代わりに\nその例外が発生します。\nブロックパラメータ i は sec がはいります。\n\nまた sec が 0 もしくは nil のときは制限時間なしで\nブロックを実行します。\n\n@param sec タイムアウトする時間を秒数で指定します.\n@param exception_class タイムアウトした時、発生させる例外を指定します.\n@param message エラーメッセージを指定します.省略した場合は\n               \"execution expired\" になります.\n\n例 長い計算のタイムアウト\n  require 'timeout'\n\n  def calc_pi(min)\n    loop do\n      x = rand\n      y = rand\n      x**2 + y**2 < 1.0 ?  min[0] += 1 : min[1] += 1\n    end\n  end\n \n  t = 5\n  min = [ 0, 0]\n  begin\n    Timeout.timeout(t){\n      calc_pi(min)\n    }\n  rescue Timeout::Error\n    puts \"timeout\"\n  end\n\n  printf \"%d: pi = %f\\n\", min[0] + min[1], min[0]*4.0/(min[0]+min[1])\n  #例\n  #=> 417519: pi = 3.141443\n\n例 独自の例外を発生させるタイムアウト\n  #!/usr/bin/env ruby\n\n  require 'timeout'\n\n  class MYError < Exception;end\n  begin\n    Timeout.timeout(5, MYError) {\n      sleep(30)\n    }\n  rescue MYError => err\n    puts \"MYError\"\n    puts err\n  end\n\n=== 注意\n\ntimeout による割り込みは Thread によって実現されています。\nC 言語レベルで実装され、\nRuby のスレッドが割り込めない処理に対して timeout は無力です。\nそのようなものは実用レベルでは少ないのですが、\nSocket などは DNSの名前解決に時間がかかった場合割り込めません\n(resolv-replace を使用する必要があります)。\nその処理を Ruby で実装しなおすか C 側で Ruby\nのスレッドを意識してあげる必要があります。\n\n以下の例では、gethostbyname(およそ0.6秒処理に時間がかかっている) が終了した直後((A)の箇所)で TimeoutError 例外があがっています。\n\n例 timeout が割り込めない\n  require 'timeout'\n  require 'socket'\n\n  t = 0.1\n  start = Time.now\n  begin\n    Timeout.timeout(t) {\n      p TCPSocket.gethostbyname(\"www.ruby-lang.org\")\n      # (A)\n    }\n  ensure\n    p Time.now - start\n  end\n  # 実行例\n  => [\"helium.ruby-lang.org\", [], 2, \"210.251.121.214\"]\n     0.689331\n     /usr/local/lib/ruby/1.6/timeout.rb:37: execution expired (TimeoutError)\n           from -:6:in `timeout'\n           from -:6\n  # gethostbyname が0.1秒かからない場合は例外が発生しないので\n  # その場合は、t に小さい数値(0.000001のような)に変える。\n\n\ntimeout による割り込みは Kernel.#system によって呼び出された外部プログラムを\nタイムアウトさせる事はできないので、IO.popen、Kernel.#openを使用するなどの工夫が必要です。\n\n例 外部コマンドのタイムアウト\n  require 'timeout'\n\n  # テスト用のシェルをつくる。\n  File.open(\"loop.sh\", \"w\"){|fp|\n    fp.print <<SHELL_EOT\n  #!/bin/bash\n\n  S=\"scale=10\"\n  M=32767\n\n  trap 'echo \"$S; $m1/($m1+$m2)*4\" | bc ; echo \"count = $((m1+m2))\" ; exit 0' INT\n  m1=0\n  m2=0\n\n  while true\n  do\n    x=\"($RANDOM/$M)\"\n    y=\"($RANDOM/$M)\"\n    c=$(echo \"$S;$x^2+$y^2 < 1.0\" | bc)\n    echo $x $y $c\n    if [ $c -eq 1 ]\n    then\n      let m1++\n    else\n      let m2++\n    fi\n  done\n  SHELL_EOT\n  }\n\n  File.chmod(0755, \"loop.sh\")\n  t = 10 # 10 秒でタイムアウト\n  begin\n    pid = nil\n    com = nil\n    Timeout.timeout(t) {\n      # system だととまらない\n      # system(\"./loop.sh\")\n      com = IO.popen(\"./loop.sh\")\n      pid = com.pid\n      while line = com.gets\n        print line\n      end\n    }\n  rescue Timeout::Error => err\n    puts \"timeout: shell execution.\"\n    Process.kill('SIGINT', pid)\n    printf \"[result]\\t%s\", com.read\n    com.close unless com.nil?\n  end\n\n  #止まっているか確認する。\n  #system(\"ps au\")",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Timeout",
          "label": "Timeout",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Timeout/"
        },
        {
          "key": "Timeout::Error",
          "label": "Timeout::Error",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Timeout%3A%3AError/"
        },
        {
          "key": "resolv-replace",
          "label": "resolv-replace",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:resolv-replace/"
        }
      ]
    },
    {
      "signature": "WIN32OLE_EVENT.message_loop -> ()",
      "score": 19.0,
      "metadata": {
        "type": "singleton-method",
        "versions": [
          "3.3"
        ]
      },
      "summary": "Windowsのメッセージポンプを実行します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/WIN32OLE_EVENT/s/message_loop.html",
          "description": "Windowsのメッセージポンプを実行します。\n\nmessage_loopメソッドは、Windowsメッセージがキューイングされている限りメッ\nセージの読み出しとディスパッチを実行します。\n\nCOMのスレッド間/プロセス間通信はスレッド内で呼び出しをシリアライズする\nためにWindowsメッセージを利用します。このため、ほとんどのイベント処理は\nWindowsメッセージを読み取ってディスパッチすることで通知されます。\n\n  ie = WIN32OLE.new('InternetExplorer.Application.1')\n  event = WIN32OLE_EVENT.new(ie, 'DWebBrowserEvents2')\n  b = false\n  event.on_event('DocumentComplete') do |disp, uri|\n    disp.document.getElementsByTagName('a').each do |e|\n      puts \"#{e.innerHTML}=#{e.href}\"   #=> ダウンロード=http://www.ruby-lang.org/ja/downloads/ など\n    end\n    disp.quit\n    b = true\n  end\n  ie.Navigate2 'http://www.ruby-lang.org/ja/'\n  loop do\n    break if b\n    WIN32OLE_EVENT.message_loop\n  end\n\nなお、メソッド名はloopですが、呼び出し時および既にキューイングされたメッ\nセージの処理中にキューされたメッセージの処理が終わると呼び出し元に制御\nが戻ります。このため、イベント通知までに長い時間がかかる場合はすべての\nイベントを受信するまでループを実行する必要があります。このとき他のスレッ\nドに制御を与える必要があれば、Kernel.#sleepなどを呼び出してくださ\nい。message_loopメソッドの呼び出し中はRubyのスレッドの切り替えは行われ\nません。",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "WIN32OLE_EVENT",
          "label": "WIN32OLE_EVENT",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:WIN32OLE_EVENT/"
        }
      ]
    },
    {
      "signature": "drb/gw",
      "score": 19.0,
      "metadata": {
        "type": "library",
        "versions": [
          "3.3"
        ]
      },
      "summary": "drb 通信を中継するゲートウェイ(DRb::GW)と、\n中継に必要なオブジェクト識別子変換クラス(DRb::GWIdConv)、\nおよび DRb::DRbObject への拡張が含まれています。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/library/drb=2fgw.html",
          "description": "drb 通信を中継するゲートウェイ(DRb::GW)と、\n中継に必要なオブジェクト識別子変換クラス(DRb::GWIdConv)、\nおよび DRb::DRbObject への拡張が含まれています。\n\nこのライブラリを利用することで直接通信することが不可能であるような\n2つのプロセスが中継プロセスを経て drb によりやりとりできるようになります。\n\ndrb による通信とは、オブジェクトをプロセス間でやりとりすること、\nおよびそのメソッドを呼び出すことです。\n中継プロセスが保持している DRb::GW オブジェクトに\nそれ以外のプロセスがオブジェクトを登録したり、登録済みの\nオブジェクトを取り出すことでオブジェクトをやりとりします。\nそしてそのオブジェクトのメソッドを呼び出すことで\n中継プロセスを経由した通信ができます。\n\n\n以下の URL も参照してください。\n * http://www2a.biglobe.ne.jp/~seki/ruby/drbssh.html\n\n=== Example\nこの例は drb/gw.rb に含まれているものです。\n\nfoo.rb\n  require 'drb/drb'\n  \n  class Foo\n    include DRbUndumped\n    def initialize(name, peer=nil)\n      @name = name\n      @peer = peer\n    end\n  \n    def ping(obj)\n      puts \"#{@name}: ping: #{obj.inspect}\"\n      @peer.ping(self) if @peer\n    end\n  end\n\ngw_b.rb\n  require 'drb/drb'\n  require 'drb/gw'\n  require 'drb/unix'\n  \n  DRb.install_id_conv(DRb::GWIdConv.new)\n  \n  front = DRb::GW.new\n  \n  s1 = DRb::DRbServer.new('drbunix:/tmp/gw_b_a', front)\n  s2 = DRb::DRbServer.new('drbunix:/tmp/gw_b_c', front)\n  \n  s1.thread.join\n  s2.thread.join\n\ngw_a.rb\n  require 'drb/unix'\n  require_relative 'foo'\n  \n  obj = Foo.new('a')\n  DRb.start_service(\"drbunix:/tmp/gw_a\", obj)\n  \n  robj = DRbObject.new_with_uri('drbunix:/tmp/gw_b_a')\n  robj[:a] = obj\n  \n  DRb.thread.join\n\ngw_c.rb\n  require 'drb/unix'\n  require_relative 'foo'\n  \n  foo = Foo.new('c', nil)\n  \n  DRb.start_service(\"drbunix:/tmp/gw_c\", nil)\n  \n  robj = DRbObject.new_with_uri(\"drbunix:/tmp/gw_b_c\")\n  \n  puts \"c->b\"\n  a = robj[:a]\n  sleep 2\n  \n  a.ping(foo)\n  \n  DRb.thread.join\n\nこれを、gw_b, gw_a, gw_c の順に起動すると、gw_b を経由して\ngw_a と gw_c が通信します。",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "DRb::GW",
          "label": "DRb::GW",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:DRb%3A%3AGW/"
        },
        {
          "key": "DRb::GWIdConv",
          "label": "DRb::GWIdConv",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:DRb%3A%3AGWIdConv/"
        }
      ]
    },
    {
      "signature": "tsort",
      "score": 19.0,
      "metadata": {
        "type": "library",
        "versions": [
          "3.3"
        ]
      },
      "summary": "tsort はトポロジカルソートと強連結成分に関するモジュールを提供します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/library/tsort.html",
          "description": "tsort はトポロジカルソートと強連結成分に関するモジュールを提供します。\n\n=== Example\n\n//emlist[][ruby]{\nrequire 'tsort'\n\nclass Hash\n  include TSort\n  alias tsort_each_node each_key\n  def tsort_each_child(node, &block)\n    fetch(node).each(&block)\n  end\nend\n\n{1=>[2, 3], 2=>[3], 3=>[], 4=>[]}.tsort\n#=> [3, 2, 1, 4]\n\n{1=>[2], 2=>[3, 4], 3=>[2], 4=>[]}.strongly_connected_components\n#=> [[4], [2, 3], [1]]\n//}\n\n=== より現実的な例\n\n非常に単純な `make' に似たツールは以下のように実装できます。\n\n//emlist[][ruby]{\nrequire 'tsort'\n\nclass Make\n  def initialize\n    @dep = {}\n    @dep.default = []\n  end\n\n  def rule(outputs, inputs=[], &block)\n    triple = [outputs, inputs, block]\n    outputs.each {|f| @dep[f] = [triple]}\n    @dep[triple] = inputs\n  end\n\n  def build(target)\n    each_strongly_connected_component_from(target) {|ns|\n      if ns.length != 1\n        fs = ns.delete_if {|n| Array === n}\n        raise TSort::Cyclic.new(\"cyclic dependencies: #{fs.join ', '}\")\n      end\n      n = ns.first\n      if Array === n\n        outputs, inputs, block = n\n        inputs_time = inputs.map {|f| File.mtime f}.max\n        begin\n          outputs_time = outputs.map {|f| File.mtime f}.min\n        rescue Errno::ENOENT\n          outputs_time = nil\n        end\n        if outputs_time == nil ||\n            inputs_time != nil && outputs_time <= inputs_time\n          sleep 1 if inputs_time != nil && inputs_time.to_i == Time.now.to_i\n          block.call\n        end\n      end\n    }\n  end\n\n  def tsort_each_child(node, &block)\n    @dep[node].each(&block)\n  end\n  include TSort\nend\n\ndef command(arg)\n  print arg, \"\\n\"\n  system arg\nend\n\nm = Make.new\nm.rule(%w[t1]) { command 'date > t1' }\nm.rule(%w[t2]) { command 'date > t2' }\nm.rule(%w[t3]) { command 'date > t3' }\nm.rule(%w[t4], %w[t1 t3]) { command 'cat t1 t3 > t4' }\nm.rule(%w[t5], %w[t4 t2]) { command 'cat t4 t2 > t5' }\nm.build('t5')\n//}\n\n=== Bugs\n\ntsort という名前は正確ではありません。なぜなら\nこのライブラリは Tarjan の強連結成分に関するアルゴリズムを使っているからです。\nとはいえ strongly_connected_components という正確な名前は長過ぎます。\n\n=== References\nR. E. Tarjan,\nDepth First Search and Linear Graph Algorithms,\nSIAM Journal on Computing, Vol. 1, No. 2, pp. 146-160, June 1972.",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "TSort",
          "label": "TSort",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:TSort/"
        },
        {
          "key": "TSort::Cyclic",
          "label": "TSort::Cyclic",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:TSort%3A%3ACyclic/"
        }
      ]
    },
    {
      "signature": "制御構造",
      "score": 19.0,
      "metadata": {
        "type": "document",
        "versions": [
          "3.3"
        ]
      },
      "summary": "制御構造 \n条件分岐:\n    * if\n    * unless\n    * case\n繰り返し:\n    * while\n    * until\n    * for\n    * break\n    * next\n    * redo\n    * retry\n例外処理:\n    * raise\n    * begin\nその他:\n    * return\n    * BEGIN\n    * END",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/doc/spec=2fcontrol.html",
          "description": "制御構造 \n条件分岐:\n    * if\n    * unless\n    * case\n繰り返し:\n    * while\n    * until\n    * for\n    * break\n    * next\n    * redo\n    * retry\n例外処理:\n    * raise\n    * begin\nその他:\n    * return\n    * BEGIN\n    * END\n\nRubyでは(Cなどとは異なり)制御構造は式であって、何らかの値を返すものが\nあります(返さないものもあります。値を返さない式を代入式の右辺に置くと\nsyntax error になります)。\n\nRubyはC言語やPerlから引き継いだ制御構造を持ちますが、\nその他にd:spec/call#blockという\n制御構造の抽象化を援助する機能があります。ブロック付きメソッド呼び出しは\n繰り返しを始めとする制御構造をクラス設計者が定義する事が出来るものです.\n\n=== 条件分岐\n====[a:if] if\n\n//emlist[例][ruby]{\nif age >= 12 then\n  print \"adult fee\\n\"\nelse\n  print \"child fee\\n\"\nend\ngender = if foo.gender == \"male\" then \"male\" else \"female\" end\n//}\n\n文法:\n\n          if 式 [then]\n            式 ...\n          [elsif 式 [then]\n            式 ... ]\n          ...\n          [else\n            式 ... ]\n          end\n\n条件式を評価した結果が真である時、then 以下の式を評価します。\nif の条件式が偽であれば elsif の条件を評価します。\nelsif 節は複数指定でき、全ての if および elsif\nの条件式が偽であったとき else 節があればその式が評価されます。\n\nif 式は、条件が成立した節(あるいは else 節)の最後に評価し\nた式の結果を返します。else 節がなくいずれの条件も成り立たなけれ\nば nil を返します。\n\nRuby では false または nil だけが偽で、それ以外は 0 や空文\n字列も含め全て真です。\n\nRuby では if を繋げるのは elsif であり、else if\n(C のように)でも elif(sh のように)でもないことに注意してください。\n\nまた if の条件式が正規表現のリテラルである時には特別に\n\n//emlist[][ruby]{\n$_ =~ リテラル\n//}\n\nであるかのように評価されます。\n\n==== if 修飾子\n\n//emlist[例][ruby]{\nprint \"debug\\n\" if $DEBUG\n//}\n\n文法:\n\n          式 if 式\n\n右辺の条件が成立する時に、左辺の式を評価してその結果を返します。\n条件が成立しなければ nil を返します。\n\n====[a:unless] unless\n\n//emlist[例][ruby]{\nunless baby?\n  feed_meat\nelse\n  feed_milk\nend\n//}\n\n文法:\n\n          unless 式 [then]\n            式 ...\n          [else\n            式 ... ]\n          end\n\nunless は if と反対で、条件式が偽の時に then 以下の\n式を評価します。unless 式にelsif を指定することはできませ\nん。\n\n==== unless 修飾子\n\n//emlist[例][ruby]{\nprint \"stop\\n\" unless valid(passwd)\n//}\n\n文法:\n\n          式 unless 式\n\n右辺の条件が成立しない時に、左辺の式を評価してその結果を返します。\n条件が成立すれば nil を返します。\n\n====[a:case] case\n\n//emlist[例][ruby]{\ncase $age\nwhen 0 .. 2\n  \"baby\"\nwhen 3 .. 6\n  \"little child\"\nwhen 7 .. 12\n  \"child\"\nwhen 13 .. 18\n  \"youth\"\nelse\n  \"adult\"\nend\n//}\n\n文法:\n\n          case [式]\n          [when 式 [, 式] ...[, `*' 式] [then]\n            式..]..\n          [when `*' 式 [then]\n            式..]..\n          [else\n            式..]\n          end\n\ncase は一つの式に対する一致判定による分岐を行います。\n上から順番に、when の直後の式を評価した結果をレシーバ、\ncase の直後の式を評価した値を引数として === 演算子を呼び出し、\n最初に真を返した when 節の本体を実行します。\n\nどの when 節でも条件が成立しなかった場合は、else 節を実行します。\n\nつまり、\n\n//emlist[][ruby]{\ncase 式0\nwhen 式1, 式2\n  stmt1\nwhen 式3, 式4\n  stmt2\nelse\n  stmt3\nend\n//}\n\nは以下の if 式とほぼ等価です。\n\n//emlist[][ruby]{\n_tmp = 式0\nif 式1 === _tmp or 式2 === _tmp\n  stmt1\nelsif 式3 === _tmp or 式4 === _tmp\n  stmt2\nelse\n  stmt3\nend\n//}\n\nwhen 節の評価順序はこの上記 if 文に書き直した場合と同じです。つまり上\nから順に(そして左から順に) === が評価されます。また「式0」は1回だけ評\n価されます。\n\nwhen 節の最後の式に `*' を前置すればその式は配列展開されます。\n\n//emlist[][ruby]{\nary = [1,2,3]\n\ncase v\nwhen *ary\n # ..\nend\n//}\n\nは、\n\n//emlist[][ruby]{\ncase v\nwhen 1, 2, 3\n # ..\nend\n//}\n\nと等価です。\n\nまた === がどのような条件で真になるかは、各クラスの === メソッ\nドの動作についてのドキュメントを参照して下さい。\n\ncase の「式」を省略した場合、when の条件式が偽でない最初の\n式を評価します。\n\n//emlist[][ruby]{\nfoo = false\nbar = true\nquu = false\n\ncase\nwhen foo then puts 'foo is true'\nwhen bar then puts 'bar is true'\nwhen quu then puts 'quu is true'\nend\n# \"bar is true\"と表示される\n//}\n\ncase は、条件が成立した when 節、(あるいは else 節)\nの最後に評価した式の結果を返します。いずれの条件も成り立たなければ\nnil を返します。\n\n=== 繰り返し\n\n====[a:while] while\n\n//emlist[例][ruby]{\nary = [0,2,4,8,16,32,64,128,256,512,1024]\ni = 0\nwhile i < ary.length\n  print ary[i]\n  i += 1\nend\n//}\n\n文法:\n\n          while 式 [do]\n             ...\n          end\n\n式を評価した値が真の間、本体を繰り返し実行します。\n\nwhile は nil を返します。また、引数を伴った break により\nwhile 式の戻り値をその値にすることもできます。\n\n==== while 修飾子\n\n//emlist[例][ruby]{\nsleep(60) while io_not_ready?\n//}\n\n文法:\n\n          式 while 式\n\n右辺の式を評価した値が真の間、左辺を繰り返し実行します。\n\n左辺の式が begin 節である場合にはそれを最初に一回評価してから繰り返します。\n\n//emlist[例][ruby]{\nsend_request(data)\nbegin\n  res = get_response()\nend while res == 'Continue'\n//}\n\nwhile 修飾した式は nil を返します。\nまた、引数を伴った break により while 修飾した式の戻り値を\nその値にすることもできます。\n\n====[a:until] until\n\n//emlist[例][ruby]{\nuntil f.eof?\n  print f.gets\nend\n//}\n\n文法:\n          until 式 [do]\n             ...\n          end\n\n式を評価した値が真になるまで、本体を繰り返して実行します。\n\nuntil は nil を返します。また、引数を伴った break により\nuntil 式の戻り値をその値にすることもできます。\n\n==== until修飾子\n\n//emlist[例][ruby]{\nprint(f.gets) until f.eof?\n//}\n\n文法:\n          式 until 式\n\n右辺の式を評価した値が真になるまで、左辺を繰り返して実行しま\nす。\n\n左辺の式が begin 節である場合にはそれを最初に一回評価してから繰り返します。\n\n//emlist[例][ruby]{\nsend_request(data)\nbegin\n  res = get_response()\nend until res == 'OK'\n//}\n\nuntil 修飾した式は nil を返します。\nまた、引数を伴った break により until 修飾した式の戻り値をその値にすることもできます。\n\n====[a:for] for\n\n//emlist[例][ruby]{\nfor i in [1, 2, 3]\n  print i*2, \"\\n\"\nend\n//}\n\n文法:\n\n          for lhs ...  in 式1 [do]\n            式2..\n          end\n\n式を評価した結果のオブジェクトの各要素に対して本体を繰り返し\nて実行します。これは以下の式とほぼ等価です。\n\n          (式1).each `{' `|' lhs..`|' 式2.. `}'\n\n「ほぼ」というのは、do  ...  endまたは{ }による\nブロックは新しいローカル変数の有効範囲を導入するのに対し、\nfor文はローカル変数のスコープに影響を及ぼさない点が\n異なるからです。\n\nfor は、in に指定したオブジェクトの each\nメソッドの戻り値を返します。\n\n複数のループ変数指定は以下のような場合に使用します。\n\n//emlist[例][ruby]{\nfor i,j in [[1,2], [3,4], [5,6]]\n  p [i,j]\nend\n# => [1, 2]\n#    [3, 4]\n#    [5, 6]\n//}\n\nfor や each で配列要素を複数個ずつ取得しながらループすることは\nできません。\n\n//emlist[][ruby]{\nfor i,j in [1, 2, 3]\n  p [i,j]\nend\n\n# => [1, nil]\n#    [2, nil]\n#    [3, nil]\n\n# [1,2] [3,nil] を期待するかもしれないがそうはならない\n//}\n\n代わりにそのようなメソッド(イテレータ)を定義する必要があります。\n\n//emlist[][ruby]{\nclass Array\n  def each2\n    i = 0\n    while i < self.size\n      yield self[i], self[i+1]\n      i += 2\n    end\n  end\nend\n//}\n\n====[a:break] break\n\n//emlist[例][ruby]{\ni = 0\nwhile i < 3\n  print i, \"\\n\"\n  break\nend\n//}\n\n文法:\n\n          break\n\n          break val\n\nbreak はもっとも内側のループを脱出します。ループとは\n\n    * while\n    * until\n    * for\n    * イテレータ\n\nのいずれかを指します。C 言語と異なり、break はループを脱出する作\n用だけを持ち、case を抜ける作用は持ちません。\n\nbreak によりループを抜けた for やイテレータは nil\nを返します。\nただし、引数を指定した場合はループの戻り値はその引数になります。\n\n\n====[a:next] next\n\n//emlist[例][ruby]{\n# 空行を捨てるcat\nARGF.each_line do |line|\n  next if line.strip.empty?\n  print line\nend\n//}\n\n文法:\n\n          next\n\n          next val\n\n\nnextはもっとも内側のループの次の繰り返しにジャンプします。\nイテレータでは、yield 呼び出しの脱出になります。\n\nnext により抜けた yield 式は nil を返します。\nただし、引数を指定した場合、yield 式の戻り値はその引数になります。\n\n====[a:redo] redo\n\n例:\n\n          redo\n\n\n文法:\n\n          redo\n\nループ条件のチェックを行なわず、現在の繰り返しをやり直します。\n\nイテレータ呼び出しにおける break, next, redo\nをまとめると以下のようになります。\n\n//emlist[][ruby]{\ndef iter\n  # (a)\n  #  :\n  # (b)\n  yield\n  # (c)\n  #  :\n  # (d)\nend\niter { redo  }  # -> (b) へ飛ぶ\niter { next  }  # -> (c) へ飛ぶ\niter { break }  # -> (d) へ飛ぶ\n//}\n\n(a) は、厳密には引数評価から始まります。(b) はブロック実行の直前を指し\nています(yield の引数が再評価されるわけではない)。(d) は、メソッドの終\n了です。\n\n//emlist[][ruby]{\ndef iter(var = p(\"(a)\"))\n  yield\n  p \"(c)\"\nensure\n  p \"(d)\"\nend\niter { p \"(b)\"; redo  }     # -> (a) .. (b)(b)(b)(b) ...\niter { p \"(b)\"; next  }     # -> (a) .. (b)(c) .. (d)\niter { p \"(b)\"; break }     # -> (a)..(b)(d)\n//}\n\n====[a:retry] retry\n\n例:\n\n          retry\n\n文法:\n\n          retry\n\nretry は、rescue 節で begin 式をはじめからもう一度実行するのに使用します。\n\nretry を使うことである処理が成功するまで処理を繰り返すようなループを作\nることができます。\n\n//emlist[][ruby]{\nbegin\n  do_something # exception raised\nrescue\n  # handles error\n  retry  # restart from beginning\nend\n//}\n\nrescue 節以外で retry が用いられた場合には例外 SyntaxError が発生\nします。\n\n=== 例外処理\n\n====[a:raise] raise\n\n//emlist[例][ruby]{\nraise \"you lose\"  # 例外 RuntimeError を発生させる\n# 以下の二つは SyntaxError を発生させる\nraise SyntaxError, \"invalid syntax\"\nraise SyntaxError.new(\"invalid syntax\")\nraise             # 最後の例外の再発生\n//}\n\n文法:\n\n          raise\n          raise messageまたはexception\n          raise error_type, message\n          raise error_type, message, traceback\n\n例外を発生させます。第一の形式では直前の例外を再発生させます。\n第二の形式では、引数が文字列であった場合、その文字列をメッセー\nジとする RuntimeError 例外を発生させます。引数が例外\nオブジェクトであった場合にはその例外を発生させます。第三の形式\nでは第一引数で指定された例外を、第二引数をメッセージとして発生さ\nせます。第四の形式の第三引数は\n$@または\nKernel.#callerで得られる\nスタック情報で、例外が発生した場所を示します。\n\n発生した例外は後述の begin 式の rescue 節で捕らえることができます。\nその場合 rescue error_type => var の形式を使えば\n例外オブジェクトを得られます。このオブジェクトは組み込み\n変数 $! でも得られます。また例外が\n発生したソースコード上の位置は変数 $@ に格納されます。\n\nKernel.#raise は Ruby の予約語ではなく、Kernel モジュールで\n定義されている関数的メソッドです。\n\n====[a:begin] begin\n\n//emlist[例][ruby]{\nbegin\n  do_something\nrescue\n  recover\nensure\n  must_to_do\nend\n//}\n\n文法:\n\n          begin\n            式..\n          [rescue [error_type,..] [=> evar] [then]\n            式..]..\n          [else\n            式..]\n          [ensure\n            式..]\n          end\n\n本体の実行中に例外が発生した場合、rescue 節(複数指定できます)が\n与えられていれば例外を捕捉できます。発生した例外と一致する\nrescue 節が存在する時には rescue 節の本体が実行されます。\n発生した例外は $! を使って参照することができます。また、\n指定されていれば変数 evar にも $! と同様に発生した例外が格\n納されます。\n\n//emlist[][ruby]{\nbegin\n  raise \"error message\"\nrescue => evar\n  p $!\n  p evar\nend\n# => #<RuntimeError: error message>\n#    #<RuntimeError: error message>\n\n//}\n例外の一致判定は，発生した例外が rescue 節で指定した\nクラスのインスタンスであるかどうかで行われます。\n\nerror_type が省略された時は StandardError のサブクラスであ\nる全ての例外を捕捉します。Rubyの組み込み例外は(SystemExit や\nInterrupt のような脱出を目的としたものを除いて)\nStandardError のサブクラスです。\n\n例外クラスのクラス階層については\n_builtin\nを参照してください。\n\nrescue では error_type は通常の引数と同じように評価され、\nそのいずれかが一致すれば本体が実行されます。error_type を評価し\nた値がクラスやモジュールでない場合には例外 TypeError が発生しま\nす。\n\n省略可能な else 節は、本体の実行によって例外が発生しなかった場合\nに評価されます。\n\nensure 節が存在する時は begin 式を終了する直前に必ず\nensure 節の本体を評価します。\n\nbegin式全体の評価値は、本体／rescue節／else節のうち\n最後に評価された文の値です。また各節において文が存在しなかったときの値\nはnilです。いずれにしてもensure節の値は無視されます。\n\nd:spec/def#class、d:spec/def#module、d:spec/def#method\nなどの定義文では、それぞれ\nbegin なしで rescue, ensure 節を定義でき、これにより例外を処理することが\nできます。\n\n==== rescue修飾子\n\n//emlist[例][ruby]{\nopen(\"nonexistent file\") rescue STDERR.puts \"Warning: #$!\"\n//}\n\n文法:\n\n          式1 rescue 式2\n\n式1で例外が発生したとき、式2を評価します。\n以下と同じ意味です。捕捉する例外クラスを指定することはできません。\n(つまり、StandardError 例外クラスのサブクラスだけしか捕捉できません)\n\n//emlist[][ruby]{\nbegin\n  式1\nrescue\n  式2\nend\n//}\n\nrescue修飾子を伴う式の値は例外が発生しなければ式1、例外が発生すれば式2\nです。\n\n//emlist[][ruby]{\nvar = open(\"nonexistent file\") rescue false\np var\n# => false\n//}\n\nただし、優先順位の都合により式全体を括弧で囲む必要がある場合があります。\nメソッドの引数にするには二重の括弧が必要です。\n\n          p(open(\"nonexistent file\") rescue false)\n          => parse error\n\n          p((open(\"nonexistent file\") rescue false))\n          => false\n\n=== その他\n\n====[a:return] return\n\n//emlist[例][ruby]{\nreturn\nreturn 12\nreturn 1,2,3\n//}\n\n文法:\n\n          return [式[`,' 式 ... ]]\n\n式の値を戻り値としてメソッドの実行を終了します。式が2つ以上\n与えられた時には、それらを要素とする配列をメソッドの戻り値と\nします。式が省略された場合には nil を戻り値とします。\n\nトップレベルで return した場合はプログラムが終了します。\nrequire, load されたファイル内のトップレベルで return した場合は呼び出し元に返ります。\n\n====[a:BEGIN] BEGIN\n\n//emlist[例][ruby]{\nBEGIN {\n  # ...\n}\n//}\n\n文法:\n\n          BEGIN '{' 文.. '}'\n\n初期化ルーチンを登録します。BEGINブロックで指定した文は当該ファ\nイルのどの文が実行されるより前に実行されます。複数のBEGINが指定\nされた場合には指定された順に実行されます。\n\nBEGINブロックはコンパイル時に登録されます。\n\nBEGIN ブロックは、独立したローカル変数のスコープを導入しません。つまり、\nBEGIN ブロック内で定義したローカル変数は BEGIN ブロックを抜けた後も使用\n可能です。\n\nBEGINはトップレベル以外では書けません。全て SyntaxErrorになります。\n\n        def foo\n          BEGIN { p \"begin\" }\n        end\n        # => -e:2: syntax error, unexpected keyword_BEGIN\n\n        class Foo\n          BEGIN { p \"begin\" }\n        end\n        # => -e:2: syntax error, unexpected keyword_BEGIN\n\n        loop do\n          BEGIN { p \"begin\" }\n        end\n        # => -e:2: syntax error, unexpected keyword_BEGIN\n\n====[a:END] END\n\n//emlist[例][ruby]{\nEND {\n  # ...\n}\n//}\n\n文法:\n\n          END '{' 文.. '}'\n\n「後始末」ルーチンを登録します。END ブロックで指定した文はインタ\nプリタが終了する時に実行されます。Ruby の終了時処理について詳しくは\nspec/terminateを参照してください。\n\n複数の END ブロックを登録した場合は、登録したときと逆の順序で実\n行されます。\n\n//emlist[][ruby]{\nEND { p 1 }\nEND { p 2 }\nEND { p 3 }\n\n# => 3\n#    2\n#    1\n//}\n\nEND ブロックは一つの記述につき最初の一回のみ有効です。たとえば以\n下のようにループの中で実行しても複数の END ブロックが登録される\nわけではありません。そのような目的には Kernel.#at_exit を使\nいます。\n\n//emlist[][ruby]{\n5.times do |i|\n  END { p i }\nend\n# => 0\n//}\n\nEND をメソッド定義式中に書くと警告が出ます。\n意図的にこのようなことを行いたい場合は Kernel.#at_exit を使\nいます。\n\n        def foo\n          END { p \"end\" }\n        end\n        p foo\n\n        # => -:2: warning: END in method; use at_exit\n             nil\n             \"end\"\n\nEND は、BEGIN とは異なり実行時に後処理を登録します。したがっ\nて、以下の例では END ブロックは実行されません。\n\n        if false\n          END { p \"end\" }\n        end\n\nEND や Kernel.#at_exit で登録した後処理を取り消すこと\nはできません。\n\nEND ブロックは周囲とスコープを共有します。すなわちイテレータと同様のス\nコープを持ちます。\n\nEND ブロックの中で発生した例外はその END ブロックを中断し\nますが、すべての後始末ルーチンが実行されるよう、インタプリタは終了せず\nにメッセージだけを出力します。\n\n//emlist[例][ruby]{\nEND { p \"FOO\" }\nEND { raise \"bar\"; p \"BAR\" }\nEND { raise \"baz\"; p \"BAZ\" }\n\n# => baz (RuntimeError)\n#    bar (RuntimeError)\n#    \"FOO\"\n//}",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Interrupt",
          "label": "Interrupt",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Interrupt/"
        },
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Kernel/"
        },
        {
          "key": "RuntimeError",
          "label": "RuntimeError",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:RuntimeError/"
        },
        {
          "key": "StandardError",
          "label": "StandardError",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:StandardError/"
        },
        {
          "key": "SyntaxError",
          "label": "SyntaxError",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:SyntaxError/"
        },
        {
          "key": "SystemExit",
          "label": "SystemExit",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:SystemExit/"
        },
        {
          "key": "TypeError",
          "label": "TypeError",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:TypeError/"
        },
        {
          "key": "_builtin",
          "label": "_builtin",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:_builtin/"
        },
        {
          "key": "spec/terminate",
          "label": "spec/terminate",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:spec%2Fterminate/"
        }
      ]
    },
    {
      "signature": "Kernel.#exec(command, options={}) -> ()",
      "score": 13.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "引数で指定されたコマンドを実行します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Kernel/m/exec.html",
          "description": "引数で指定されたコマンドを実行します。\n\nプロセスの実行コードはそのコマンド(あるいは shell)になるので、\n起動に成功した場合、このメソッドからは戻りません。\n\n=== 引数の解釈\n\nこの形式では command が shell のメタ文字\n//emlist{\n  * ? {} [] <> () ~ & | \\ $ ; ' ` \" \\n\n//}\nを含む場合、shell 経由で実行されます。\nそうでなければインタプリタから直接実行されます。\n\n@param command コマンドを文字列で指定します。\n@param env 更新する環境変数を表す Hash\n@param options オプションパラメータ Hash\n@raise Errno::EXXX 起動に失敗し、ruby インタプリタに制御が戻った場合に発生します。\n\n//emlist[例][ruby]{\n# a.rb\nputs '実行前'\nexec 'echo \"実行中\"'\nputs '実行後'\n//}\n\n上記のスクリプトを実行すると以下のようになります。\n\n  $ ruby a.rb\n  実行前\n  実行中\n  # '実行後' は表示されない",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Kernel/"
        }
      ]
    },
    {
      "signature": "Kernel.#exec(env, command, options={}) -> ()",
      "score": 13.0,
      "metadata": {
        "type": "module-function",
        "versions": [
          "3.3"
        ]
      },
      "summary": "引数で指定されたコマンドを実行します。",
      "documents": [
        {
          "version": "3.3",
          "url": "https://rurema.clear-code.com/3.3/method/Kernel/m/exec.html",
          "description": "引数で指定されたコマンドを実行します。\n\nプロセスの実行コードはそのコマンド(あるいは shell)になるので、\n起動に成功した場合、このメソッドからは戻りません。\n\n=== 引数の解釈\n\nこの形式では command が shell のメタ文字\n//emlist{\n  * ? {} [] <> () ~ & | \\ $ ; ' ` \" \\n\n//}\nを含む場合、shell 経由で実行されます。\nそうでなければインタプリタから直接実行されます。\n\n@param command コマンドを文字列で指定します。\n@param env 更新する環境変数を表す Hash\n@param options オプションパラメータ Hash\n@raise Errno::EXXX 起動に失敗し、ruby インタプリタに制御が戻った場合に発生します。\n\n//emlist[例][ruby]{\n# a.rb\nputs '実行前'\nexec 'echo \"実行中\"'\nputs '実行後'\n//}\n\n上記のスクリプトを実行すると以下のようになります。\n\n  $ ruby a.rb\n  実行前\n  実行中\n  # '実行後' は表示されない",
          "snippets": []
        }
      ],
      "related_entries": [
        {
          "key": "Kernel",
          "label": "Kernel",
          "type": "module",
          "url": "https://rurema.clear-code.com/api:v1/module:Kernel/"
        }
      ]
    }
  ]
}
