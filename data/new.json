{
  "versions": [
    { "name": "all", "selected": true },
    { "name": "2.1.0", "selected": false },
    { "name": "2.2.0", "selected": false },
    { "name": "2.3.0", "selected": false },
    { "name": "2.4.0", "selected": false },
    { "name": "2.5.0", "selected": false },
    { "name": "2.6.0", "selected": false },
    { "name": "2.7.0", "selected": false },
    { "name": "3.0.0", "selected": false },
    { "name": "3.1.0", "selected": false },
    { "name": "3.2.0", "selected": false }
  ],
  "statistics": {
    "total": 697,
    "start_offset": 1,
    "end_offset": 100,
    "elapsed_time": 0.03216195106506348
  },
  "conditions": [
    {
      "name": "query",
      "value": "array",
      "icon_url": "https://rurema.clear-code.com/images/query-icon.png"
    },
    {
      "name": "query",
      "value": "each",
      "icon_url": "https://rurema.clear-code.com/images/query-icon.png"
    }
  ],
  "corrections": [
    { "value": "array fill", "score": 5510 },
    { "value": "array []", "score": 3673 },
    { "value": "array sample", "score": 3672 },
    { "value": "array fetch", "score": 2756 },
    { "value": "array []=", "score": 2754 }
  ],
  "suggestions": [],
  "entries": [
    {
      "signature": "Array#each -> Enumerator",
      "score": 27138.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "各要素に対してブロックを評価します。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        },
        {
          "key": "Enumerator",
          "label": "Enumerator",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Enumerator/"
        }
      ]
    },
    {
      "signature": "Array#each {|item| .... } -> self",
      "score": 27138.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "各要素に対してブロックを評価します。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/i/each.html",
          "description": "各要素に対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].each do |i|\n  puts i\nend\n#=> 1\n#   2\n#   3\n//}\n\n\n@see Array#each_index, Array#reverse_each",
          "snippets": [
            "対してブロックを評価します。\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\n[1, 2, 3].<span class=\"keyword\">each</span> do |i|\n  puts i\nend\n#=&gt; 1\n#   2\n#   3\n//}\n\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>_index,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        },
        {
          "key": "Enumerator",
          "label": "Enumerator",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Enumerator/"
        }
      ]
    },
    {
      "signature": "Array#each_index -> Enumerator",
      "score": 15138.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "各要素のインデックスに対してブロックを評価します。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        },
        {
          "key": "Enumerator",
          "label": "Enumerator",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Enumerator/"
        }
      ]
    },
    {
      "signature": "Array#each_index {|index| .... } -> self",
      "score": 15138.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "各要素のインデックスに対してブロックを評価します。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/i/each_index.html",
          "description": "各要素のインデックスに対してブロックを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).each do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と each_index から生成した\nEnumerator オブジェクトを返します。\n\n@see Array#each, Array#reverse_each",
          "snippets": [
            "クを評価します。\n\n以下と同じです。\n\n//emlist[例][ruby]{\n(0 ... ary.size).<span class=\"keyword\">each</span> do |index|\n  # ....\nend\n//}\n\nブロックが与えられなかった場合は、自身と<span class=\"keyword\"> each</span>_index から生成した\nEnumerator オブジェクトを返します。\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>,<span class=\"keyword\"> Array</span>#reverse_<span class=\"keyword\">each</span>"
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        },
        {
          "key": "Enumerator",
          "label": "Enumerator",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Enumerator/"
        }
      ]
    },
    {
      "signature": "Array#reverse_each -> Enumerator",
      "score": 15126.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "各要素に対して逆順にブロックを評価します。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        },
        {
          "key": "Enumerator",
          "label": "Enumerator",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Enumerator/"
        }
      ]
    },
    {
      "signature": "Array#reverse_each {|item| ... } -> self",
      "score": 15126.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "各要素に対して逆順にブロックを評価します。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/i/reverse_each.html",
          "description": "各要素に対して逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_each から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ \"a\", \"b\", \"c\" ]\na.reverse_each {|x| print x, \" \" }\n# => c b a\n//}\n\n@see Array#each",
          "snippets": [
            "て逆順にブロックを評価します。\n\nブロックが与えられなかった場合は、自身と reverse_<span class=\"keyword\">each</span> から生成した\nEnumerator オブジェクトを返します。\n\n//emlist[例][ruby]{\na = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]\na.reverse_<span class=\"keyword\">each</span> {|x| print x, &quot; &quot; }\n# =&gt; c b a\n//}\n\n@see<span class=\"keyword\"> Array</span>#<span class=\"keyword\">each</span>"
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        },
        {
          "key": "Enumerator",
          "label": "Enumerator",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:Enumerator/"
        }
      ]
    },
    {
      "signature": "Array.new(ary) -> Array",
      "score": 9140.0,
      "metadata": {
        "type": "singleton-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/s/new.html",
          "description": "指定された配列 ary を複製して返します。\nArray#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np Array.new([1,2,3]) # => [1,2,3]\n\na = [\"a\", \"b\", \"c\"]\nb = Array.new(a)\na.each{|s| s.capitalize! }\np a                        #=> [\"A\", \"B\", \"C\"]\np b                        #=> [\"A\", \"B\", \"C\"]   (b は a と要素を共有する)\n//}",
          "snippets": [
            "配列 ary を複製して返します。<span class=\"keyword\">\nArray</span>#dup 同様 要素を複製しない浅い複製です。\n\n@param ary 複製したい配列を指定します。\n\n//emlist[例][ruby]{\np<span class=\"keyword\"> Array</span>.new([1,2,3]) # =&gt; [1,2,3]\n\na = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\nb =<span class=\"keyword\"> Array</span>.new(a)\na.<span class=\"keyword\">each</span>{|s| s.capitalize! }\np a                "
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        }
      ]
    },
    {
      "signature": "Array.new(size) {|index| ... } -> Array",
      "score": 9120.0,
      "metadata": {
        "type": "singleton-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素のインデックスを引数としてブロックを実行し、\n各要素の値をブロックの評価結果に設定します。\n\nブロックは要素毎に実行されるので、全要素をあるオブジェクトの複製にすることができます。\n\n@param size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3){|index| \"hoge#{index}\"}\np ary                      #=> [\"hoge0\", \"hoge1\", \"hoge2\"]\n//}\n\n//emlist[例][ruby]{\nary = Array.new(3){ \"foo\" }\np ary                      #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                      #=> [\"Foo\", \"foo\", \"foo\"]  (各要素は違うオブジェクトである)\n//}",
          "snippets": [
            "aram size 配列の長さを数値で指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){|index| &quot;hoge#{index}&quot;}\np ary                      #=&gt; [&quot;hoge0&quot;, &quot;hoge1&quot;, &quot;hoge2&quot;]\n//}\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3){ &quot;foo&quot; }\np ary                      #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capita"
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        }
      ]
    },
    {
      "signature": "Array.new(size = 0, val = nil) -> Array",
      "score": 9115.0,
      "metadata": {
        "type": "singleton-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "長さ size の配列を生成し、各要素を val で初期化して返します。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/s/new.html",
          "description": "長さ size の配列を生成し、各要素を val で初期化して返します。\n\n要素毎に val が複製されるわけではないことに注意してください。\n全要素が同じオブジェクト val を参照します。\n後述の例では、配列の各要素は全て同一の文字列を指します。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary = Array.new(3, \"foo\")\np ary                     #=> [\"foo\", \"foo\", \"foo\"]\nary[0].capitalize!\np ary                     #=> [\"Foo\", \"Foo\", \"Foo\"]  (各要素は同一のオブジェクトである)\n//}",
          "snippets": [
            "。\n\n@param size 配列の長さを数値で指定します。\n\n@param val 配列の要素の値を指定します。\n\n//emlist[例][ruby]{\nary =<span class=\"keyword\"> Array</span>.new(3, &quot;foo&quot;)\np ary                     #=&gt; [&quot;foo&quot;, &quot;foo&quot;, &quot;foo&quot;]\nary[0].capitalize!\np ary                     #=&gt; [&quot;Foo&quot;, &quot;Foo&quot;, &quot;Foo&quot;]  (各要素"
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        }
      ]
    },
    {
      "signature": "Array#pack(template) -> String",
      "score": 9030.0,
      "metadata": {
        "type": "instance-method",
        "versions": [
          "2.1.0",
          "2.2.0",
          "2.3.0",
          "2.4.0",
          "2.5.0",
          "2.6.0",
          "2.7.0",
          "3.0.0",
          "3.1.0",
          "3.2.0"
        ]
      },
      "summary": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。",
      "documents": [
        {
          "version": "2.1.0",
          "url": "https://rurema.clear-code.com/2.1.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n\n\n以下にあげるものは、Array#pack、String#unpack\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\xFF\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\xFF\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack",
          "snippets": [
            " template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けること",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        },
        {
          "version": "2.2.0",
          "url": "https://rurema.clear-code.com/2.2.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n\n\n以下にあげるものは、Array#pack、String#unpack\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\xFF\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\xFF\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack",
          "snippets": [
            " template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けること",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        },
        {
          "version": "2.3.0",
          "url": "https://rurema.clear-code.com/2.3.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n\n\n以下にあげるものは、Array#pack、String#unpack\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\xFF\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\xFF\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack",
          "snippets": [
            " template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けること",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        },
        {
          "version": "2.4.0",
          "url": "https://rurema.clear-code.com/2.4.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\nbuffer が指定されていれば、バッファとして使って返値として返します。\nもし template の最初にオフセット (@) が指定されていれば、\n結果はオフセットの後ろから詰められます。\nbuffer の元の内容がオフセットより長ければ、\nオフセットより後ろの部分は上書きされます。\nオフセットより短ければ、足りない部分は \"\\0\" で埋められます。\n\nbuffer オプションはメモリ確保が発生しないことを保証するものでは\nないことに注意してください。\nbuffer のサイズ(capacity)が足りなければ、packはメモリを確保します。\n\n//emlist[例][ruby]{\n['!'].pack('@1a', buffer: 'abc')  # => \"a!\"\n['!'].pack('@5a', buffer: 'abc')  # => \"abc\\u0000\\u0000!\"\n//}\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n@param buffer   結果を詰めるバッファとして使う文字列オブジェクトを指定します。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、Array#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\xFF\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\xFF\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack, String#unpack1",
          "snippets": [
            "ます。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        },
        {
          "version": "2.5.0",
          "url": "https://rurema.clear-code.com/2.5.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\nbuffer が指定されていれば、バッファとして使って返値として返します。\nもし template の最初にオフセット (@) が指定されていれば、\n結果はオフセットの後ろから詰められます。\nbuffer の元の内容がオフセットより長ければ、\nオフセットより後ろの部分は上書きされます。\nオフセットより短ければ、足りない部分は \"\\0\" で埋められます。\n\nbuffer オプションはメモリ確保が発生しないことを保証するものでは\nないことに注意してください。\nbuffer のサイズ(capacity)が足りなければ、packはメモリを確保します。\n\n//emlist[例][ruby]{\n['!'].pack('@1a', buffer: 'abc')  # => \"a!\"\n['!'].pack('@5a', buffer: 'abc')  # => \"abc\\u0000\\u0000!\"\n//}\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n@param buffer   結果を詰めるバッファとして使う文字列オブジェクトを指定します。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、Array#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\xFF\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\xFF\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack, String#unpack1",
          "snippets": [
            "ます。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        },
        {
          "version": "2.6.0",
          "url": "https://rurema.clear-code.com/2.6.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\nbuffer が指定されていれば、バッファとして使って返値として返します。\nもし template の最初にオフセット (@) が指定されていれば、\n結果はオフセットの後ろから詰められます。\nbuffer の元の内容がオフセットより長ければ、\nオフセットより後ろの部分は上書きされます。\nオフセットより短ければ、足りない部分は \"\\0\" で埋められます。\n\nbuffer オプションはメモリ確保が発生しないことを保証するものでは\nないことに注意してください。\nbuffer のサイズ(capacity)が足りなければ、packはメモリを確保します。\n\n//emlist[例][ruby]{\n['!'].pack('@1a', buffer: 'abc')  # => \"a!\"\n['!'].pack('@5a', buffer: 'abc')  # => \"abc\\u0000\\u0000!\"\n//}\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n@param buffer   結果を詰めるバッファとして使う文字列オブジェクトを指定します。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、Array#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\x7F\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\x7F\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack, String#unpack1",
          "snippets": [
            "ます。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        },
        {
          "version": "2.7.0",
          "url": "https://rurema.clear-code.com/2.7.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\nbuffer が指定されていれば、バッファとして使って返値として返します。\nもし template の最初にオフセット (@) が指定されていれば、\n結果はオフセットの後ろから詰められます。\nbuffer の元の内容がオフセットより長ければ、\nオフセットより後ろの部分は上書きされます。\nオフセットより短ければ、足りない部分は \"\\0\" で埋められます。\n\nbuffer オプションはメモリ確保が発生しないことを保証するものでは\nないことに注意してください。\nbuffer のサイズ(capacity)が足りなければ、packはメモリを確保します。\n\n//emlist[例][ruby]{\n['!'].pack('@1a', buffer: 'abc')  # => \"a!\"\n['!'].pack('@5a', buffer: 'abc')  # => \"abc\\u0000\\u0000!\"\n//}\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n@param buffer   結果を詰めるバッファとして使う文字列オブジェクトを指定します。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、Array#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\x7F\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\x7F\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack, String#unpack1",
          "snippets": [
            "ます。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        },
        {
          "version": "3.0.0",
          "url": "https://rurema.clear-code.com/3.0.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\nbuffer が指定されていれば、バッファとして使って返値として返します。\nもし template の最初にオフセット (@) が指定されていれば、\n結果はオフセットの後ろから詰められます。\nbuffer の元の内容がオフセットより長ければ、\nオフセットより後ろの部分は上書きされます。\nオフセットより短ければ、足りない部分は \"\\0\" で埋められます。\n\nbuffer オプションはメモリ確保が発生しないことを保証するものでは\nないことに注意してください。\nbuffer のサイズ(capacity)が足りなければ、packはメモリを確保します。\n\n//emlist[例][ruby]{\n['!'].pack('@1a', buffer: 'abc')  # => \"a!\"\n['!'].pack('@5a', buffer: 'abc')  # => \"abc\\u0000\\u0000!\"\n//}\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n@param buffer   結果を詰めるバッファとして使う文字列オブジェクトを指定します。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、Array#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\x7F\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\x7F\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack, String#unpack1",
          "snippets": [
            "ます。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        },
        {
          "version": "3.1.0",
          "url": "https://rurema.clear-code.com/3.1.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\nbuffer が指定されていれば、バッファとして使って返値として返します。\nもし template の最初にオフセット (@) が指定されていれば、\n結果はオフセットの後ろから詰められます。\nbuffer の元の内容がオフセットより長ければ、\nオフセットより後ろの部分は上書きされます。\nオフセットより短ければ、足りない部分は \"\\0\" で埋められます。\n\nbuffer オプションはメモリ確保が発生しないことを保証するものでは\nないことに注意してください。\nbuffer のサイズ(capacity)が足りなければ、packはメモリを確保します。\n\n//emlist[例][ruby]{\n['!'].pack('@1a', buffer: 'abc')  # => \"a!\"\n['!'].pack('@5a', buffer: 'abc')  # => \"abc\\u0000\\u0000!\"\n//}\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n@param buffer   結果を詰めるバッファとして使う文字列オブジェクトを指定します。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、Array#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\x7F\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\x7F\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack, String#unpack1",
          "snippets": [
            "ます。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        },
        {
          "version": "3.2.0",
          "url": "https://rurema.clear-code.com/3.2.0/method/Array/i/pack.html",
          "description": "配列の内容を template で指定された文字列にしたがって、\nバイナリとしてパックした文字列を返します。\n\nテンプレートは\n型指定文字列とその長さ(省略時は1)を並べたものです。長さと\nして * が指定された時は「残りのデータ全て」の長さを\n表します。型指定文字は以下で述べる pack テンプレート文字列の通りです。\n\nbuffer が指定されていれば、バッファとして使って返値として返します。\nもし template の最初にオフセット (@) が指定されていれば、\n結果はオフセットの後ろから詰められます。\nbuffer の元の内容がオフセットより長ければ、\nオフセットより後ろの部分は上書きされます。\nオフセットより短ければ、足りない部分は \"\\0\" で埋められます。\n\nbuffer オプションはメモリ確保が発生しないことを保証するものでは\nないことに注意してください。\nbuffer のサイズ(capacity)が足りなければ、packはメモリを確保します。\n\n//emlist[例][ruby]{\n['!'].pack('@1a', buffer: 'abc')  # => \"a!\"\n['!'].pack('@5a', buffer: 'abc')  # => \"abc\\u0000\\u0000!\"\n//}\n\n@param template 自身のバイナリとしてパックするためのテンプレートを文字列で指定します。\n@param buffer   結果を詰めるバッファとして使う文字列オブジェクトを指定します。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、Array#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを続けることができます。「長さ」の代わりに`*'とすることで「残り全て」\nを表すこともできます。\n\n長さの意味はテンプレート文字により異なりますが大抵、\n  \"iiii\"\nのように連続するテンプレート文字は\n  \"i4\"\nと書き換えることができます。\n\nテンプレート文字列中の空白類は無視されます。\nまた、`#' から改行あるいはテンプレート文字列の最後まではコメントとみな\nされ無視されます。\n\n=== 整数のテンプレート文字のシステム依存性\n\n各テンプレート文字の説明の中で、\nshort や long はシステムによらずそれぞれ 2, 4バイトサ\nイズの数値(32ビットマシンで一般的なshort, longのサイズ)を意味していま\nす。s, S, l, L に対しては直後に _ または ! を \"s_\" あるいは \"s!\" のように\n続けることでシステム依存の short, long のサイズにすることもできます。\n\ni, I (int)のサイズは常にシステム依存であり、n, N, v, V\nのサイズは常にシステム依存ではない(!をつけられない)ことに注意してください。\n\nつまり、IO#ioctl などで C の構造体を渡すときのように、\nシステム依存のサイズとエンディアンに合わせる必要があるときには\ns!, S!, i!, I!, l!, L!, q!, Q!, j!, J! を用います。\nまた、ネットワークプロトコルやファイルフォーマットのように、\nシステムに依存しないデータを扱うときには\nn, N, v, V を用います。\n\n強制的にエンディアンを指定したいときは、\nリトルエンディアンなら < を、\nビッグエンディアンなら >\nを後ろにつけます。! と組み合わせることも可能です。\n\nまとめると以下のようになります。\n\n: エンディアン非依存、整数サイズ非依存 (ネットワークプロトコルなどに適切)\n//emlist{\n  n: big endian unsigned 16bit\n  N: big endian unsigned 32bit\n  v: little endian unsigned 16bit\n  V: little endian unsigned 32bit\n//}\n\n: エンディアン依存、整数サイズ依存 (C の構造体などに適切)\n//emlist{\n  s!: signed short\n  S!: unsigned short\n  i,i!: signed int\n  I,I!: unsigned int\n  l!: signed long\n  L!: unsigned long\n  q!: signed long long\n  Q!: unsigned long long\n  j,j!: intptr_t\n  J,J!: uintptr_t\n//}\n\n: エンディアン依存、整数サイズ非依存 (C99 の stdint.h にある厳密な幅を持つ整数型に適切)\n//emlist{\n  s: int16_t\n  S: uint16_t\n  l: int32_t\n  L: uint32_t\n  q: int64_t\n  Q: uint64_t\n//}\n\n: エンディアンの強制指定(バイナリ解析などに適切)\n//emlist{\n  S>:  big endian unsigned 16bit(nと同じ)\n  s>:  big endian int16_t\n  s!>: big endian signed short\n  l<:  little endian int32_t\n  l!<: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、Array#pack と String#unpack で違いのあるものは `/' で区切って\n「Array#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰める/後続するヌル文字やスペースを残す)\n//emlist[][ruby]{\n[\"abc\"].pack(\"a\")    # => \"a\"\n[\"abc\"].pack(\"a*\")   # => \"abc\"\n[\"abc\"].pack(\"a4\")   # => \"abc\\x00\"\n\n\"abc\\0\".unpack(\"a4\") # => [\"abc\\x00\"]\n\"abc \".unpack(\"a4\")  # => [\"abc \"]\n//}\n\n: A\n\n  ASCII文字列(スペースを詰める/後続するヌル文字やスペースを削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"A\")    # => \"a\"\n[\"abc\"].pack(\"A*\")   # => \"abc\"\n[\"abc\"].pack(\"A4\")   # => \"abc \"\n\n\"abc \".unpack(\"A4\")  # => [\"abc\"]\n\"abc\\0\".unpack(\"A4\") # => [\"abc\"]\n//}\n\n: Z\n\n  ヌル終端文字列(長さが`*'の場合も含め、ヌル文字を詰める/後続するヌル文字を削除)\n//emlist[][ruby]{\n[\"abc\"].pack(\"Z\")  # => \"a\"\n[\"abc\"].pack(\"Z*\") # => \"abc\\x00\"\n[\"abc\"].pack(\"Z5\") # => \"abc\\x00\\x00\"\n\n\"abc\\0\".unpack(\"Z4\") # => [\"abc\"]\n\"abc \".unpack(\"Z4\")  # => [\"abc \"]\n//}\n\n: b\n\n  ビットストリング(各バイトごとに下位ビットから上位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"b*\") # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"b*\") # => [\"1000000001000000\"]\n\"\\x01\\x02\".unpack(\"b3\") # => [\"100\"]\n\n\n[\"1000000001000000\"].pack(\"b*\") # => \"\\x01\\x02\"\n//}\n\n: B\n\n  ビットストリング(各バイトごとに上位ビットから下位ビット)\n//emlist[][ruby]{\n\"\\xFF\\x00\".unpack(\"B*\")  # => [\"1111111100000000\"]\n\"\\x01\\x02\".unpack(\"B*\")  # => [\"0000000100000010\"]\n\"\\x01\\x02\".unpack(\"B9\")  # => [\"000000010\"]\n\"\\x01\\x02\".unpack(\"B15\") # => [\"000000010000001\"]\n\n[\"0000000100000010\"].pack(\"B*\")  # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B0\")  # => \"\"\n[\"0000000100000010\"].pack(\"B1\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B7\")  # => \"\\x00\"\n[\"0000000100000010\"].pack(\"B8\")  # => \"\\x01\"\n[\"0000000100000010\"].pack(\"B9\")  # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B14\") # => \"\\x01\\x00\"\n[\"0000000100000010\"].pack(\"B15\") # => \"\\x01\\x02\"\n[\"0000000100000010\"].pack(\"B16\") # => \"\\x01\\x02\"\n//}\n\n: h\n\n  16進文字列(下位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"h*\") # => [\"10ef\"]\n\"\\x01\\xFE\".unpack(\"h3\") # => [\"10e\"]\n\n[\"10ef\"].pack(\"h*\") # => \"\\x01\\xFE\"\n//}\n\n: H\n\n  16進文字列(上位ニブルが先)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"H*\") # => [\"01fe\"]\n\"\\x01\\xFE\".unpack(\"H3\") # => [\"01f\"]\n\"~\".unpack(\"H2\")        # => [\"7e\"]\n\n[\"01fe\"].pack(\"H*\") # => \"\\x01\\xFE\"\n[\"7e\"].pack(\"H2\")   # => \"~\"\n//}\n\n: c\n\n  char (8bit 符号つき整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"c*\") # => [1, -2]\n\n[1, -2].pack(\"c*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"c*\") # => \"\\x01\\xFE\"\n//}\n\n: C\n\n  unsigned char (8bit 符号なし整数)\n//emlist[][ruby]{\n\"\\x01\\xFE\".unpack(\"C*\") # => [1, 254]\n\n[1, -2].pack(\"C*\")  # => \"\\x01\\xFE\"\n[1, 254].pack(\"C*\") # => \"\\x01\\xFE\"\n//}\n\n: s\n\n  short (16bit 符号つき整数, エンディアンに依存)\n  (s! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [513, -514]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"s*\") # => [258, -259]\n\n[258, 65277].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: S\n\n  unsigned short (16bit 符号なし整数, エンディアンに依存)\n  (S! は 16bit でなく、short のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [513, 65022]\n\n[513, 65022].pack(\"s*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[513, -514].pack(\"s*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n  ビッグエンディアン (SPARC64):\n\n//emlist[][ruby]{\n\"\\x01\\x02\\xFE\\xFD\".unpack(\"S*\") # => [258, 65277]\n\n[258, 65277].pack(\"S*\") # => \"\\x01\\x02\\xFE\\xFD\"\n[258, -259].pack(\"S*\")  # => \"\\x01\\x02\\xFE\\xFD\"\n//}\n\n: i\n\n  int (符号つき整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"i*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"i*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"i*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"i*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n: I\n\n  unsigned int (符号なし整数, エンディアンと int のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"I*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n  ビッグエンディアン (SPARC64), 32bit int:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"I*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"I*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"I*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: l\n\n  long (32bit 符号つき整数, エンディアンに依存)\n  (l! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [67305985, -50462977]\n\n[67305985, 4244504319].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"l*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"l*\") # => [16909060, -66052]\n\n[16909060, 4294901244].pack(\"l*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"l*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: L\n\n  unsigned long (32bit 符号なし整数, エンディアンに依存)\n  (L! は 32bit でなく、long のサイズに依存)\n\n  リトルエンディアン (x86_64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [67305985, 4244504319]\n\n[67305985, 4244504319].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[67305985, -50462977].pack(\"L*\")  # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n  ビッグエンディアン (SPARC64), 32bit long:\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\".unpack(\"L*\") # => [16909060, 4294901244]\n\n[16909060, 4294901244].pack(\"L*\") # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n[16909060, -66052].pack(\"L*\")     # => \"\\x01\\x02\\x03\\x04\\xFF\\xFE\\xFD\\xFC\"\n//}\n\n: q\n\n  64bit 符号付き整数 (エンディアンに依存)\n  (q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [578437695752307201, -506097522914230529]\n\n[578437695752307201, -506097522914230529].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, 17940646550795321087].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"q*\")\n# => [72623859790382856, -283686952306184]\n\n[72623859790382856, -283686952306184].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, 18446460386757245432].pack(\"q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: Q\n\n  64bit 符号なし整数 (エンディアンに依存)\n  (Q! は 64bit でなく、long long のサイズに依存)\n\n  リトルエンディアン (x86_64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [578437695752307201, 17940646550795321087]\n\n[578437695752307201, 17940646550795321087].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[578437695752307201, -506097522914230529].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n\n  ビッグエンディアン (SPARC64):\n//emlist[][ruby]{\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\".unpack(\"Q*\")\n# => [72623859790382856, 18446460386757245432]\n\n[72623859790382856, 18446460386757245432].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n[72623859790382856, -283686952306184].pack(\"Q*\")\n# => \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\xFF\\xFE\\xFD\\xFC\\xFB\\xFA\\xF9\\xF8\"\n//}\n: m\n\n  base64された文字列。60 オクテットごと(と最後)に改行コードが付加されます。\n\n  Base64は、3オクテット(8bits * 3 = 24bits)のバイナリコードをASCII文字の\n  うちの65文字 ([A-Za-z0-9+/]の64文字とpaddingのための'=')だけを使用して\n  4オクテット(6bits * 4 = 24bits)の印字可能文字列に変換するエンコーディ\n  ング法です。2045, 4648 で定義されています。\n//emlist[][ruby]{\n[\"\"].pack(\"m\")             # => \"\"\n[\"\\0\"].pack(\"m\")           # => \"AA==\\n\"\n[\"\\0\\0\"].pack(\"m\")         # => \"AAA=\\n\"\n[\"\\0\\0\\0\"].pack(\"m\")       # => \"AAAA\\n\"\n[\"\\xFF\"].pack(\"m\")         # => \"/w==\\n\"\n[\"\\xFF\\xFF\"].pack(\"m\")     # => \"//8=\\n\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m\") # => \"////\\n\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\"\n[\"abcdefghijklmnopqrstuvwxyz\"].pack(\"m3\")\n# => \"YWJj\\nZGVm\\nZ2hp\\namts\\nbW5v\\ncHFy\\nc3R1\\ndnd4\\neXo=\\n\"\n\n\"\".unpack(\"m\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m\") # => [\"\\x00\"]\n\"AA==\".unpack(\"m\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJT\\nVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\\n\".unpack(\"m\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n  m0 は 4648 対応\n//emlist[][ruby]{\n[\"\"].pack(\"m0\")             # => \"\"\n[\"\\0\"].pack(\"m0\")           # => \"AA==\"\n[\"\\0\\0\"].pack(\"m0\")         # => \"AAA=\"\n[\"\\0\\0\\0\"].pack(\"m0\")       # => \"AAAA\"\n[\"\\xFF\"].pack(\"m0\")         # => \"/w==\"\n[\"\\xFF\\xFF\"].pack(\"m0\")     # => \"//8=\"\n[\"\\xFF\\xFF\\xFF\"].pack(\"m0\") # => \"////\"\n\n[\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"].pack(\"m0\")\n# => \"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\"\n\n\"\".unpack(\"m0\")       # => [\"\"]\n\"AA==\\n\".unpack(\"m0\") # => ArgumentError (invalid base64)\n\"AA==\".unpack(\"m0\")   # => [\"\\x00\"]\n\n\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWg==\".unpack(\"m0\")\n# => [\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"]\n//}\n@see base64\n\n: M\n\n  quoted-printable encoding された文字列\n//emlist[][ruby]{\n[\"a b c\\td \\ne\"].pack(\"M\") # => \"a b c\\td =\\n\\ne=\\n\"\n\n\"a b c\\td =\\n\\ne=\\n\".unpack(\"M\") # => [\"a b c\\td \\ne\"]\n//}\n\n: n\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"n*\")\n# => \"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x01\\xFF\\xFF\\x7F\\xFF\\x80\\x00\\xFF\\xFF\".unpack(\"n*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: N\n\n  ネットワークバイトオーダー(ビッグエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"N*\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\"\n\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\xFF\\xFF\\xFF\\xFF\".unpack(\"N*\") # => [0, 1, 4294967295]\n//}\n\n: v\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned short (16bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1,32767,-32768,65535].pack(\"v*\")\n# => \"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\"\n\n\"\\x00\\x00\\x01\\x00\\xFF\\xFF\\xFF\\x7F\\x00\\x80\\xFF\\xFF\".unpack(\"v*\")\n# => [0, 1, 65535, 32767, 32768, 65535]\n//}\n\n: V\n\n  \"VAX\"バイトオーダー(リトルエンディアン)のunsigned long (32bit 符号なし整数)\n//emlist[][ruby]{\n[0,1,-1].pack(\"V*\") # => \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\"\n\n\n\"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\".unpack(\"V*\") # => [0, 1, 4294967295]\n//}\n\n: f\n\n  単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 単精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"\\x00\\x00\\x80?\"\n[0.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\xC0\\x7F\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x00\\x00\\x80\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\x00\\x00\\x80\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 単精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"f\")      # => \"?\\x80\\x00\\x00\"\n[0.0/0.0].pack(\"f\")  # => \"\\x7F\\xC0\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"f\")  # => \"\\x7F\\x80\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"f\") # => \"\\xFF\\x80\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"f\") # => \"\\x80@\\x00\\x00\"\n//}\n\n: d\n\n  倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754 倍精度 リトルエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n[0.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF8\\x7F\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\x7F\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0\\xFF\"      # -Infinity\n//}\n\n  SPARC64 (IEEE754 倍精度 ビッグエンディアン):\n//emlist[][ruby]{\n[1.0].pack(\"d\")      # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n[0.0/0.0].pack(\"d\")  # => \"\\x7F\\xF8\\x00\\x00\\x00\\x00\\x00\\x00\"      # NaN\n[1.0/0.0].pack(\"d\")  # => \"\\x7F\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # +Infinity\n[-1.0/0.0].pack(\"d\") # => \"\\xFF\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"      # -Infinity\n//}\n\n  VAX (NetBSD 3.0) (非IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"d\") # => \"\\x80@\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: e\n\n  リトルエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"e\") # => \"\\x00\\x00\\x80?\"\n//}\n\n: E\n\n  リトルエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"E\") # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\xF0?\"\n//}\n\n: g\n\n  ビッグエンディアンの単精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"g\") # => \"?\\x80\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"g\").unpack(\"B*\")[0][0,1]      # 符号\ne = [v].pack(\"g\").unpack(\"B*\")[0][1,8]      # 指数部\nf = [v].pack(\"g\").unpack(\"B*\")[0][9,23]     # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-126-23)    # 非正規化数 (denormalized number)\n  end\nelsif exp == 255\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 23                # ゲタ\n  sgn * fra * 2**(exp-127-23)   # 正規化数 (normalized number)\nend\n//}\n\n: G\n\n  ビッグエンディアンの倍精度浮動小数点数(機種依存)\n\n  x86_64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  SPARC64 (IEEE754):\n//emlist[][ruby]{\n[1.0].pack(\"G\") # => \"?\\xF0\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  IEEE754準拠な環境の場合、以下のようにして符号、指数部、仮数部を取り出せます。\n//emlist[][ruby]{\ns = [v].pack(\"G\").unpack(\"B*\")[0][0,1]    # 符号\ne = [v].pack(\"G\").unpack(\"B*\")[0][1,11]   # 指数部\nf = [v].pack(\"G\").unpack(\"B*\")[0][12,52]  # 仮数部\n//}\n\n  そして、s, e, f の意味は以下の通りです。\n//emlist[][ruby]{\nsgn = s == \"0\" ? +1.0 : -1.0\nexp = Integer(\"0b\" + e)\nfra = Integer(\"0b\" + f)\nif exp == 0\n  if fra == 0\n    sgn * 0                     # ±0 (positive/negative zero)\n  else\n    sgn * fra * 2**(-1022-52)   # 非正規化数 (denormalized number)\n  end\nelsif exp == 2047\n  if fra == 0\n    sgn * Inf                   # ±∞ (positive/negative infinity)\n  else\n    NaN                         # 非数 (not a number)\n  end\nelse\n  fra += 1 << 52                # ゲタ\n  sgn * fra * 2**(exp-1023-52)  # 正規化数 (normalized number)\nend\n//}\n\n: p\n\n  ヌル終端の文字列へのポインタ\n//emlist[][ruby]{\n[\"\"].pack(\"p\")             # => \"\\x980\\xBEf\\x1CV\\x00\\x00\"\n[\"a\", \"b\", \"c\"].pack(\"p3\") # => \"\\x98\\xE5\\x9ER\\xD2U\\x00\\x00p\\xE5\\x9ER\\xD2U\\x00\\x00H\\xE5\\x9ER\\xD2U\\x00\\x00\"\n[nil].pack(\"p\")            # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n: P\n\n  構造体(固定長文字列)へのポインタ\n//emlist[][ruby]{\n[nil].pack(\"P\")    # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n[\"abc\"].pack(\"P3\") # => \"\\xA0\\xEE\\er\\x84U\\x00\\x00\"\n\n[\"abc\"].pack(\"P4\") # => ArgumentError: too short buffer for P(3 for 4)\n[\"\"].pack(\"P\")     # => ArgumentError: too short buffer for P(0 for 1)\n//}\n\n: u\n\n  uuencodeされた文字列\n//emlist[][ruby]{\n[\"\"].pack(\"u\")           # => \"\"\n[\"a\"].pack(\"u\")          # => \"!80``\\n\"\n[\"abc\"].pack(\"u\")        # => \"#86)C\\n\"\n[\"abcd\"].pack(\"u\")       # => \"$86)C9```\\n\"\n[\"a\"*45].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n\"\n[\"a\"*46].pack(\"u\")       # => \"M86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A86%A\\n!80``\\n\"\n[\"abcdefghi\"].pack(\"u6\") # => \"&86)C9&5F\\n#9VAI\\n\"\n//}\n\n: U\n\n  UTF-8\n//emlist[][ruby]{\n[0].pack(\"U\")                               # => \"\\u0000\"\n[1].pack(\"U\")                               # => \"\\u0001\"\n[0x7f].pack(\"U\")                            # => \"\\u007F\"\n[0x80].pack(\"U\")                            # => \"\\u0080\"\n[0x7fffffff].pack(\"U\")                      # => \"\\xFD\\xBF\\xBF\\xBF\\xBF\\xBF\"\n[0x80000000].pack(\"U\")                      # => RangeError: pack(U): value out of range\n[0,256,65536].pack(\"U3\").b                  # => \"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\"\n\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U3\") # => [0, 256, 65536]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U\")  # => [0]\n\"\\x00\\xC4\\x80\\xF0\\x90\\x80\\x80\".unpack(\"U*\") # => [0, 256, 65536]\n//}\n\n: w\n\n  BER圧縮整数\n\n  1バイトあたり7ビットを使用して必要最小限のバイト数で任意サイズの\n  0以上の整数を表す数値表現。各バイトの最上位ビットはデータの最後\n  を除いて必ず1が立っている(つまり最上位ビットはどこまでデータがあ\n  るかを示している)。\n\n  ISO/IEC 8825-1:1995 : Information technology−ASN.1 encoding rules : Specification of Basic Encoding Rules(BER) に定められる整数の符号化方法。\n\n//emlist[][ruby]{\n[0].pack(\"w\")             # => \"\\x00\"\n[1].pack(\"w\")             # => \"\\x01\"\n[127].pack(\"w\")           # => \"\\x7F\"\n[128].pack(\"w\")           # => \"\\x81\\x00\"\n[0x3fff].pack(\"w\")        # => \"\\xFF\\x7F\"\n[0x4000].pack(\"w\")        # => \"\\x81\\x80\\x00\"\n[0x3fffffff].pack(\"w\")    # => \"\\x83\\xFF\\xFF\\xFF\\x7F\"\n[0x40000000].pack(\"w\")    # => \"\\x84\\x80\\x80\\x80\\x00\"\n[0xffffffff].pack(\"w\")    # => \"\\x8F\\xFF\\xFF\\xFF\\x7F\"\n[0x100000000].pack(\"w\")   # => \"\\x90\\x80\\x80\\x80\\x00\"\n\n\"\\x00\".unpack(\"w\")              # => [0]\n\"\\x00\\x81\\x00\\x01\".unpack(\"w*\") # => [0, 128, 1]\n//}\n\n  なお、BER圧縮整数でエンコードした結果は大小関係を保存しない。\n  たとえば、[0x3fff].pack(\"w\") > [0x4000].pack(\"w\") である。\n\n: x\n\n  ヌルバイト（pack）／1バイト読み飛ばし（unpack）\n//emlist[][ruby]{\n[97, 98].pack(\"CxC\")    # => \"a\\x00b\"\n[97, 98].pack(\"Cx3C\")   # => \"a\\x00\\x00\\x00b\"\n\n\"abc\".unpack(\"CxC\")  # => [97, 99]\n\"abc\".unpack(\"Cx3C\") # => ArgumentError: x outside of string\n//}\n\n: X\n\n  1バイト後退\n//emlist[][ruby]{\n[97, 98, 99].pack(\"CCXC\") # => \"ac\"\n\n\"abcdef\".unpack(\"x*XC\") # => [102]\n//}\n\n: @\n\n  絶対位置への移動\n//emlist[][ruby]{\n[97, 98].pack(\"C @3 C\") # => \"a\\x00\\x00b\"\n\n\"abcd\".unpack(\"C @3 C\") # => [97, 100]\n//}\n\n: j\n\nintptr_t (ポインタの幅の符号つき整数, エンディアンに依存)\n\n: J\n\nuintptr_t (ポインタの幅の符号なし整数, エンディアンに依存)\n\n=== 使用例\n\n以下、pack/unpack の使用例の一部です。\n\npack を使用しなくても同じことができる場合はその例も載せています。\npack は暗号になりやすい面があることを考慮し、pack を使いたくない人\nに別解を示すためです。\n\n: 数値(文字コード)の配列を文字列に変換する例\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"cccc\")  # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c4\")    # => \"Ruby\"\n[82, 117, 98, 121].pack(\"c*\")    # => \"Ruby\"\n\ns = \"\"\n[82, 117, 98, 121].each {|c| s << c}\ns    # => \"Ruby\"\n\n[82, 117, 98, 121].collect {|c| sprintf \"%c\", c}.join   # => \"Ruby\"\n\n[82, 117, 98, 121].inject(\"\") {|s, c| s << c}    # => \"Ruby\"\n//}\n\n: 文字列を数値(文字コード)の配列に変換する例\n//emlist[][ruby]{\n\"Ruby\".unpack('C*')    # => [82, 117, 98, 121]\n\na = []\n\"Ruby\".each_byte {|c| a << c}\na    # => [82, 117, 98, 121]\n//}\n\n: \"x\" でヌルバイトを埋めることができる\n//emlist[][ruby]{\n[82, 117, 98, 121].pack(\"ccxxcc\")    # => \"Ru\\x00\\x00by\"\n//}\n\n: \"x\" で文字を読み飛ばす事が出来る\n//emlist[][ruby]{\n\"Ru\\x00\\x00by\".unpack('ccxxcc')    # => [82, 117, 98, 121]\n//}\n\n: Hexダンプを数値の配列に変換する例\n//emlist[][ruby]{\n\"61 62 63 64 65 66\".delete(' ').lines.pack('H*').unpack('C*')\n# => [97, 98, 99, 100, 101, 102]\n\n\"61 62 63 64 65 66\".split.collect {|c| c.hex}\n# => [97, 98, 99, 100, 101, 102]\n//}\n\n: バイナリと16進数のpackでは長さ指定は生成されるバイト数ではなく、ビットやニブルの個数を表す\n//emlist[][ruby]{\n[0b01010010, 0b01110101, 0b01100010, 0b01111001].pack(\"C4\")\n# => \"Ruby\"\n[\"01010010011101010110001001111001\"].pack(\"B32\") # 8 bits * 4\n# => \"Ruby\"\n\n[0x52, 0x75, 0x62, 0x79].pack(\"C4\")\n# => \"Ruby\"\n[\"52756279\"].pack(\"H8\")  # 2 nybbles * 4\n# => \"Ruby\"\n//}\n\n: テンプレート文字'a'の長さ指定は1つの文字列だけに適用される\n//emlist[][ruby]{\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a4\")\n# => \"RUBY\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"aaaa\")\n# => \"Ruby\"\n\n[\"RUBY\", \"u\", \"b\", \"y\"].pack(\"a*aaa\")\n# => \"RUBYuby\"\n//}\n\n: テンプレート文字\"a\"は、長さが足りない分をヌル文字で補う\n//emlist[][ruby]{\n[\"Ruby\"].pack(\"a8\")\n# => \"Ruby\\x00\\x00\\x00\\x00\"\n//}\n\n: リトルエンディアンとビッグエンディアン\n//emlist[][ruby]{\n[1,2].pack(\"s2\")\n# => \"\\x01\\x00\\002\\x00\" # リトルエンディアンのシステムでの出力\n# => \"\\x00\\x01\\x00\\002\" # ビッグエンディアンのシステムでの出力\n\n[1,2].pack(\"n2\")\n# => \"\\x00\\x01\\x00\\002\" # システムによらずビッグエンディアン\n\n[1,2].pack(\"v2\")\n# => \"\\x01\\x00\\002\\x00\" # システムによらずリトルエンディアン\n//}\n\n: ネットワークバイトオーダの signed long\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\")[0]\nif n[31] == 1\n  n = -((n ^ 0xffff_ffff) + 1)\nend\nn # => -2\n//}\n\n: ネットワークバイトオーダの signed long(その2)\n//emlist[][ruby]{\ns = \"\\xFF\\xFF\\xFF\\xFE\"\nn = s.unpack(\"N\").pack(\"l\").unpack(\"l\")[0]\nn # => -2\n//}\n\n: IPアドレス\n//emlist[][ruby]{\nrequire 'socket'\nofficial_hostname, alias_hostnames, address_family, *address_list = Socket.gethostbyname(\"localhost\")\naddress_list.find {|address| address.size == 4 }.unpack(\"C4\").join(\".\")\n# => \"127.0.0.1\"\n\n\"127.0.0.1\".split(\".\").collect {|c| c.to_i}.pack(\"C4\")\n# => \"\\x7F\\x00\\x00\\x01\"\n//}\n\n: sockaddr_in 構造体\n//emlist[][ruby]{\nrequire 'socket'\n[Socket::AF_INET,\n Socket.getservbyname('echo'),\n 127, 0, 0, 1].pack(\"s n C4 x8\")\n# => \"\\x02\\x00\\x00\\a\\x7F\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n//}\n\n  pack/unpack を使う代わりに\n  Socket.pack_sockaddr_in,\n  Socket.unpack_sockaddr_in メソッドがあります。\n\n: '\\0'終端文字列のアドレス\n\n  テンプレート文字 \"p\" や \"P\" は、C 言語レベルのインタフェースのた\n  めにあります(例えば IO#ioctl)。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\")    # => \"xp\\xC2\\x85\\vV\\x00\\x00\"\n//}\n\n  結果の文字列はゴミに見えますが、実際は文字列\"foo\\0\"を指すアドレ\n  ス(のバイナリ表現)です。以下のようにすれば見慣れた表記で見ること\n  が出来ます\n//emlist[][ruby]{\nprintf \"%#014x\\n\", \"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"J\")[0] # => 0x560b85c27078\n//}\n\n  アドレスが指す先のオブジェクト(この例で \"foo\\0\") は、pack の結\n  果が GC されるまではGCされないことが保証されています。\n\n  unpack(\"p\"), unpack(\"P\") は、pack の結果からしか unpack できません。\n//emlist[][ruby]{\n[\"foo\"].pack(\"p\").unpack(\"p\") # => [\"foo\"]\n\"xp\\xC2\\x85\\vV\\x00\\x00\".unpack(\"p\")\n# => ArgumentError: no associated pointer\n//}\n  \"p\" や \"P\" は、nil を特別に扱い NULL\n  ポインタとして解釈します。(以下は、64bitマシンで一般的な結果)\n//emlist[][ruby]{\n[nil].pack(\"p\")        # => \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\".unpack(\"p\") # => [nil]\n//}\n\n: 構造体のアドレス\n\n  例えば、\n//emlist{\n      struct {\n        int   a;\n        short b;\n        long  c;\n      } v = {1,2,3};\n//}\n  を表す文字列は\n//emlist[][ruby]{\nv = [1,2,3].pack(\"i!s!l!\")\n//}\n  です。(byte alignment の問題から実際は適当な padding が必要に\n  なるかもしれません)\n\n  この構造体を指すアドレスは\n//emlist[][ruby]{\n[v].pack(\"P\")  # => \"\\xC0\\xCC2L\\fV\\x00\\x00\"\n//}\n  で得られます。\n\n: UTF-8からUCS-2への変換 (サロゲートを処理していないので UTF-16 とはいえない)\n\n  リトルエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"v*\") # => \"C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\\x00\"\n//}\n  ビッグエンディアン:\n//emlist[][ruby]{\n(\"Comments\").unpack(\"U*\").pack(\"n*\") # => \"\\x00C\\x00o\\x00m\\x00m\\x00e\\x00n\\x00t\\x00s\"\n//}\n\n@see String#unpack, String#unpack1",
          "snippets": [
            "ます。\n                指定した場合は返値も指定した文字列オブジェクトになります。\n\n\n以下にあげるものは、<span class=\"keyword\">Array</span>#pack、String#unpack、String#unpack1\nのテンプレート文字の一覧です。テンプレート文字は後に「長さ」を表す数字\nを",
            " endian int32_t\n  l!&lt;: little endian signed long\n//}\n\n=== 各テンプレート文字の説明\n\n説明中、<span class=\"keyword\">Array</span>#pack と String#unpack で違いのあるものは `/' で区切って\n「<span class=\"keyword\">Array</span>#pack の説明 / String#unpack の説明」としています。\n\n: a\n\n  ASCII文字列(ヌル文字を詰",
            "121].pack(&quot;cccc&quot;)  # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c4&quot;)    # =&gt; &quot;Ruby&quot;\n[82, 117, 98, 121].pack(&quot;c*&quot;)    # =&gt; &quot;Ruby&quot;\n\ns = &quot;&quot;\n[82, 117, 98, 121].<span class=\"keyword\">each</span> {|c| s &lt;&lt; c}\ns    # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].collect {|c| sprintf &quot;%c&quot;, c}.join   # =&gt; &quot;Ruby&quot;\n\n[82, 117, 98, 121].inject(&quot;&quot;) {|s, c| s &lt;&lt; c}  "
          ]
        }
      ],
      "related_entries": [
        {
          "key": "Array",
          "label": "Array",
          "type": "class",
          "url": "https://rurema.clear-code.com/api:v1/class:Array/"
        },
        {
          "key": "base64",
          "label": "base64",
          "type": "query",
          "url": "https://rurema.clear-code.com/api:v1/query:base64/"
        }
      ]
    }
  ]
}
